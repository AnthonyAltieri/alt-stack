// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`master OpenAPI fixture > snapshots full generated TypeScript output 1`] = `
"/**
 * This file was automatically generated from OpenAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

// Type assertion helper - verifies interface matches schema at compile time
type _AssertEqual<T, U> = [T] extends [U] ? ([U] extends [T] ? true : never) : never;

export type ScalarString = string;
export const ScalarStringSchema = z.string();

export type StringEmail = string;
export const StringEmailSchema = z.string().email().meta({"openapi":{"format":"email"}});

export type StringUrl = string;
export const StringUrlSchema = z.string().url().meta({"openapi":{"format":"url"}});

export type StringUri = string;
export const StringUriSchema = z.string().url().meta({"openapi":{"format":"uri"}});

export type StringUuid = string;
export const StringUuidSchema = z.string().uuid().meta({"openapi":{"format":"uuid"}});

export type StringColorHex = string;
export const StringColorHexSchema = z.string().regex(/^[a-fA-F0-9]{6}$/).meta({"openapi":{"format":"color-hex"}});

export type StringPattern = string;
export const StringPatternSchema = z.string().regex(/^[a-z]+$/).meta({"openapi":{"pattern":"^[a-z]+$"}});

export type StringMinMax = string;
export const StringMinMaxSchema = z.string().min(2).max(5);

export type StringAllConstraints = string;
export const StringAllConstraintsSchema = z.string().email().min(6).max(50).regex(/.*@example\\.com$/).meta({"openapi":{"format":"email","pattern":".*@example\\\\.com$"}});

export type StringEnum = "red" | "green" | "blue";
export const StringEnumSchema = z.enum(['red', 'green', 'blue']);

export type NumberMinMax = number;
export const NumberMinMaxSchema = z.number().min(0).max(10);

export type IntegerMinMax = number;
export const IntegerMinMaxSchema = z.number().int().min(1).max(100);

export type ScalarBoolean = boolean;
export const ScalarBooleanSchema = z.boolean();

export type ArrayOfStrings = Array<string>;
export const ArrayOfStringsSchema = z.array(z.string()).min(1).max(3);

export type ArrayOfUnion = Array<(string | number)>;
export const ArrayOfUnionSchema = z.array(z.union([z.string(), z.number()]));

export interface ObjectOptionalAndNullable {
  name: string;
  nickname?: (string | null);
  'x-rate-limit'?: number;
}
export const ObjectOptionalAndNullableSchema = z.object({ name: z.string().min(1), nickname: z.string().nullable().optional(), 'x-rate-limit': z.number().int().min(0).optional() });

export interface EmptyObjectStrict {
}
export const EmptyObjectStrictSchema = z.object({}).strict();

export interface FreeformObject {
}
export const FreeformObjectSchema = z.record(z.string(), z.unknown());

export interface Named {
  name: string;
}
export const NamedSchema = z.object({ name: z.string().min(1) });

export interface Timestamped {
  createdAt: string;
  updatedAt?: (string | null);
}
export const TimestampedSchema = z.object({ createdAt: z.string().datetime().meta({"openapi":{"format":"date-time"}}), updatedAt: z.string().datetime().meta({"openapi":{"format":"date-time"}}).nullable().optional() });

export interface Audited {
  createdBy: string;
  updatedBy?: (string | null);
}
export const AuditedSchema = z.object({ createdBy: z.string().min(1), updatedBy: z.string().nullable().optional() });

export interface Cat {
  kind: "cat";
  meows: boolean;
}
export const CatSchema = z.object({ kind: z.enum(['cat']), meows: z.boolean() }).strict();

export interface Dog {
  kind: "dog";
  barks: boolean;
}
export const DogSchema = z.object({ kind: z.enum(['dog']), barks: z.boolean() }).strict();

export interface UnauthorizedError {
  error: { code: "UNAUTHORIZED"; message: string };
}
export const UnauthorizedErrorSchema = z.object({ error: z.object({ code: z.enum(['UNAUTHORIZED']), message: z.string().min(1) }).strict() }).strict();

export interface NotFoundError {
  error: { code: "NOT_FOUND"; message: string };
}
export const NotFoundErrorSchema = z.object({ error: z.object({ code: z.enum(['NOT_FOUND']), message: z.string().min(1) }).strict() }).strict();

export interface ValidationError {
  error: { code: "VALIDATION_ERROR"; message: string };
  details?: Array<string>;
}
export const ValidationErrorSchema = z.object({ error: z.object({ code: z.enum(['VALIDATION_ERROR']), message: z.string().min(1) }).strict(), details: z.array(z.string()).optional() }).strict();

export interface Profile {
  bio: string;
  website?: (StringUrl | null);
  location?: (string | null);
}
export const ProfileSchema = z.object({ bio: z.string().max(160), website: StringUrlSchema.nullable().optional(), location: z.string().nullable().optional() }).strict();

export type ArrayOfUuids = Array<StringUuid>;
export const ArrayOfUuidsSchema = z.array(StringUuidSchema);

export interface ImplicitObject {
  id: StringUuid;
}
export const ImplicitObjectSchema = z.object({ id: StringUuidSchema }).strict();

export interface ObjectSimple {
  id: StringUuid;
  count?: IntegerMinMax;
}
export const ObjectSimpleSchema = z.object({ id: StringUuidSchema, count: IntegerMinMaxSchema.optional() });

export type NamedTimestamped = (Named & Timestamped);
export const NamedTimestampedSchema = z.intersection(NamedSchema, TimestampedSchema);

export type FullAuditRecord = (Named & Timestamped & Audited);
export const FullAuditRecordSchema = z.intersection(z.intersection(NamedSchema, TimestampedSchema), AuditedSchema);

export type Pet = (Cat | Dog);
export const PetSchema = z.union([CatSchema, DogSchema]);

export interface CreateUser {
  name: string;
  email: StringEmail;
  profile?: (Profile | null);
}
export const CreateUserSchema = z.object({ name: z.string().min(1), email: StringEmailSchema, profile: ProfileSchema.nullable().optional() }).strict();

export interface User {
  id: StringUuid;
  name: string;
  email: StringEmail;
  roles: Array<StringEnum>;
  profile?: (Profile | null);
}
export const UserSchema = z.object({ id: StringUuidSchema, name: z.string().min(1), email: StringEmailSchema, roles: z.array(StringEnumSchema).min(1), profile: ProfileSchema.nullable().optional() }).strict();

export interface PetAdoptedEvent {
  eventType: "pet.adopted";
  data: Pet;
}
export const PetAdoptedEventSchema = z.object({ eventType: z.enum(['pet.adopted']), data: PetSchema }).strict();

export interface UserCreatedEvent {
  eventType: "user.created";
  data: User;
}
export const UserCreatedEventSchema = z.object({ eventType: z.enum(['user.created']), data: UserSchema }).strict();

export type NullableUser = (User | null);
export const NullableUserSchema = UserSchema.nullable();

export type Event = (UserCreatedEvent | PetAdoptedEvent);
export const EventSchema = z.union([UserCreatedEventSchema, PetAdoptedEventSchema]);

// Compile-time type assertions - ensure interfaces match schemas
type _AssertScalarString = _AssertEqual<ScalarString, z.infer<typeof ScalarStringSchema>>;
type _AssertStringEmail = _AssertEqual<StringEmail, z.infer<typeof StringEmailSchema>>;
type _AssertStringUrl = _AssertEqual<StringUrl, z.infer<typeof StringUrlSchema>>;
type _AssertStringUri = _AssertEqual<StringUri, z.infer<typeof StringUriSchema>>;
type _AssertStringUuid = _AssertEqual<StringUuid, z.infer<typeof StringUuidSchema>>;
type _AssertStringColorHex = _AssertEqual<StringColorHex, z.infer<typeof StringColorHexSchema>>;
type _AssertStringPattern = _AssertEqual<StringPattern, z.infer<typeof StringPatternSchema>>;
type _AssertStringMinMax = _AssertEqual<StringMinMax, z.infer<typeof StringMinMaxSchema>>;
type _AssertStringAllConstraints = _AssertEqual<StringAllConstraints, z.infer<typeof StringAllConstraintsSchema>>;
type _AssertStringEnum = _AssertEqual<StringEnum, z.infer<typeof StringEnumSchema>>;
type _AssertNumberMinMax = _AssertEqual<NumberMinMax, z.infer<typeof NumberMinMaxSchema>>;
type _AssertIntegerMinMax = _AssertEqual<IntegerMinMax, z.infer<typeof IntegerMinMaxSchema>>;
type _AssertScalarBoolean = _AssertEqual<ScalarBoolean, z.infer<typeof ScalarBooleanSchema>>;
type _AssertArrayOfStrings = _AssertEqual<ArrayOfStrings, z.infer<typeof ArrayOfStringsSchema>>;
type _AssertArrayOfUnion = _AssertEqual<ArrayOfUnion, z.infer<typeof ArrayOfUnionSchema>>;
type _AssertObjectOptionalAndNullable = _AssertEqual<ObjectOptionalAndNullable, z.infer<typeof ObjectOptionalAndNullableSchema>>;
type _AssertEmptyObjectStrict = _AssertEqual<EmptyObjectStrict, z.infer<typeof EmptyObjectStrictSchema>>;
type _AssertFreeformObject = _AssertEqual<FreeformObject, z.infer<typeof FreeformObjectSchema>>;
type _AssertNamed = _AssertEqual<Named, z.infer<typeof NamedSchema>>;
type _AssertTimestamped = _AssertEqual<Timestamped, z.infer<typeof TimestampedSchema>>;
type _AssertAudited = _AssertEqual<Audited, z.infer<typeof AuditedSchema>>;
type _AssertCat = _AssertEqual<Cat, z.infer<typeof CatSchema>>;
type _AssertDog = _AssertEqual<Dog, z.infer<typeof DogSchema>>;
type _AssertUnauthorizedError = _AssertEqual<UnauthorizedError, z.infer<typeof UnauthorizedErrorSchema>>;
type _AssertNotFoundError = _AssertEqual<NotFoundError, z.infer<typeof NotFoundErrorSchema>>;
type _AssertValidationError = _AssertEqual<ValidationError, z.infer<typeof ValidationErrorSchema>>;
type _AssertProfile = _AssertEqual<Profile, z.infer<typeof ProfileSchema>>;
type _AssertArrayOfUuids = _AssertEqual<ArrayOfUuids, z.infer<typeof ArrayOfUuidsSchema>>;
type _AssertImplicitObject = _AssertEqual<ImplicitObject, z.infer<typeof ImplicitObjectSchema>>;
type _AssertObjectSimple = _AssertEqual<ObjectSimple, z.infer<typeof ObjectSimpleSchema>>;
type _AssertNamedTimestamped = _AssertEqual<NamedTimestamped, z.infer<typeof NamedTimestampedSchema>>;
type _AssertFullAuditRecord = _AssertEqual<FullAuditRecord, z.infer<typeof FullAuditRecordSchema>>;
type _AssertPet = _AssertEqual<Pet, z.infer<typeof PetSchema>>;
type _AssertCreateUser = _AssertEqual<CreateUser, z.infer<typeof CreateUserSchema>>;
type _AssertUser = _AssertEqual<User, z.infer<typeof UserSchema>>;
type _AssertPetAdoptedEvent = _AssertEqual<PetAdoptedEvent, z.infer<typeof PetAdoptedEventSchema>>;
type _AssertUserCreatedEvent = _AssertEqual<UserCreatedEvent, z.infer<typeof UserCreatedEventSchema>>;
type _AssertNullableUser = _AssertEqual<NullableUser, z.infer<typeof NullableUserSchema>>;
type _AssertEvent = _AssertEqual<Event, z.infer<typeof EventSchema>>;

// Common Error Schemas (deduplicated)
export const GetUsersId401ErrorResponse = UnauthorizedErrorSchema;
export const GetUsersId200Response = UserSchema;

// Route Schemas
export const GetUsersIdParams = z.object({ id: z.string().uuid().meta({"openapi":{"format":"uuid"}}) });
export const GetUsersIdQuery = z.object({ includeProfile: z.boolean().optional() });
export const GetUsersIdHeaders = z.object({ 'x-trace-id': z.string().min(8) });
export const GetUsersId404ErrorResponse = NotFoundErrorSchema;
export const PostUsersBody = CreateUserSchema;
export const PostUsers201Response = GetUsersId200Response;
export const PostUsers400ErrorResponse = ValidationErrorSchema;
export const PostUsers401ErrorResponse = GetUsersId401ErrorResponse;
export const GetPets200Response = PetSchema;
export const GetPets401ErrorResponse = GetUsersId401ErrorResponse;
export const GetStats200Response = z.object({ count: z.number().int().min(0) }).strict();
export const GetStats401ErrorResponse = GetUsersId401ErrorResponse;

export const Request = {
  '/users/{id}': {
    GET: {
      params: GetUsersIdParams,
      query: GetUsersIdQuery,
      headers: GetUsersIdHeaders,
    },
  },
  '/users': {
    POST: {
      body: PostUsersBody,
    },
  },
} as const;

export const Response = {
  '/users/{id}': {
    GET: {
      '200': GetUsersId200Response,
      '401': GetUsersId401ErrorResponse,
      '404': GetUsersId404ErrorResponse,
    },
  },
  '/users': {
    POST: {
      '201': GetUsersId200Response,
      '400': PostUsers400ErrorResponse,
      '401': GetUsersId401ErrorResponse,
    },
  },
  '/pets': {
    GET: {
      '200': GetPets200Response,
      '401': GetUsersId401ErrorResponse,
    },
  },
  '/stats': {
    GET: {
      '200': GetStats200Response,
      '401': GetUsersId401ErrorResponse,
    },
  },
} as const;"
`;
