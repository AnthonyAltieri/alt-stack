// File: client/core-concepts/basic-usage

# Basic Usage

Learn how to use the API client for making type-safe requests.

## Creating a Client

Use `createApiClient` to create a client instance:

```typescript
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
  headers: {
    Authorization: "Bearer token",
  },
});
```

## Making Requests

The client provides methods for different HTTP methods:

### GET Requests

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  query: { include: "profile" },
});
```

### POST Requests

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "alice@example.com",
  },
});
```

### PUT Requests

```typescript
const result = await client.put("/users/{id}", {
  params: { id: "123" },
  body: { name: "Alice Updated", email: "alice@example.com" },
});
```

### PATCH Requests

```typescript
const result = await client.patch("/users/{id}", {
  params: { id: "123" },
  body: { email: "newemail@example.com" },
});
```

### DELETE Requests

```typescript
const result = await client.delete("/users/{id}", {
  params: { id: "123" },
});
```

## Handling Responses

All methods return a result object that can be either a success or error:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // Type-safe access to response body
  console.log(result.body);
  console.log(result.code); // Status code string, e.g., "200"
  console.log(result.raw); // Raw Response object for advanced use
} else {
  // Handle error - check if it's a defined error or unexpected
  if (typeof result.code === "string") {
    // Server returned a defined error response
    console.error(result.code, result.error);
  } else {
    // Unexpected error (network, validation, etc.)
    console.error(result.error);
  }
}
```

## Request Options

You can pass additional options to requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  headers: {
    "X-Custom-Header": "value",
  },
  timeout: 5000, // milliseconds
  retries: 3, // number of retry attempts
  shouldRetry: ({ response }) => response?.status >= 500, // custom retry logic
});
```

| Option | Type | Description |
|--------|------|-------------|
| `params` | `object` | Path parameters to interpolate into the URL |
| `query` | `object` | Query parameters to append to the URL |
| `body` | `object` | Request body (required for POST, PUT, PATCH) |
| `headers` | `object` | Additional headers to include |
| `timeout` | `number` | Request timeout in milliseconds |
| `retries` | `number` | Number of retry attempts |
| `shouldRetry` | `function` | Custom retry logic callback |

See [Error Handling](./error-handling.md#custom-retry-logic) for more details on `shouldRetry`.

---

// File: client/core-concepts/error-handling

# Error Handling

The client provides comprehensive error handling with typed error responses.

## Response Types

Every request returns a result that can be one of three types:

1. **Success Response** - Request succeeded
2. **Error Response** - Server returned an error response
3. **Unexpected Error Response** - Network, validation, or unexpected error

## Success Response

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body);
  // result.code contains the status code (e.g., "200", "201")
}
```

## Error Response

When the server returns an error response (non-2xx status):

```typescript
const result = await client.post("/users", {
  body: { name: "Alice" },
});

if (!result.success && typeof result.code === "string") {
  // Server error response (typed error from Response schemas)
  // result.error is typed based on the error schema for this status code
  console.error(result.code); // HTTP status code (e.g., "404", "500")
  console.error(result.error); // Typed error body based on schema
}
```

## Unexpected Error Response

For network errors, validation errors, or other unexpected issues:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (!result.success && typeof result.code === "number") {
  // Unexpected error response (not defined in Response schemas)
  if (result.error instanceof Error) {
    console.error(result.error.message); // Error message
    // error may be UnexpectedApiClientError with additional properties
  } else {
    console.error("Unexpected error:", result.error);
  }
  console.error(result.code); // HTTP status code as number
}
```

## Error Classes

The client exports error classes for programmatic handling:

| Class | Description |
|-------|-------------|
| `ApiClientError` | Base class for all client errors |
| `ValidationError` | Request/response validation failed |
| `UnexpectedApiClientError` | Network error or unexpected response |
| `TimeoutError` | Request exceeded timeout |

```typescript
import {
  ValidationError,
  UnexpectedApiClientError,
  TimeoutError,
  ApiClientError,
} from "@alt-stack/http-client-fetch";

try {
  await client.get("/users/{id}", {
    params: { id: 123 },
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation error:", error.validationErrors);
  } else if (error instanceof TimeoutError) {
    console.error(`Request timed out after ${error.timeout}ms`);
  } else if (error instanceof UnexpectedApiClientError) {
    console.error("Request failed:", error.message, error.code);
  } else if (error instanceof ApiClientError) {
    console.error("Client error:", error.message);
  }
}
```

## Retry Logic

The client includes built-in retry logic with exponential backoff:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3, // Will retry up to 3 times
});
```

By default, retries are automatically performed for:
- Network errors

Retries are **not** performed by default for:
- Validation errors
- Client errors (4xx status codes)
- Server errors (5xx status codes) - these are valid HTTP responses

### Custom Retry Logic

Use the `shouldRetry` option to customize retry behavior:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3,
  shouldRetry: ({ attempt, error, response }) => {
    // Retry on 5xx server errors
    if (response?.status >= 500) return true;
    // Retry on rate limiting
    if (response?.status === 429) return true;
    // Retry on network errors
    if (error) return true;
    return false;
  },
});
```

The `shouldRetry` callback receives a context object with:
- `attempt` - Current attempt number (0-indexed)
- `error` - Error thrown during request (network errors, timeouts)
- `response` - HTTP response received (status, statusText, data)

#### Examples

**Retry on 5xx server errors:**

```typescript
shouldRetry: ({ response }) => response?.status !== undefined && response.status >= 500
```

**Limit retries regardless of `retries` option:**

```typescript
shouldRetry: ({ attempt }) => attempt < 2
```

**Retry on specific error codes:**

```typescript
shouldRetry: ({ response }) => {
  const retryableCodes = [500, 502, 503, 504, 429];
  return response?.status !== undefined && retryableCodes.includes(response.status);
}
```

**Custom logic combining error and response:**

```typescript
shouldRetry: ({ error, response }) => {
  // Always retry network errors
  if (error) return true;
  // Retry rate limits and server errors
  if (response?.status === 429 || (response?.status ?? 0) >= 500) return true;
  return false;
}
```

## Timeouts

Set a timeout for requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  timeout: 5000, // 5 seconds
});
```

If the request exceeds the timeout, a `TimeoutError` is thrown with the `timeout` property indicating the configured timeout in milliseconds.

---

// File: client/core-concepts/validation

# Validation

The client automatically validates request parameters, query strings, and request bodies using Zod schemas.

## Automatic Validation

When you make a request, the client automatically validates:

1. **Path parameters** - Validated against the `params` schema
2. **Query parameters** - Validated against the `query` schema
3. **Request body** - Validated against the `body` schema
4. **Response data** - Validated against the `output` schema

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "invalid-email", // ❌ This will throw ValidationError
  },
});
```

## Validation Errors

If validation fails, the client throws a `ValidationError`:

```typescript
import { ValidationError } from "@alt-stack/http-client-fetch";

try {
  await client.get("/users/{id}", {
    params: { id: 123 }, // ❌ Should be string
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation failed:", error.message);
    console.error("Validation errors:", error.validationErrors);
  }
}
```

The `ValidationError` includes:
- `message`: Human-readable error message
- `validationErrors`: Validation error details from Zod
- `endpoint`: The endpoint that failed validation
- `method`: The HTTP method that failed validation

## Type Safety

TypeScript ensures you pass the correct types at compile time:

```typescript
// ✅ TypeScript knows this is correct
await client.get("/users/{id}", {
  params: { id: "123" },
});

// ❌ TypeScript error - id must be string
await client.get("/users/{id}", {
  params: { id: 123 },
});
```

## Response Validation

Response data is automatically validated when received:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is validated and typed
  console.log(result.body.name); // ✅ Type-safe
}
```

If the response doesn't match the expected schema, an error is returned in the result.

---

// File: client/getting-started/installation

# Installation

Choose the HTTP client binding that fits your needs:

## Using Native Fetch

```bash
pnpm add @alt-stack/http-client-fetch zod
```

## Using Ky

```bash
pnpm add @alt-stack/http-client-ky zod
```

## Peer Dependencies

- **zod**: `^4.0.0`

## Requirements

1. A server built with `@alt-stack/server-hono` that exposes an OpenAPI spec
2. Generated `Request` and `Response` types from the OpenAPI spec (see [Server Integration](../guides/server-integration))

## Package Comparison

| Package | Description | Best For |
|---------|-------------|----------|
| `@alt-stack/http-client-fetch` | Native fetch API | Simple use cases, browser/Node.js |
| `@alt-stack/http-client-ky` | Ky library | Advanced features like hooks, pre-configured instances |

---

// File: client/getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates how to use the type-safe API client.

## Basic Example

First, ensure your server generates an OpenAPI spec and Request/Response types:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });
const openApiSpec = generateOpenAPISpec({ api: router }, {
  title: "My API",
  version: "1.0.0",
});

export { openApiSpec };
export default app;
```

Then generate Request and Response types from the OpenAPI spec (see [Server Integration](../guides/server-integration) for details), and use the client:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

// Make a type-safe API call
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // TypeScript knows the shape of result.body
  console.log(result.body.name); // ✅ Type-safe
  console.log(result.body.email); // ✅ Type-safe
  // Access raw Response if needed
  console.log(result.raw.headers.get("x-request-id"));
} else {
  // Handle error
  console.error(result.error);
}
```

## Features

- **Type-safe**: Full TypeScript inference from server types
- **Validation**: Automatic runtime validation using Zod schemas
- **Error handling**: Typed error responses
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters
- **Raw response access**: Access underlying Response/KyResponse for advanced use cases

---

// File: client/guides/server-integration

# Server Integration

Learn how to integrate the client with your Altstack server.

## Overview

To use the client with your server, you need:

1. Generate an OpenAPI spec from your server router
2. Generate `Request` and `Response` types from the OpenAPI spec
3. Create a client instance with these types

## Step 1: Generate OpenAPI Spec

On your server, generate the OpenAPI spec:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });

// Generate OpenAPI spec
const openApiSpec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
  }
);

export { openApiSpec };
export default app;
```

## Step 2: Generate Request and Response Types

Use the `@alt-stack/zod-openapi` package to generate TypeScript types:

```typescript
// generate-types.ts
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";
import { openApiSpec } from "./server.js";
import { writeFileSync } from "fs";

const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});

writeFileSync("./src/generated-types.ts", generatedCode);
```

This generates a file with:
- Zod schemas for all request parameters, query strings, bodies, and responses
- `Request` object with lookup for request schemas
- `Response` object with lookup for response schemas organized by status code

Example generated output:

```typescript
// generated-types.ts
import { z } from "zod";

export const GetUsersIdParamsSchema = z.object({
  id: z.string(),
});

export const GetUsersId200ResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

export const GetUsersId404ErrorResponseSchema = z.object({
  error: z.object({
    code: z.literal("NOT_FOUND"),
    message: z.string(),
  }),
});

export const Request = {
  "/users/{id}": {
    GET: {
      params: GetUsersIdParamsSchema,
    },
  },
} as const;

export const Response = {
  "/users/{id}": {
    GET: {
      "200": GetUsersId200ResponseSchema,
      "404": GetUsersId404ErrorResponseSchema,
    },
  },
} as const;
```

## Step 3: Create Client

Now create the client using the generated types:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

export { client };
```

## Step 4: Use the Client

Now you can make type-safe API calls:

```typescript
import { client } from "./client.js";

// Type-safe GET request
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body.name); // ✅ Type-safe
}
```

## Keeping Types in Sync

It's recommended to regenerate types whenever you change your server routes. You can:

1. **Manual regeneration**: Run your type generation script when routes change
2. **Watch mode**: Use a file watcher to regenerate on route changes
3. **Build step**: Include type generation in your build process

## Sharing Types Between Projects

If your client is in a separate project from your server:

1. Export the OpenAPI spec from your server project
2. Share it via npm package, git submodule, or API endpoint
3. Generate types in your client project from the shared spec

Example: Export spec as JSON endpoint:

```typescript
// server.ts
const docsRouter = createDocsRouter({ api: router });
app.route("/docs", docsRouter);

// Access at /docs/openapi.json
```

Then fetch and generate types in client:

```typescript
// client project
const response = await fetch("http://localhost:3000/docs/openapi.json");
const openApiSpec = await response.json();
const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});
```

---

// File: core-concepts/combining-routers

# Combining Routers

Organize your API by combining multiple routers using the new tRPC-style `router()` function. Routers can be nested, and paths combine automatically.

## Basic Router Combination

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

// User routes
const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      const { input } = opts;
      return { id: input.id, name: "Alice" };
    }),

  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .post((opts) => {
      return { id: "1" };
    }),
});

// Post routes
const postsRouter = router({
  list: publicProcedure
    .output(
      z.array(
        z.object({
          id: z.string(),
          title: z.string(),
        })
      )
    )
    .get(() => {
      return [{ id: "1", title: "Hello World" }];
    }),
});

// Combine routers - keys become path prefixes
const appRouter = router({
  users: userRouter,  // Routes prefixed with /users
  posts: postsRouter, // Routes prefixed with /posts
});

const app = createServer({
  api: appRouter,
});

// Routes available at:
// - GET /api/users/{id}
// - POST /api/users/create
// - GET /api/posts/list
```

## Nested Routers

Routers can be nested within other routers. Paths combine automatically:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const productRouter = router({
  "favorites/me": publicProcedure.get(() => {
    return [];
  }),
});

const userRouter = router({
  profile: publicProcedure.get(() => {
    return { id: "1" };
  }),
});

// Nested routers
const appRouter = router({
  products: productRouter,  // /products/favorites/me
  users: userRouter,        // /users/profile
});

// Final paths:
// - GET /products/favorites/me
// - GET /users/profile
```

## Multiple Routers with Same Prefix

You can pass arrays of routers for the same prefix in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const app = createServer({
  api: [v1Router, v2Router], // Both routers prefixed with /api
});
```

This is useful for versioning APIs or organizing routes by feature.

## Nested Routes with Compound Paths

To achieve nested routes like `/api/v1/*` and `/api/v2/*`, use compound prefixes in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const adminRouter = router({
  settings: publicProcedure.get(() => []),
});

const app = createServer({
  "api/v1": v1Router,
  "api/v2": v2Router,
  admin: adminRouter,
});
```

Results in routes like:
- `/api/v1/users` - All v1Router routes
- `/api/v2/users` - All v2Router routes
- `/admin/settings` - All adminRouter routes

---

// File: core-concepts/custom-context

# Custom Context

Define custom context (similar to tRPC) to pass data like database connections or authentication info.

## Defining Context

Create a context type and a function to create it:

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import type { Context } from "hono";
import { z } from "zod";

// Define your context type
interface AppContext {
  db: Database;
  user: User | null;
}

// Create context function
async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthenticatedUser(c);
  return {
    db: database,
    user,
  };
}

// Create factory and router with context type
const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.db and ctx.user are typed and available
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    return {
      id: ctx.user.id,
      name: ctx.user.name,
    };
  });

// Create server with createContext
const app = createServer({
  users: router,
}, {
  createContext,
});
```

## Accessing Hono Context

Access the raw Hono context for advanced use cases:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
    }),
  })
  .handler((ctx) => {
    // Access raw Hono context
    const headers = ctx.hono.req.header();
    const ip = ctx.hono.req.header("x-forwarded-for");
    
    return { id: ctx.input.id };
  });
```

The `ctx.hono` property gives you full access to the underlying Hono context for headers, cookies, environment variables, and other advanced features.

---

// File: core-concepts/error-handling

# Error Handling

Define error schemas and use `ok()` / `err()` for type-safe error responses with the Result pattern.

For comprehensive documentation on the Result type, see the [Result documentation](/result).

## Defining Error Schemas

Specify error schemas using `.errors()`:

```typescript
import { init, router, ok, err } from "@alt-stack/server-hono";

const factory = init();

const userRouter = router({
  "{id}": factory.procedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(z.object({ id: z.string(), name: z.string() }))
    .errors({
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    })
    .get(({ input }) => {
      const user = findUser(input.params.id);

      if (!user) {
        // Return error with _httpCode for status code
        return err({
          _httpCode: 404 as const,
          data: {
            error: {
              code: "NOT_FOUND" as const,
              message: `User ${input.params.id} not found`,
            },
          },
        });
      }

      return ok(user);
    }),
});
```

## Multiple Error Types

Define multiple error status codes:

```typescript
const userRouter = router({
  "/": factory.procedure
    .input({
      body: z.object({ email: z.string().email() }),
    })
    .output(z.object({ id: z.string() }))
    .errors({
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
      409: z.object({
        error: z.object({
          code: z.literal("CONFLICT"),
          message: z.string(),
        }),
      }),
    })
    .post(({ input }) => {
      if (userExists(input.body.email)) {
        return err({
          _httpCode: 409 as const,
          data: {
            error: {
              code: "CONFLICT" as const,
              message: "User already exists",
            },
          },
        });
      }

      const user = createUser(input.body);
      return ok({ id: user.id });
    }),
});
```

## HTTP Status Codes

The `_httpCode` field determines the HTTP response status:

```typescript
return err({
  _httpCode: 404 as const,  // Sets HTTP status to 404
  data: { error: { code: "NOT_FOUND" as const, message: "Not found" } },
});
```

Without `_httpCode`, errors default to 500.

## Validation Errors

Input validation errors are automatic. When validation fails, a `400` response is returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

## Middleware Errors

Middleware can return `err()` just like handlers. Define errors with `.errors()` before `.use()`:

```typescript
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.user) {
      return err({
        _httpCode: 401 as const,
        data: {
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        },
      });
    }
    return next({ ctx: { user: ctx.user } });
  });
```

## See Also

- [Result Documentation](/result) - Complete guide to the Result type
- [Result Type](./result-type) - Server-specific Result usage

---

// File: core-concepts/input-validation

# Input Validation

Automatic validation of path parameters, query parameters, and request body using Zod schemas.

## Validation Sources

Inputs can be validated from three sources:

- **params**: Path parameters (e.g., `/users/{id}`)
- **query**: Query string parameters (e.g., `?limit=10&offset=0`)
- **body**: Request body for POST/PUT/PATCH requests

## Example

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .get((opts) => {
      // opts.input.params.id (from params)
      // opts.input.query.limit (from query)
      // opts.input.query.offset (from query)
      const { input } = opts;
      return { id: input.params.id };
    }),
});
```

## String Input Constraints

Since HTTP path parameters and query strings are always strings, `params` and `query` schemas are constrained at **compile-time** to only accept Zod types that can parse string input. This prevents runtime errors from invalid schema configurations.

| Schema | Input Type | Allowed in params/query? |
|--------|-----------|--------------------------|
| `z.string()` | `string` | ✅ |
| `z.enum(["a", "b"])` | `"a" \| "b"` | ✅ (string literals) |
| `z.coerce.number()` | `unknown` | ✅ (coerces strings) |
| `z.string().transform(...)` | `string` | ✅ (transform) |
| `z.codec(z.string(), ...)` | `string` | ✅ (Zod 4 codec) |
| `z.number()` | `number` | ❌ compile error |
| `z.boolean()` | `boolean` | ❌ compile error |
| `z.array(...)` | `T[]` | ❌ compile error |

```typescript
// ✅ Valid - all fields accept string input
.input({
  params: z.object({ id: z.string() }),
  query: z.object({ page: z.coerce.number() }),
})

// ❌ Compile error - z.number() doesn't accept string input
.input({
  query: z.object({ page: z.number() }), // Error!
})
```

:::tip Use z.coerce for numeric parameters
Since query strings are always strings, use `z.coerce.number()` instead of `z.number()` to automatically convert string values like `"42"` to numbers.
:::

### Zod 4 Codecs

[Zod 4 codecs](https://zod.dev/codecs) provide bidirectional transformation between input and output types. They work seamlessly with params/query since the input schema determines what the field accepts:

```typescript
// Define a codec that transforms ISO strings to Date objects
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString),
    encode: (date) => date.toISOString(),
  }
);

// ✅ Valid - input type is string (from z.iso.datetime())
.input({
  query: z.object({
    since: stringToDate, // Accepts: "2024-01-15T10:30:00.000Z"
  }),
})
.get(({ input }) => {
  // input.query.since is typed as Date (the output type)
  const date: Date = input.query.since;
  return { events: getEventsSince(date) };
})
```

:::note Body has no string constraint
The `body` field has no string input constraint since request bodies are parsed as JSON and can contain any JSON-serializable types.
:::

## Path Parameter Validation

When using path parameters in the route key (e.g., `{id}`), TypeScript enforces that you must provide a `params` schema with matching keys:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  // ✅ Valid - params.id matches {id} in path
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      return { id: opts.input.params.id };
    }),

  // ❌ TypeScript error - missing params.id for {id} path
  // "{id}": publicProcedure.get(() => ({ id: "1" })),
});
```

## Validation Errors

When validation fails, a `400` response is automatically returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

The handler is only called if all inputs pass validation, ensuring type safety and runtime safety.

## Combining Input Types

You can combine params, query, and body validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.enum(["profile", "posts"]).optional(),
      }),
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      const { input } = opts;
      // All inputs are validated and typed:
      // input.params.id (from params)
      // input.query.include (from query, optional)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

---

// File: core-concepts/middleware

# Middleware

Apply middleware to procedures to add cross-cutting concerns like authentication, logging, or rate limiting.

## Procedure-Level Middleware

Apply middleware to specific procedures using `.use()`:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .use(async (opts) => {
      // Log before handler
      const { ctx, next } = opts;
      console.log("Creating user:", ctx.input.name);
      return next();
    })
    .post((opts) => {
      return { id: "1" };
    }),
});
```

## Context Extension

Middleware can extend the context by passing updated context to `next()`. This follows the tRPC pattern:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  console.log(`Request took ${duration}ms`);
  return result;
};

const authMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const user = await authenticate(ctx.hono.req);
  if (!user) {
    return ctx.hono.json({ error: "Unauthorized" }, 401);
  }
  // Extend context - user is now non-null in subsequent handlers
  return next({ ctx: { user } });
};

const protectedProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware);

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null
      const { ctx } = opts;
      return { id: ctx.user!.id, name: ctx.user!.name };
    }),
});
```

## Multiple Middleware

Chain multiple middleware on the same procedure:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: any) => {
  console.log("Request started");
  return opts.next();
};

const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

const adminMiddleware = async (opts: any) => {
  if (opts.ctx.user?.role !== "admin") {
    return new Response("Forbidden", { status: 403 });
  }
  return opts.next();
};

const adminProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware)
  .use(adminMiddleware);

export const adminRouter = router({
  settings: adminProcedure.get(() => {
    return { admin: true };
  }),
});
```

Middleware executes in the order they're defined.

## Reusable Procedures

Create reusable procedures with middleware to reuse authentication or other middleware across multiple routes. See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for details:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  // Auth middleware
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

// Use procedures
export const appRouter = router({
  hello: publicProc.get(() => "hello"),
  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      return opts.ctx.user!;
    }),
});
```

## Middleware Chaining and Context Flow

Middleware can chain together, with each middleware able to extend the context:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
  requestId: string;
  isAdmin: boolean;
}

const factory = init<AppContext>();

// First middleware adds requestId
const requestIdMiddleware = async (opts: any) => {
  const requestId = crypto.randomUUID();
  return opts.next({ ctx: { requestId } });
};

// Second middleware adds user
const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

// Third middleware adds isAdmin based on user role
const adminCheckMiddleware = async (opts: any) => {
  const isAdmin = opts.ctx.user?.role === "admin";
  return opts.next({ ctx: { isAdmin } });
};

const adminProcedure = factory.procedure
  .use(requestIdMiddleware)
  .use(authMiddleware)
  .use(adminCheckMiddleware);

export const adminRouter = router({
  dashboard: adminProcedure
    .input({})
    .get((opts) => {
      // All context extensions are available
      const { ctx } = opts;
      return {
        requestId: ctx.requestId,
        userId: ctx.user!.id,
        isAdmin: ctx.isAdmin,
      };
    }),
});
```

---

// File: core-concepts/output-validation

# Output Validation

Optionally validate response data to ensure handlers return the expected structure.

## Basic Usage

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // Return value is validated against output schema
    return {
      id: ctx.input.id,
      name: "Alice",
    };
  });
```

## Benefits

- **Runtime safety**: Catch bugs during development when handlers return incorrect data
- **Type safety**: TypeScript ensures your return value matches the schema
- **Documentation**: Output schemas serve as API documentation

## Optional Output Validation

Output validation is optional. If you omit the `output` field, no validation is performed, but you lose type safety for the return value:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    // No output validation
  })
  .handler((ctx) => {
    return { id: ctx.input.id };
  });
```

---

// File: core-concepts/result-type

# Result Type

Handlers return a `Result<A, E>` type for explicit error handling, powered by `@alt-stack/result`.

For comprehensive documentation on the Result type, see the [Result documentation](/result).

## Overview

The Result type makes errors explicit in your type signatures. Instead of throwing exceptions, handlers return `Result` types that are either `Ok` (success) or `Err` (failure).

```typescript
import { ok, err } from "@alt-stack/server-hono";
// Or import directly: import { ok, err } from "@alt-stack/result";

// Success: wrap value in ok()
return ok({ id: "123", name: "John" });

// Error: wrap error in err() with _httpCode for status
return err({ _httpCode: 404, data: { error: { code: "NOT_FOUND", message: "User not found" } } });
```

## Basic Usage

### Returning Success

Use `ok()` to return successful values:

```typescript
const handler = procedure
  .output(z.object({ id: z.string(), name: z.string() }))
  .get(({ input }) => {
    const user = { id: "123", name: "John" };
    return ok(user);
  });
```

### Returning Errors

Use `err()` to return typed errors. Include `_httpCode` to set the HTTP status code:

```typescript
const handler = procedure
  .output(UserSchema)
  .errors({
    404: z.object({
      error: z.object({
        code: z.literal("NOT_FOUND"),
        message: z.string(),
      }),
    }),
  })
  .get(({ input }) => {
    const user = findUser(input.params.id);

    if (!user) {
      return err({
        _httpCode: 404 as const,
        data: {
          error: {
            code: "NOT_FOUND" as const,
            message: `User ${input.params.id} not found`,
          },
        },
      });
    }

    return ok(user);
  });
```

## Error Structure

Server errors have two fields:
- `_httpCode`: HTTP status code (e.g., 404, 500)
- `data`: The error payload matching your error schema

```typescript
return err({
  _httpCode: 400 as const,
  data: {
    error: {
      code: "VALIDATION_ERROR" as const,
      message: "Invalid input",
    },
  },
});
```

## Type Inference

Error types are inferred from your `.errors()` definitions. TypeScript ensures you can only return errors that match defined schemas:

```typescript
procedure
  .errors({
    404: z.object({ error: z.object({ code: z.literal("NOT_FOUND"), message: z.string() }) }),
    409: z.object({ error: z.object({ code: z.literal("CONFLICT"), message: z.string() }) }),
  })
  .get(({ input }) => {
    // TypeScript knows errors must match 404 or 409 schemas
    if (!exists) {
      return err({ _httpCode: 404 as const, data: { error: { code: "NOT_FOUND" as const, message: "Not found" } } });
    }
    if (conflict) {
      return err({ _httpCode: 409 as const, data: { error: { code: "CONFLICT" as const, message: "Already exists" } } });
    }
    return ok(result);
  });
```

## Result Utilities

The server packages re-export Result utilities from `@alt-stack/result`:

### Type Guards

```typescript
import { isOk, isErr } from "@alt-stack/server-hono";

const result = await handler();
if (isOk(result)) {
  console.log(result.value);
}
if (isErr(result)) {
  console.log(result.error);
}
```

### Pattern Matching

```typescript
import { match } from "@alt-stack/server-hono";

const message = match(result, {
  ok: (value) => `Success: ${value.name}`,
  err: (error) => `Error: ${error.data.error.message}`,
});
```

### Transformations

```typescript
import { map, flatMap, mapError } from "@alt-stack/server-hono";

// Transform success value
const mapped = map(result, (user) => user.name);

// Chain operations
const chained = flatMap(result, (user) => {
  if (!user.active) return err({ _httpCode: 403 as const, data: { message: "Inactive" } });
  return ok(user.profile);
});

// Transform error
const withNewError = mapError(result, (e) => ({ ...e, logged: true }));
```

### Extraction

```typescript
import { unwrap, unwrapOr } from "@alt-stack/server-hono";

// Get value or throw (use sparingly)
const value = unwrap(result);

// Get value or default
const valueOrDefault = unwrapOr(result, defaultUser);
```

### Try-Catch Wrappers

```typescript
import { tryCatch, tryCatchAsync } from "@alt-stack/server-hono";

// Wrap sync function
const result = tryCatch(
  () => JSON.parse(input),
  (e) => ({ _httpCode: 400 as const, data: { message: "Invalid JSON" } })
);

// Wrap async function
const asyncResult = await tryCatchAsync(
  () => fetchUser(id),
  (e) => ({ _httpCode: 500 as const, data: { error: { code: "FETCH_ERROR", message: String(e) } } })
);
```

## Middleware

Middleware can return `err()` just like handlers. Define errors with `.errors()` before `.use()`:

```typescript
const protectedProcedure = procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.user) {
      return err({
        _httpCode: 401 as const,
        data: {
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        },
      });
    }
    return next({ ctx: { user: ctx.user } });
  });
```

## See Also

- [Result Documentation](/result) - Complete guide to the Result type
- [Error Handling](./error-handling) - Defining error schemas

---

// File: core-concepts/reusable-procedures

# Reusable Procedures

Create reusable procedures with middleware to follow the tRPC pattern. This allows you to define common authentication, validation, or other middleware once and reuse it across multiple routes.

## Basic Pattern

Use `publicProcedure` or `init()` to create procedures:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    // `ctx.user` is nullable
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    // ✅ Pass updated context where user is non-null
    return next({
      ctx: {
        user: ctx.user, // ✅ user value is known to be non-null now
      },
    });
  });

// Create a router using the new tRPC-style API
export const appRouter = router({
  hello: publicProc.get(() => {
    return "hello world";
  }),

  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null after middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        name: ctx.user!.name,
      };
    }),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => {
      return { secret: "sauce" };
    }),
});
```

## Configuring Procedures

Procedures support the same configuration methods as regular routes:

### Setting Default Input

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const validatedProcedure = publicProcedure.input({
  query: z.object({
    apiKey: z.string().min(1),
  }),
});

// All routes using this procedure will require apiKey in query
export const dataRouter = router({
  list: validatedProcedure
    .input({
      body: z.object({ filter: z.string() }), // Additional input
    })
    .get((opts) => {
      // opts.input.apiKey is available (from procedure)
      // opts.input.filter is available (from route)
      const { input } = opts;
      return [];
    }),
});
```

### Setting Default Output

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const jsonProcedure = publicProcedure.output(
  z.object({
    success: z.boolean(),
  })
);

export const actionRouter = router({
  create: jsonProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post((opts) => {
      // output is automatically set from procedure
      return { success: true };
    }),
});
```

### Setting Default Errors

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const errorProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const protectedRouter = router({
  data: errorProcedure
    .input({})
    .output(z.string())
    .get((opts) => {
      const { ctx } = opts;
      if (someCondition) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Not authorized",
          },
        });
      }
      return "success";
    }),
});
```

### Combining Procedure and Route Errors

Errors defined on procedures are automatically merged with errors defined on routes. Route errors take precedence when the same status code is defined in both:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

// Procedure defines common authentication error
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const userRouter = router({
  "{id}": apiProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(z.object({ id: z.string(), name: z.string() }))
    .errors({
      // 401 is inherited from procedure
      // Add additional route-specific errors
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
      403: z.object({
        error: z.object({
          code: z.literal("FORBIDDEN"),
          message: z.string(),
        }),
      }),
    })
    .get((opts) => {
      const { input, ctx } = opts;
      const user = findUser(input.id);

      if (!user) {
        // Can throw 404 error (defined on route)
        throw ctx.error({
          error: {
            code: "NOT_FOUND",
            message: "User not found",
          },
        });
      }

      if (!canAccessUser(user)) {
        // Can throw 403 error (defined on route)
        throw ctx.error({
          error: {
            code: "FORBIDDEN",
            message: "Access denied",
          },
        });
      }

      if (!isAuthenticated()) {
        // Can throw 401 error (inherited from procedure)
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Authentication required",
          },
        });
      }

      return user;
    }),
});
```

In this example, the route has access to all three error types:
- `401 UNAUTHORIZED` from the procedure
- `404 NOT_FOUND` from the route
- `403 FORBIDDEN` from the route

**Union of Error Schemas**: If both the procedure and route define an error with the same status code, the schemas are unioned. This means `ctx.error()` can accept either schema for that status code:

```typescript
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const settingsRouter = router({
  me: apiProcedure
    .input({})
    .errors({
      // Route defines a different 401 error schema - they will be unioned
      401: z.object({
        error: z.object({
          code: z.literal("SESSION_EXPIRED"),
          message: z.string(),
          redirect: z.string().url(),
        }),
      }),
    })
    .get((opts) => {
      const { ctx } = opts;
      // Can throw 401 with either UNAUTHORIZED or SESSION_EXPIRED
      throw ctx.error({
        error: {
          code: "SESSION_EXPIRED",
          message: "Your session has expired",
          redirect: "https://example.com/login",
        },
      });
    }),
});
```

## Middleware Chaining

Middleware can be chained to build up context:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const authProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  const user = await getUser(ctx);
  if (!user) {
    throw ctx.error({ code: "UNAUTHORIZED" });
  }
  return next({ ctx: { user } });
});

const adminProcedure = authProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (ctx.user.role !== "admin") {
    throw ctx.error({ code: "FORBIDDEN" });
  }
  return next({ ctx: { isAdmin: true } });
});

export const adminRouter = router({
  settings: adminProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user and opts.ctx.isAdmin are both available
      const { ctx } = opts;
      return { admin: ctx.isAdmin };
    }),
});
```

## Common Patterns

### Public and Protected Routes

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(authMiddleware);

export const appRouter = router({
  hello: publicProc.get(() => "hello"),

  profile: protectedProcedure
    .input({})
    .get((opts) => {
      return opts.ctx.user!; // Non-null due to middleware
    }),
});
```

### Role-Based Procedures

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { role: string } | null;
}

const factory = init<AppContext>();

const requireRole = (role: string) =>
  factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next();
  });

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  delete: adminProcedure.get(() => ({ success: true })),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure.post(() => ({ success: true })),
});
```

### Rate Limited Procedures

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const rateLimitedProcedure = publicProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  const rateLimitKey = getRateLimitKey(ctx);
  if (await isRateLimited(rateLimitKey)) {
    return new Response("Too many requests", { status: 429 });
  }
  await incrementRateLimit(rateLimitKey);
  return next();
});

export const apiRouter = router({
  data: rateLimitedProcedure.get(() => {
    return { data: [] };
  }),
});
```

---

// File: getting-started/basic-routes

# Basic Routes

Define routes using the tRPC-style API with support for all HTTP methods.

## Route Methods

The router supports all standard HTTP methods:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure.get(() => {
    return [];
  }),
  
  create: publicProcedure.post(() => {
    return { id: "1" };
  }),
  
  update: publicProcedure.put(() => {
    return { id: "1" };
  }),
  
  patch: publicProcedure.patch(() => {
    return { id: "1" };
  }),
  
  remove: publicProcedure.delete(() => {
    return { success: true };
  }),
});
```

## Path Parameters

Extract parameters from the URL path. Path parameters in the route key (e.g., `{id}`) are automatically validated:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      // opts.input.id is typed as string
      const { input } = opts;
      return {
        id: input.id,
        name: "Alice",
      };
    }),
});
```

**Type Safety**: TypeScript will automatically detect an error if you use a path parameter like `{id}` but don't provide the corresponding `params.id` in your input schema. For example, this would cause a TypeScript error:

```typescript
// ❌ TypeScript error: Missing required path parameter 'id' in params
export const userRouter = router({
  "{id}": publicProcedure.get((opts) => {
    return { id: "1" };
  }),
});
```

You must include `params: z.object({ id: z.string() })` (or the appropriate type) when using `{id}` in your route path.

## Query Parameters

Extract query string parameters:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure
    .input({
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
        search: z.string().optional(),
      }),
    })
    .get((opts) => {
      // opts.input.query.limit, opts.input.query.offset, opts.input.query.search are typed
      const { input } = opts;
      return [];
    }),
});
```

:::tip Use z.coerce for numeric query parameters
Query strings are always strings in HTTP. Use `z.coerce.number()` to automatically convert string values like `"10"` to numbers. See [Input Validation](/core-concepts/input-validation#string-input-constraints) for more details.
:::

## Request Body

Handle POST/PUT/PATCH requests with typed request bodies:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .post((opts) => {
      // opts.input.name and opts.input.email are typed
      const { input } = opts;
      return {
        id: "1",
        name: input.name,
      };
    }),
});
```

## Combining Input Sources

You can combine params, query, and body:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        notify: z.coerce.boolean().optional(),
      }),
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      // All inputs are available and typed
      const { input } = opts;
      // input.params.id (from params)
      // input.query.notify (from query)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

## Output Validation

You can specify output schemas for validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
});

export const userRouter = router({
  get: publicProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(UserSchema)
    .get((opts) => {
      return {
        id: opts.input.id,
        name: "Alice",
        email: "alice@example.com",
      };
    }),
});
```

---

// File: getting-started/installation

# Installation

Choose an adapter based on your preferred HTTP framework.

## Result Package (Optional)

For standalone use of the Result type without server/client packages:

```bash
pnpm add @alt-stack/result
# or
npm install @alt-stack/result
# or
yarn add @alt-stack/result
```

The Result type is automatically included with the server and client packages, so you don't need to install it separately when using those. See the [Result documentation](/result) for usage details.

## Hono Adapter (Recommended)

Best for new projects, edge deployments, and serverless environments.

```bash
pnpm add @alt-stack/server-hono hono zod
# or
npm install @alt-stack/server-hono hono zod
# or
yarn add @alt-stack/server-hono hono zod
```

### Peer Dependencies

- **hono**: `^4.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Express Adapter

Best for existing Express applications or teams familiar with Express.

```bash
pnpm add @alt-stack/server-express express zod
# or
npm install @alt-stack/server-express express zod
# or
yarn add @alt-stack/server-express express zod
```

For TypeScript users:
```bash
pnpm add -D @types/express
```

### Peer Dependencies

- **express**: `^4.0.0 || ^5.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Which Adapter Should I Choose?

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards API) | Mature, well-tested |
| Bundle size | Smaller | Larger ecosystem |
| Edge/Serverless | Native support (Cloudflare, Vercel) | Requires adapters |
| Middleware ecosystem | Growing | Extensive |
| Learning curve | Familiar if you know fetch | Familiar if you know Express |

**Recommendation**: Use `@alt-stack/server-hono` for new projects. Use `@alt-stack/server-express` if you're adding to an existing Express app or need specific Express middleware.

## Migration from @alt-stack/server

If you're using the deprecated `@alt-stack/server` package:

```bash
# Remove old package
pnpm remove @alt-stack/server

# Install new package
pnpm add @alt-stack/server-hono hono zod
```

Then update your imports:

```typescript
// Before
import { createServer, router } from "@alt-stack/server";

// After
import { createServer, router } from "@alt-stack/server-hono";
```

The API remains the same - only the import path changes.

---

// File: getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates the core concepts.

## Basic Example

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.id is typed as string (from params)
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  })
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.name and ctx.input.email are typed (from body)
    return {
      id: "1",
      name: ctx.input.name,
    };
  });

const app = createServer({
  api: router,
});

// Use with your favorite Hono adapter
export default app;
```

This example shows:
- Type-safe route definitions with Zod schemas
- Automatic input validation from params, query, and body
- Type inference in handlers
- Combining routes into a server

---

// File: guides/asyncapi-to-typescript

# AsyncAPI to TypeScript

Generate TypeScript types and Zod schemas from AsyncAPI specifications using the `zod-asyncapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-asyncapi
# or
npm install @alt-stack/zod-asyncapi
```

## CLI Usage

```bash
npx zod-asyncapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-asyncapi asyncapi.json

# Generate from URL (e.g., from your running Kafka producer)
npx zod-asyncapi http://localhost:3000/asyncapi.json

# Specify output file
npx zod-asyncapi asyncapi.json -o src/kafka-types.ts
```

## Generated Output

Given an AsyncAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Message schemas** for each topic
- **Topics lookup object** for easy schema access

### Example

For an AsyncAPI spec with a `User` schema and `user-events` topic:

```typescript
/**
 * This file was automatically generated from AsyncAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

// Component Schemas
export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

// Topic Message Schemas
export const UserEventsMessageSchema = UserSchema;
export type UserEventsMessage = z.infer<typeof UserEventsMessageSchema>;

// Topics Object
export const Topics = {
  'user-events': UserEventsMessageSchema
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Using Generated Types with Kafka Client

The generated `Topics` object works directly with `@alt-stack/kafka-client-kafkajs` or `@alt-stack/kafka-client-warpstream`:

### KafkaJS Producer

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending - topic names and message shapes are validated
await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});

await client.disconnect();
```

### WarpStream Producer

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToAsyncApiSchema } from "@alt-stack/zod-asyncapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToAsyncApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-asyncapi asyncapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/kafka-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Workflow: Server to Client

A typical workflow:

1. **Server defines Kafka topics** with Zod schemas using `@alt-stack/kafka-core`
2. **Server exposes AsyncAPI spec** at an endpoint
3. **Client generates types** using `zod-asyncapi`
4. **Client uses Kafka client** with generated types

```bash
# Generate types from running server
npx zod-asyncapi http://localhost:3000/asyncapi.json -o src/kafka-types.ts
```

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { asyncApiToZodTsCode } from "@alt-stack/zod-asyncapi";

const asyncApiSpec = {
  asyncapi: "3.0.0",
  info: { title: "My API", version: "1.0.0" },
  channels: {
    userEvents: {
      address: "user-events",
      messages: {
        UserCreated: { $ref: "#/components/messages/UserCreated" },
      },
    },
  },
  components: {
    messages: {
      UserCreated: {
        payload: { $ref: "#/components/schemas/User" },
      },
    },
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
};

const generatedCode = asyncApiToZodTsCode(
  asyncApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
);

console.log(generatedCode);
```

---

// File: guides/better-auth-integration

# Better Auth Integration

Integrate Better Auth for authentication with your server framework. Better Auth handles session management, authentication flows, and user management.

## Setup

First, install Better Auth:

```bash
pnpm add better-auth
# or
npm install better-auth
# or
yarn add better-auth
```

Create your Better Auth configuration:

```typescript
// src/auth.ts
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { z } from "zod";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg", // or your database provider
  }),
  emailAndPassword: {
    enabled: true,
  },
  // Add other auth providers as needed
});
```

## Validating User Session with Zod

Better Auth returns session data that should be validated. Use Zod to ensure type safety and validate the user structure:

```typescript
import { z } from "zod";
import { auth } from "./auth.js";

// Define your user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  // Add other user fields as needed
});

// Schema for Better Auth session
const SessionSchema = z.object({
  user: UserSchema,
  session: z.object({
    id: z.string(),
    userId: z.string(),
    expiresAt: z.date(),
  }),
});

// Infer TypeScript types from Zod schemas
export type User = z.infer<typeof UserSchema>;
export type Session = z.infer<typeof SessionSchema>;

export async function getAuthSession(request: Request): Promise<Session | null> {
  const session = await auth.api.getSession({ headers: request.headers });
  
  // Validate and parse the session with safeParse for optional validation
  const result = SessionSchema.safeParse(session);
  
  if (!result.success) {
    // Log validation errors in development
    if (process.env.NODE_ENV === "development") {
      console.warn("Session validation failed:", result.error);
    }
    return null;
  }
  
  return result.data;
}

// Or if you only need the user:
export async function getAuthUser(request: Request): Promise<User | null> {
  const session = await getAuthSession(request);
  return session?.user ?? null;
}
```

## Mounting Better Auth Routes

Mount Better Auth routes alongside your server framework routes. Better Auth handles all `/api/auth/*` routes:

```typescript
import { Hono } from "hono";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create base Hono app
const app = new Hono();

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount your server framework routes
const serverApp = createServer({
  todos: todosRouter,
});

app.route("/", serverApp);

export default app;
```

## Adding User to Context

Add the authenticated user to your custom context so it's available in all handlers. Use Zod validation to ensure type safety:

```typescript
import { createServer } from "@alt-stack/server-hono";
import { getAuthUser, type User } from "./auth.js";
import type { Context } from "hono";
import { z } from "zod";

interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return {
    user,
  };
}

const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      email: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    // ctx.user is fully typed based on UserSchema
    return {
      id: ctx.user.id,
      email: ctx.user.email,
      name: ctx.user.name,
    };
  });

const app = createServer({
  users: router,
}, {
  createContext,
});
```

---

// File: guides/ci-cd-sdk-generation

# CI/CD SDK Generation

Automatically generate and publish TypeScript SDKs from your API schemas using GitHub Actions.

## Overview

Alt Stack provides example GitHub Action workflows for automating SDK generation:

| Workflow | Use Case |
|----------|----------|
| `generate-openapi-sdk.yml` | Generate types from OpenAPI and commit to repo |
| `generate-asyncapi-sdk.yml` | Generate types from AsyncAPI and commit to repo |
| `publish-openapi-schema.yml` | Publish OpenAPI SDK as npm package |
| `publish-asyncapi-schema.yml` | Publish AsyncAPI SDK as npm package |

## Setup for a TypeScript Project

### Prerequisites

Your project should have:
- A `package.json` with a `generate-spec` script
- Node.js 20+ and pnpm (or npm/yarn)

### Project Structure

```
my-api/
├── .github/
│   └── workflows/
│       └── generate-sdk.yml    # Your workflow file
├── src/
│   ├── index.ts                # Your API server
│   ├── router.ts               # Your router definition
│   └── generate-spec.ts        # Script to generate spec
├── openapi.json                # Generated spec (committed)
├── generated-types.ts          # Generated SDK (auto-committed)
├── package.json
└── tsconfig.json
```

## Generate OpenAPI SDK (In-Repo)

This workflow generates TypeScript types from your OpenAPI spec and commits them to your repository.

### Step 1: Create the Workflow

Create `.github/workflows/generate-sdk.yml`:

```yaml
name: Generate SDK

on:
  push:
    branches: [main]
    paths: ['src/**', 'openapi.json']
  pull_request:
    paths: ['src/**', 'openapi.json']

env:
  OPENAPI_FILE: 'openapi.json'
  OUTPUT_PATH: 'generated-types.ts'

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile

      - run: pnpm add -D @alt-stack/zod-openapi

      - name: Generate spec
        run: npm run generate-spec --if-present || true

      - name: Generate SDK
        run: npx zod-openapi ${{ env.OPENAPI_FILE }} -o ${{ env.OUTPUT_PATH }}

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet ${{ env.OUTPUT_PATH }}; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.OUTPUT_PATH }}
          git commit -m "chore: regenerate types [skip ci]"
          git push

      - name: Fail if outdated (PR)
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated types are outdated. Run locally:"
          echo "npm run generate-spec && npx zod-openapi ${{ env.OPENAPI_FILE }} -o ${{ env.OUTPUT_PATH }}"
          exit 1
```

### Step 2: Define Your Router

```typescript title="src/router.ts"
import { init, router } from '@alt-stack/server-hono';
import { z } from 'zod';

const { publicProcedure } = init();

export const appRouter = router({
  getUser: publicProcedure
    .input({ params: z.object({ id: z.string() }) })
    .output(z.object({ id: z.string(), name: z.string() }))
    .get('/users/:id', async ({ input }) => {
      return { id: input.params.id, name: 'John' };
    }),
});
```

### Step 3: Create Generate Script

```typescript title="src/generate-spec.ts"
import { writeFileSync } from 'fs';
import { generateOpenAPISpec } from '@alt-stack/server-hono';
import { appRouter } from './router';

const spec = generateOpenAPISpec(appRouter, {
  title: 'My API',
  version: '1.0.0',
});

writeFileSync('openapi.json', JSON.stringify(spec, null, 2));
console.log('Generated openapi.json');
```

### Step 4: Add Scripts

```json title="package.json"
{
  "scripts": {
    "generate-spec": "tsx src/generate-spec.ts",
    "generate-types": "npm run generate-spec && npx zod-openapi openapi.json -o generated-types.ts"
  }
}
```

## Generate AsyncAPI SDK (In-Repo)

For Kafka/event-driven APIs using AsyncAPI.

### Step 1: Create the Workflow

```yaml title=".github/workflows/generate-sdk.yml"
name: Generate SDK

on:
  push:
    branches: [main]
    paths: ['src/**', 'asyncapi.json']
  pull_request:
    paths: ['src/**', 'asyncapi.json']

env:
  ASYNCAPI_FILE: 'asyncapi.json'
  OUTPUT_PATH: 'generated-types.ts'

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile

      - run: pnpm add -D @alt-stack/zod-asyncapi

      - name: Generate spec
        run: npm run generate-spec --if-present || true

      - name: Generate SDK
        run: npx zod-asyncapi ${{ env.ASYNCAPI_FILE }} -o ${{ env.OUTPUT_PATH }}

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet ${{ env.OUTPUT_PATH }}; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.OUTPUT_PATH }}
          git commit -m "chore: regenerate types [skip ci]"
          git push

      - name: Fail if outdated (PR)
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated types are outdated. Run locally:"
          echo "npm run generate-spec && npx zod-asyncapi ${{ env.ASYNCAPI_FILE }} -o ${{ env.OUTPUT_PATH }}"
          exit 1
```

### Step 2: Create Your Kafka Router

```typescript title="src/router.ts"
import { init, kafkaRouter } from '@alt-stack/kafka-core';
import { z } from 'zod';

const { procedure } = init();

export const myRouter = kafkaRouter({
  userCreated: procedure
    .topic('user.created')
    .payload(z.object({
      userId: z.string(),
      email: z.string().email(),
      createdAt: z.string().datetime(),
    }))
    .handler(async ({ payload }) => {
      console.log('User created:', payload.userId);
    }),
});
```

### Step 3: Add Generate Script

```typescript title="src/generate-spec.ts"
import { writeFileSync } from 'fs';
import { generateAsyncAPISpec } from '@alt-stack/kafka-core';
import { myRouter } from './router';

const spec = generateAsyncAPISpec(myRouter, {
  title: 'My Kafka API',
  version: '1.0.0',
});

writeFileSync('asyncapi.json', JSON.stringify(spec, null, 2));
console.log('Generated asyncapi.json');
```

```json title="package.json"
{
  "scripts": {
    "generate-spec": "tsx src/generate-spec.ts",
    "generate-types": "npm run generate-spec && npx zod-asyncapi asyncapi.json -o generated-types.ts"
  }
}
```

## Publish SDK to npm

For publishing your SDK as a standalone npm package that consumers can install.

### Publish OpenAPI SDK

```yaml title=".github/workflows/publish-sdk.yml"
name: Publish SDK

on:
  push:
    branches: [main]
    paths: ['src/**']

env:
  OPENAPI_FILE: 'openapi.json'
  NPM_PACKAGE_NAME: '@my-org/my-api-sdk'

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org/'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile
      
      - run: pnpm add -D @alt-stack/zod-openapi

      - name: Generate spec
        run: npm run generate-spec

      - name: Generate SDK
        run: |
          mkdir -p sdk-package/src
          npx zod-openapi ${{ env.OPENAPI_FILE }} -o sdk-package/src/index.ts

      - name: Create package.json
        run: |
          VERSION=$(node -p "require('./package.json').version")
          cat > sdk-package/package.json << EOF
          {
            "name": "${{ env.NPM_PACKAGE_NAME }}",
            "version": "$VERSION",
            "type": "module",
            "main": "./dist/index.js",
            "types": "./dist/index.d.ts",
            "exports": {
              ".": {
                "types": "./dist/index.d.ts",
                "import": "./dist/index.js"
              }
            },
            "scripts": {
              "build": "tsup src/index.ts --format esm --dts"
            },
            "peerDependencies": {
              "zod": "^4.0.0"
            },
            "devDependencies": {
              "tsup": "^8.0.0",
              "typescript": "^5.0.0"
            }
          }
          EOF

      - name: Build and publish
        working-directory: sdk-package
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          pnpm install
          pnpm build
          npm publish --access public
```

### Required Secrets

Add `NPM_TOKEN` to your repository secrets:

1. Go to **Settings** → **Secrets and variables** → **Actions**
2. Click **New repository secret**
3. Name: `NPM_TOKEN`
4. Value: Your npm access token (from npmjs.com → Access Tokens)

## Using the Generated SDK

### In-Repo Types

```typescript
import { schemas, Request, Response } from './generated-types';

// Validate data
const user = schemas.User.parse(data);

// Type-safe request/response
type GetUserRequest = Request['GET /users/:id'];
type GetUserResponse = Response['GET /users/:id']['200'];
```

### Published SDK

```bash
pnpm add @my-org/my-api-sdk
```

```typescript
import { schemas, Request, Response } from '@my-org/my-api-sdk';

// Same usage as above
const user = schemas.User.parse(apiResponse);
```

## Local Development

Run the generation locally to test before pushing:

```bash
# Generate spec and types in one command
npm run generate-types

# Or step by step
npm run generate-spec
npx zod-openapi openapi.json -o generated-types.ts
```

## Best Practices

### Commit Both Spec and Types

Commit both your spec file (`openapi.json`/`asyncapi.json`) and generated types. This provides:
- Full history of API changes
- Easy diffing in PRs
- No runtime generation needed

### Version Synchronization

Keep your SDK version in sync with your API:

```yaml
- name: Read version
  id: version
  run: echo "version=$(node -p \"require('./package.json').version\")" >> $GITHUB_OUTPUT
```

### Conditional Publishing

Only publish when source files change:

```yaml
on:
  push:
    paths:
      - 'src/**'
      - '!src/**/*.test.ts'
```

### PR Validation

Fail PRs if generated types are outdated to catch schema changes:

```yaml
- name: Fail if outdated
  if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
  run: exit 1
```

## Troubleshooting

### Spec Not Generating

- Check your `generate-spec` script is defined in package.json
- Ensure the router is exported correctly
- Verify all dependencies are installed

### Types Not Generating

- Check the spec file exists and is valid JSON
- Ensure `@alt-stack/zod-openapi` or `@alt-stack/zod-asyncapi` is installed
- Check for syntax errors in the spec

### npm Publish Failing

- Verify `NPM_TOKEN` secret is set correctly
- Check the package name is available on npm
- Ensure version hasn't already been published

---

// File: guides/client-side-usage

# Client-Side Usage

When making requests from the client, include credentials to support authentication cookies.

## Using Hono Client

Use the Hono client (`hc`) for type-safe API calls:

```typescript
import { hc } from "hono/client";

const client = hc("http://localhost:3000", {
  init: {
    credentials: "include", // Required for auth cookies
  },
});

// Make authenticated requests
const response = await client.api.users.profile.$get();
```

## Fetch with Credentials

When using standard `fetch`, ensure credentials are included:

```typescript
const response = await fetch("http://localhost:3000/api/users/profile", {
  method: "GET",
  credentials: "include", // Required for auth cookies
  headers: {
    "Content-Type": "application/json",
  },
});

const data = await response.json();
```

## Type-Safe API Calls

The Hono client provides type inference from your router definitions. The client automatically knows:

- Available routes
- Request methods
- Input types (params, query, body)
- Output types
- Error types

```typescript
// TypeScript knows this route exists and what it expects
const response = await client.api.users["{id}"].$get({
  param: {
    id: "123",
  },
  query: {
    include: "profile",
  },
});

// response.data is typed based on your output schema
console.log(response.data.name); // ✅ TypeScript knows this exists
```

## Error Handling

Handle errors type-safely:

```typescript
try {
  const response = await client.api.users["{id}"].$get({
    param: { id: "123" },
  });
  
  if (!response.ok) {
    // Handle error response
    const error = await response.json();
    console.error(error);
  }
} catch (error) {
  // Handle network errors
  console.error("Request failed:", error);
}
```

---

// File: guides/cors-configuration

# CORS Configuration

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call.

## Recommended: Global CORS with Better Auth

For most applications, applying CORS globally with credentials support works best:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth, getAuthUser } from "./auth.js";
import { todosRouter } from "./routes/todos.js";
import type { Context } from "hono";

// Create base app
const app = new Hono();

// Apply CORS globally (must be before routes)
app.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true, // Required for Better Auth cookies
  exposeHeaders: ["Set-Cookie"],
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create server framework app with context
interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return { user };
}

const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Mount server framework routes
app.route("/", serverApp);

export default app;
```

## Using Middleware Option

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call:

```typescript
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server with CORS and Better Auth routes
const app = createServer(
  {
    todos: todosRouter,
  },
  {
    createContext,
    middleware: {
      // Apply CORS globally
      "*": {
        methods: ["OPTIONS", "GET", "POST", "PUT", "PATCH", "DELETE"],
        handler: cors({
          origin: process.env.CLIENT_URL || "http://localhost:3000",
          allowHeaders: ["Content-Type", "Authorization"],
          allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
          credentials: true, // Required for Better Auth cookies
          exposeHeaders: ["Set-Cookie"],
        }) as any, // Type assertion for CORS middleware
      },
      // Mount Better Auth routes
      "/api/auth/*": {
        methods: ["GET", "POST"],
        handler: async (c) => auth.handler(c.req.raw),
      },
    },
  },
);

export default app;
```

**Key Points:**
- The `"*"` path applies middleware globally to all routes (framework and mounted routes)
- For `"*"` paths, the handler can be a Hono middleware function (like `cors()`) or a regular handler
- Other paths mount specific route handlers (like Better Auth)
- Middleware is applied before framework routes, ensuring CORS headers are set correctly

## Manual Setup

If you need more control, you can still apply CORS manually after `createServer`:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

const app = new Hono();

// Apply CORS specifically to Better Auth routes
app.use("/api/auth/*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "OPTIONS"],
  credentials: true,
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create and mount server framework routes
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

app.route("/", serverApp);

export default app;
```

## CORS Only for Server Framework Routes

Apply CORS to server framework routes only:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server framework app
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Apply CORS to server framework routes
serverApp.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true,
}));

const app = new Hono();

// Mount Better Auth routes (no CORS needed if same origin)
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount server framework routes with CORS
app.route("/", serverApp);

export default app;
```

---

// File: guides/openapi-documentation

# OpenAPI Documentation

Automatically generate and serve OpenAPI 3.0 documentation for your API using Zod 4's native `toJSONSchema()` function.

## Quick Start

Use `createDocsRouter` to automatically generate and serve OpenAPI documentation:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const apiRouter = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "Alice",
    email: "alice@example.com",
  }))
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
  }));

// Create docs router
const docsRouter = createDocsRouter(
  { api: apiRouter },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Mount both routers
const app = createServer({
  api: apiRouter,
  docs: docsRouter,
});
```

Now you can access:
- OpenAPI JSON spec at `/docs/openapi.json` (path determined by mount prefix `docs`)
- Interactive Swagger UI at `/docs` (path determined by mount prefix `docs`)

## Basic Usage

The `createDocsRouter` function takes the same router configuration as `createServer`, allowing it to automatically discover all your routes and generate complete OpenAPI documentation.

```typescript
import { init, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const router = factory.router()
  .get("/items", {
    input: {},
    output: z.array(z.object({ id: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter({ api: router });
```

## Customization Options

Customize paths, metadata, and enable/disable features:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    // OpenAPI metadata
    title: "Todo API",
    version: "2.0.0",
    description: "A simple todo API",
    
    // Custom OpenAPI spec path
    openapiPath: "openapi.json", // Default: "openapi.json"
    // Note: The docs path is determined by the router prefix when mounting in createServer
    
    // Enable/disable interactive docs
    enableDocs: true, // Default: true
  }
);
```

## Integration with createServer

The docs router integrates seamlessly with `createServer`:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const todosRouter = factory.router()
  .get("/", {
    input: {},
    output: z.array(z.object({ id: z.string(), title: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter(
  { todos: todosRouter },
  {
    title: "Todo API",
    version: "1.0.0",
  }
);

const app = createServer({
  todos: todosRouter,
  docs: docsRouter,
});
```

With this setup:
- API routes are available at `/todos/*`
- Documentation is available at `/docs/*`

## Manual OpenAPI Spec Generation

If you need the OpenAPI spec object directly (e.g., for external tools or custom documentation), use `generateOpenAPISpec`:

```typescript
import { generateOpenAPISpec } from "@alt-stack/server-hono";

const spec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Use the spec with external tools
console.log(JSON.stringify(spec, null, 2));
```

## What Gets Documented

The OpenAPI documentation automatically includes:

- **All routes** from your routers
- **Path parameters** (e.g., `/{id}`)
- **Query parameters** from query schemas
- **Request bodies** for POST/PUT/PATCH operations
- **Response schemas** from output schemas
- **Error responses** from error schemas
- **Operation IDs** automatically generated from route paths

## Example: Complete API Documentation

Here's a complete example with multiple route types:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  // GET with path and query params
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.string().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "John",
    email: "john@example.com",
  }))
  
  // POST with body
  .post("/users", {
    input: {
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
    email: ctx.input.email,
  }))
  
  // PATCH with path params and body
  .patch("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      body: z.object({
        name: z.string().optional(),
        email: z.string().email().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: ctx.input.name || "John",
    email: ctx.input.email || "john@example.com",
  }))
  
  // DELETE
  .delete("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      success: z.boolean(),
    }),
  })
  .handler(() => ({ success: true }));

const docsRouter = createDocsRouter({ api: router });
const app = createServer({ api: router, docs: docsRouter });
```

All routes are automatically documented with proper OpenAPI 3.0 schemas.

## Disabling Interactive Docs

If you only need the JSON spec (e.g., for external tools), disable the HTML docs:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    enableDocs: false, // Only serve /openapi.json, not /docs
  }
);
```

## How It Works

The OpenAPI generation uses Zod 4's native `toJSONSchema()` function with the `openapi-3.0` target. This means:

- All Zod schemas are automatically converted to JSON Schema
- Complex types (objects, arrays, unions, etc.) are properly documented
- String formats (email, UUID, URL, etc.) are recognized
- Validation constraints are included in the schema

The generated OpenAPI spec is fully compliant with OpenAPI 3.0 specification and can be used with any OpenAPI-compatible tools.

---

// File: guides/openapi-to-typescript

# OpenAPI to TypeScript

Generate TypeScript types and Zod schemas from OpenAPI specifications using the `zod-openapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-openapi
# or
npm install @alt-stack/zod-openapi
```

## CLI Usage

```bash
npx zod-openapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-openapi openapi.json

# Generate from URL (e.g., from your running server)
npx zod-openapi http://localhost:3000/docs/openapi.json

# Specify output file
npx zod-openapi openapi.json -o src/api-types.ts
```

## Generated Output

Given an OpenAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Request schemas** for params, query, headers, and body
- **Response schemas** for all status codes
- **Lookup objects** (`Request` and `Response`) for easy access

### Example

For an OpenAPI spec with a `User` schema and `/users/{id}` endpoint:

```typescript
/**
 * This file was automatically generated from OpenAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

export const GetUsersIdParams = z.object({ id: z.string() });
export const GetUsersId200Response = UserSchema;

export const Request = {
  '/users/{id}': {
    GET: {
      params: GetUsersIdParams,
    },
  },
} as const;

export const Response = {
  '/users/{id}': {
    GET: {
      '200': GetUsersId200Response,
    },
  },
} as const;
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToOpenApiSchema } from "@alt-stack/zod-openapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToOpenApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-openapi openapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/api-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Integration with @alt-stack/server

A typical workflow with `@alt-stack/server-hono`:

1. **Define your API** with Zod schemas on the server
2. **Generate OpenAPI spec** using `createDocsRouter`
3. **Generate client types** using the `zod-openapi` CLI

```bash
# Fetch OpenAPI from your running server and generate types
npx zod-openapi http://localhost:3000/docs/openapi.json -o src/api-types.ts
```

This gives you fully typed request/response schemas that match your server's API exactly.

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";

const openApiSpec = {
  components: {
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
  paths: {
    "/users/{id}": {
      get: {
        parameters: [
          { name: "id", in: "path", required: true, schema: { type: "string" } },
        ],
        responses: {
          "200": {
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/User" },
              },
            },
          },
        },
      },
    },
  },
};

const generatedCode = openApiToZodTsCode(
  openApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
  { includeRoutes: true }
);

console.log(generatedCode);
```

---

// File: guides/protected-routes

# Protected Routes

Follow the tRPC authorization pattern for type-safe protected routes. The middleware can pass an updated context to `next()` to narrow types.

## Reusable Procedures Pattern (Recommended)

The recommended way to create protected routes is using reusable procedures:

```typescript
import { router, publicProcedure, init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    return next({
      ctx: {
        user: ctx.user,
      },
    });
  });

// Use procedures to create routes
export const appRouter = router({
  hello: publicProc.get(() => "hello world"),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => ({
      secret: "sauce",
    })),
});

const app = createServer({ api: appRouter });
```

See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for more details.

## Procedure-Level Middleware Pattern

The middleware can narrow the context type by passing an updated context to `next()`:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string; name: string } | null;
}

const factory = init<AppContext>();

export const protectedRouter = router({
  profile: factory.procedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
        name: z.string(),
      })
    )
    .errors({
      401: z.object({
        error: z.object({
          code: z.literal("UNAUTHORIZED"),
          message: z.string(),
        }),
      }),
    })
    .use(async function isAuthed(opts) {
      const { ctx, next } = opts;
      // `ctx.user` is nullable
      if (!ctx.user) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        });
      }
      // ✅ Pass updated context where user is non-null (tRPC pattern)
      // This allows the context to have user as non-null for subsequent handlers
      return next({
        ctx: {
          user: ctx.user, // ✅ user value is known to be non-null now
        },
      });
    })
    .get((opts) => {
      // ✅ opts.ctx.user is now guaranteed to be non-null after the middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
        name: ctx.user!.name,
      };
    }),
});
```

## Mixed Public and Protected Routes

You can mix public and protected routes in the same router:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

export const appRouter = router({
  public: publicProc.get(() => ({ message: "Public content" })),

  private: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
      })
    )
    .get((opts) => {
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
      };
    }),
});
```

## Role-Based Access Control

You can validate user roles, permissions, or other attributes:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string; permissions: string[] } | null;
}

const factory = init<AppContext>();

// Middleware that requires specific role
const requireRole = (role: "admin" | "user" | "moderator") => {
  return factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user) {
      return new Response("Unauthorized", { status: 401 });
    }
    if (ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next({ ctx: { user: ctx.user } });
  });
};

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  users: adminProcedure
    .input({})
    .output(z.array(z.object({ id: z.string(), name: z.string() })))
    .get(() => {
      return getAllUsers();
    }),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post(() => {
      return { success: true };
    }),
});
```

## Type-Safe User Context

For better type safety, use Zod's type inference to create authenticated context types:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

// Your validated user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  role: z.enum(["admin", "user", "moderator"]),
  permissions: z.array(z.string()),
});

type User = z.infer<typeof UserSchema>;

interface AppContext {
  user: User | null;
}

const factory = init<AppContext>();

const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Optionally re-validate to ensure type safety
  const validatedUser = UserSchema.parse(ctx.user);

  // Return context with validated user
  return next({ ctx: { user: validatedUser } });
});

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .output(UserSchema)
    .get((opts) => {
      // opts.ctx.user is validated and typed
      const { ctx } = opts;
      return ctx.user!;
    }),
});
```

---

// File: guides/telemetry

# OpenTelemetry Integration

Altstack servers support [OpenTelemetry](https://opentelemetry.io/) for distributed tracing with minimal configuration. When enabled, every request is automatically traced with semantic HTTP attributes.

## Installation

First, install the OpenTelemetry packages:

```bash
pnpm add @opentelemetry/api @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

## Quick Start

Enable telemetry by passing `telemetry: true` to `createServer`:

```typescript
import { createServer, router, init } from "@alt-stack/server-hono";

const { procedure } = init<AppContext>();

const appRouter = router({
  "/todos": procedure
    .output(z.array(TodoSchema))
    .get(async () => {
      return await db.todos.findMany();
    }),
});

const app = createServer({ api: appRouter }, {
  createContext,
  telemetry: true, // Enable OpenTelemetry
});
```

## Configuration Options

For more control, pass a configuration object:

```typescript
const app = createServer({ api: appRouter }, {
  createContext,
  telemetry: {
    enabled: true,
    serviceName: "my-api",           // Custom service name (default: "altstack-server")
    ignoreRoutes: ["/health", "/metrics"], // Routes to skip tracing
  },
});
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable/disable telemetry |
| `serviceName` | `string` | `"altstack-server"` | Service name for traces |
| `ignoreRoutes` | `string[]` | `[]` | Routes to exclude from tracing |

## Span Attributes

Each request span includes these attributes following [OpenTelemetry HTTP semantic conventions](https://opentelemetry.io/docs/specs/semconv/http/http-spans/):

| Attribute | Example | Description |
|-----------|---------|-------------|
| `http.request.method` | `GET` | HTTP method |
| `http.route` | `/api/todos/{id}` | Route pattern (with path params) |
| `url.path` | `/api/todos/123` | Actual URL path |
| `http.response.status_code` | `200` | Response status code |

## Custom Spans and Attributes

Access the current span via `ctx.span` to add custom attributes or events:

```typescript
const todoRouter = router({
  "/todos/{id}": procedure
    .input({ params: z.object({ id: z.string() }) })
    .get(async ({ input, ctx }) => {
      // Add custom attributes
      ctx.span?.setAttribute("todo.id", input.params.id);
      
      // Add events for significant operations
      ctx.span?.addEvent("db-query-start");
      const todo = await db.todos.findUnique({ 
        where: { id: input.params.id } 
      });
      ctx.span?.addEvent("db-query-end");
      
      return todo;
    }),
});
```

## Setting Up the OTel SDK

Before your server starts, initialize the OpenTelemetry SDK. Here's a typical setup:

```typescript
// tracing.ts - import this before your server starts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { Resource } from "@opentelemetry/resources";
import { ATTR_SERVICE_NAME } from "@opentelemetry/semantic-conventions";

const sdk = new NodeSDK({
  resource: new Resource({
    [ATTR_SERVICE_NAME]: "my-api",
  }),
  traceExporter: new OTLPTraceExporter({
    url: "http://localhost:4318/v1/traces", // OTLP HTTP endpoint
  }),
});

sdk.start();

// Graceful shutdown
process.on("SIGTERM", () => {
  sdk.shutdown().then(() => process.exit(0));
});
```

Then import this file at the top of your main entry point:

```typescript
// index.ts
import "./tracing.js"; // Must be first!
import { createServer } from "@alt-stack/server-hono";
// ... rest of your server code
```

## Example with Jaeger

To visualize traces locally with [Jaeger](https://www.jaegertracing.io/):

1. Run Jaeger with Docker:

```bash
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 4318:4318 \
  jaegertracing/all-in-one:latest
```

2. Configure the OTLP exporter to send to Jaeger:

```typescript
const sdk = new NodeSDK({
  traceExporter: new OTLPTraceExporter({
    url: "http://localhost:4318/v1/traces",
  }),
});
```

3. View traces at http://localhost:16686

## Works with Both Adapters

Telemetry works identically with both Hono and Express adapters:

```typescript
// Hono
import { createServer } from "@alt-stack/server-hono";
const app = createServer({ api: router }, { telemetry: true });

// Express
import { createServer } from "@alt-stack/server-express";
const app = createServer({ api: router }, { telemetry: true });
```

## Graceful Degradation

If `@opentelemetry/api` is not installed, telemetry is silently disabled. This allows you to:

- Use the same code in development (without OTel) and production (with OTel)
- Keep `@opentelemetry/api` as a dev dependency in some environments

The `ctx.span` will be `undefined` when telemetry is disabled or not installed, so always use optional chaining:

```typescript
ctx.span?.setAttribute("key", "value"); // Safe even without OTel
```

---

// File: intro

# Introduction

Altstack is a type-safe full-stack framework with separate server and client packages, built with Zod validation. Inspired by tRPC's builder pattern, providing full type inference from a central router definition.

## Architecture

Altstack is organized into foundational utilities and framework packages:

### Core Utilities

- **`@alt-stack/result`**: Type-safe Result type for explicit error handling. Provides `ok()`, `err()`, type guards, transformations, and pattern matching. Used throughout all Altstack packages. See [Result documentation](/result).

### Server Packages

- **`@alt-stack/server-core`**: Framework-agnostic core containing types, router, middleware, and validation logic. Used as a dependency by the adapter packages.

- **`@alt-stack/server-hono`**: [Hono](https://hono.dev/) adapter - creates a Hono app with full type inference. **Recommended for new projects.**

- **`@alt-stack/server-express`**: [Express](https://expressjs.com/) adapter - creates an Express app with the same type-safe API.

### Client Packages

- **`@alt-stack/http-client-fetch`**: Type-safe API client using native fetch
- **`@alt-stack/http-client-ky`**: Type-safe API client using ky library

## Choosing an Adapter

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards) | Mature ecosystem |
| Edge/Serverless | Native support | Requires adapters |
| Context access | `ctx.hono` | `ctx.express.req/res` |
| Best for | New projects, edge | Existing Express apps |

## Server Features

- **Type-safe routes**: Full TypeScript inference from Zod schemas
- **Builder pattern**: Fluent API for defining routes with `.get()`, `.post()`, etc.
- **Type-safe errors**: `ctx.error()` with automatic status code inference from error schemas
- **Reusable procedures**: Create reusable procedures with middleware (tRPC-style pattern)
- **Middleware support**: Procedure-level middleware with context extension
- **Router combination**: Merge multiple routers with `.merge()`
- **Validation**: Automatic Zod validation for inputs and optional outputs
- **OpenAPI generation**: Generate OpenAPI specs and interactive Swagger UI
- **Native framework access**: Full access to underlying framework APIs

## Client Features

- **Type-safe API calls**: Full TypeScript inference from server-generated types
- **Automatic validation**: Runtime validation using Zod schemas
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters
- **Error handling**: Typed error responses with detailed error information

## Quick Example

```typescript
import { init, createServer, router } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();

const appRouter = router({
  "/hello": factory.procedure
    .output(z.object({ message: z.string() }))
    .get(() => ({ message: "Hello, World!" })),
});

const app = createServer({ api: appRouter });
export default app;
```

---

// File: kafka/core-concepts/combining-routers

# Combining Routers

Organize consumers by domain using nested routers.

## Nested Routers

Use nested `kafkaRouter` for topic prefixing:

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";

const { procedure } = init<AppContext>();

const userRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: UserCreatedSchema }).subscribe(handleUserCreated),
  updated: procedure.input({ message: UserUpdatedSchema }).subscribe(handleUserUpdated),
});

const orderRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: OrderCreatedSchema }).subscribe(handleOrderCreated),
  cancelled: procedure.input({ message: OrderCancelledSchema }).subscribe(handleOrderCancelled),
});

// Topics become: users/created, users/updated, orders/created, orders/cancelled
const mainRouter = kafkaRouter<AppContext>({
  users: userRouter,
  orders: orderRouter,
});
```

## Merging Flat Routers

Use `mergeKafkaRouters` to combine routers without prefixing:

```typescript
import { mergeKafkaRouters } from "@alt-stack/kafka-core";

const router1 = kafkaRouter({
  "user-events": procedure.input({ message: UserSchema }).subscribe(() => {}),
});

const router2 = kafkaRouter({
  "order-events": procedure.input({ message: OrderSchema }).subscribe(() => {}),
});

// Topics remain: user-events, order-events (no prefix)
const mainRouter = mergeKafkaRouters(router1, router2);
```

## Using init() Factory

```typescript
const { router, mergeRouters, procedure } = init<AppContext>();

const r1 = router();
r1.registerProcedure("events", procedure.input({ message: Schema }).subscribe(() => {}));

const r2 = router();
r2.registerProcedure("other", procedure.input({ message: Schema }).subscribe(() => {}));

const merged = mergeRouters(r1, r2);
```

---

// File: kafka/core-concepts/consumers

# Consumers

Create Kafka consumers from routers.

## Basic Setup

```typescript
import { createConsumer, kafkaRouter, init } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: z.object({ userId: z.string() }) })
    .subscribe(({ input }) => {
      console.log(input.userId);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-app",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});

// Consumer is connected and running
```

## Kafka Config Options

Pass config directly instead of a Kafka instance:

```typescript
const consumer = await createConsumer(router, {
  kafka: {
    clientId: "my-app",
    brokers: ["localhost:9092"],
    ssl: true,
    sasl: {
      mechanism: "plain",
      username: "user",
      password: "pass",
    },
  },
  groupId: "my-consumer-group",
});
```

## Consumer Options

```typescript
const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-consumer-group",
  consumerConfig: {
    sessionTimeout: 30000,
    heartbeatInterval: 3000,
    maxBytesPerPartition: 1048576,
  },
  createContext: (baseCtx) => ({ logger: getLogger() }),
  onError: (error) => console.error("Consumer error:", error),
});
```

## Graceful Shutdown

```typescript
const consumer = await createConsumer(router, options);

process.on("SIGTERM", async () => {
  await consumer.disconnect();
  process.exit(0);
});
```

---

// File: kafka/core-concepts/custom-context

# Custom Context

Extend the base context with application-specific properties.

## Base Context

Every handler receives:

```typescript
interface BaseKafkaContext {
  message: KafkaMessage; // Full kafkajs message (value, key, headers, timestamp)
  topic: string;
  partition: number;
  offset: string;
}
```

## Defining Custom Context

```typescript
import { init, kafkaRouter, createConsumer, type BaseKafkaContext } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
  db: Database;
}

// Initialize with context type
const { procedure } = init<AppContext>();

const router = kafkaRouter<AppContext>({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx has logger, db, plus base context
      ctx.logger.log(`Processing user ${input.userId}`);
      ctx.db.save(input);
    }),
});
```

## Creating Context

Provide `createContext` to the consumer:

```typescript
function createContext(baseCtx: BaseKafkaContext): AppContext {
  return {
    logger: {
      log: (msg: string) =>
        console.log(`[${baseCtx.topic}:${baseCtx.partition}] ${msg}`),
    },
    db: getDatabase(),
  };
}

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  createContext,
});
```

## Async Context

```typescript
async function createContext(baseCtx: BaseKafkaContext): Promise<AppContext> {
  const db = await getConnectionFromPool();
  return { logger: getLogger(), db };
}
```

## Middleware Context Extension

Middleware can add to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await authenticate(ctx.message.headers);
  return next({ ctx: { user } });
});

const router = kafkaRouter<AppContext>({
  protected: authMiddleware
    .input({ message: Schema })
    .subscribe(({ ctx }) => {
      // ctx.user is available
    }),
});
```

---

// File: kafka/core-concepts/error-handling

# Error Handling

Define typed error schemas using the Result pattern.

For comprehensive documentation on the Result type, see the [Result documentation](/result).

## Error Schemas

```typescript
import { init, kafkaRouter, ok, err } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "process-order": procedure
    .input({
      message: z.object({
        orderId: z.string(),
        amount: z.number(),
      }),
    })
    .errors({
      INVALID_ORDER: z.object({
        error: z.object({
          code: z.literal("INVALID_ORDER"),
          message: z.string(),
          orderId: z.string(),
        }),
      }),
      INSUFFICIENT_FUNDS: z.object({
        error: z.object({
          code: z.literal("INSUFFICIENT_FUNDS"),
          message: z.string(),
          required: z.number(),
          available: z.number(),
        }),
      }),
    })
    .subscribe(({ input }) => {
      if (!isValidOrder(input.orderId)) {
        return err({
          data: {
            error: {
              code: "INVALID_ORDER" as const,
              message: "Order not found",
              orderId: input.orderId,
            },
          },
        });
      }

      const available = getAvailableFunds();
      if (input.amount > available) {
        return err({
          data: {
            error: {
              code: "INSUFFICIENT_FUNDS" as const,
              message: "Insufficient funds",
              required: input.amount,
              available,
            },
          },
        });
      }

      processOrder(input);
      return ok();
    }),
});
```

## Consumer Error Handling

```typescript
import { createConsumer, ProcessingError } from "@alt-stack/kafka-core";

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  onError: (error) => {
    if (error instanceof ProcessingError) {
      console.error("Processing error:", error.code, error.details);
      sendToDeadLetterQueue(error);
    } else {
      console.error("Unexpected error:", error);
    }
  },
});
```

## Result Pattern

Handlers return `Result<Errors, Output>`:

```typescript
import { ok, err, isOk, isErr } from "@alt-stack/kafka-core";

// Success
return ok({ processed: true });

// Success with void
return ok();

// Error
return err({
  data: {
    error: { code: "FAILED" as const, message: "Processing failed" },
  },
});
```

## Error Types

The library exports:

- `KafkaError` - Base error class with `code`, `message`, and optional `details`
- `ValidationError` - Schema validation failures
- `ProcessingError` - Handler execution errors

## See Also

- [Result Documentation](/result) - Complete guide to the Result type

---

// File: kafka/core-concepts/middleware

# Middleware

Add cross-cutting concerns like logging, metrics, or authentication.

## Basic Middleware

```typescript
const { procedure } = init();

const loggedProcedure = procedure.use(async ({ ctx, next }) => {
  console.log(`Processing message from ${ctx.topic}`);
  const result = await next();
  console.log(`Completed processing`);
  return result;
});

const router = kafkaRouter({
  events: loggedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input }) => {
      // Logging middleware runs before/after this
    }),
});
```

## Context Extension

Middleware can add properties to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await getUserFromMessage(ctx.message);
  return next({ ctx: { user } });
});

const router = kafkaRouter({
  "protected-events": authMiddleware
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx.user is available and typed
      console.log(`User: ${ctx.user.name}`);
    }),
});
```

## Reusable Middleware with createMiddleware

```typescript
import { createMiddleware } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
}

const metricsMiddleware = createMiddleware<AppContext>()(async ({ ctx, next }) => {
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  metrics.recordDuration(ctx.topic, duration);
  return result;
});
```

## Chaining Middleware

```typescript
const { procedure } = init<AppContext>();

const protectedProcedure = procedure
  .use(loggingMiddleware)
  .use(authMiddleware)
  .use(metricsMiddleware);

// All three middleware run in order
const router = kafkaRouter({
  events: protectedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {}),
});
```

## Piping Middleware Builders

```typescript
const authChain = createMiddleware<AppContext>()
  .pipe(validateSession)
  .pipe(loadUser);

// Use the chain
const protectedProcedure = procedure.use(authChain);
```

---

// File: kafka/core-concepts/producers

# Producers

Create type-safe Kafka producers using AsyncAPI-generated types.

## Installation

```bash
# Core + KafkaJS binding
pnpm add @alt-stack/kafka-client-core @alt-stack/kafka-client-kafkajs kafkajs zod

# Or for WarpStream
pnpm add @alt-stack/kafka-client-core @alt-stack/kafka-client-warpstream kafkajs zod
```

## Basic Setup

Use types generated from your AsyncAPI spec with `zod-asyncapi`:

```typescript
// 1. Generate types from AsyncAPI spec
// npx zod-asyncapi asyncapi.json -o ./generated-types.ts

// 2. Import generated types
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

// 3. Create type-safe client
const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// 4. Send messages with full type safety
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

## KafkaJS Client

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: {
    brokers: ["localhost:9092"],
    clientId: "my-app",
    ssl: true,
    sasl: { mechanism: "plain", username: "user", password: "pass" },
  },
  topics: Topics,
  producerConfig: {
    allowAutoTopicCreation: false,
  },
  onError: (error) => console.error("Producer error:", error),
});
```

## WarpStream Client

Optimized for WarpStream with recommended defaults (LZ4 compression, extended timeouts):

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
  clientId: "my-producer",
});
```

## Type-Safe Sending

```typescript
// TypeScript enforces valid topics and message shapes
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});

// Type error: "invalid-topic" doesn't exist
await client.send("invalid-topic", { data: "test" });

// Type error: missing required field
await client.send("user-events", { userId: "123" });
```

## Batch Sending

```typescript
await client.sendBatch("user-events", [
  { userId: "user-1", eventType: "created", timestamp: Date.now() },
  { userId: "user-2", eventType: "created", timestamp: Date.now() },
  { userId: "user-1", eventType: "updated", timestamp: Date.now() },
]);
```

## Send Options

```typescript
await client.send(
  "user-events",
  { userId: "123", eventType: "created", timestamp: Date.now() },
  {
    key: "user-123",              // Message key for partitioning
    partition: 0,                 // Explicit partition
    headers: { source: "api" },   // Custom headers
    timestamp: Date.now().toString(),
  }
);
```

## Disconnecting

```typescript
await client.disconnect();
```

## Accessing Raw Producer

For advanced use cases (transactions, producer events, etc.), access the underlying KafkaJS producer:

```typescript
// Access the raw kafkajs Producer
const rawProducer = client.producer;

// Use kafkajs features directly
await rawProducer.send({
  topic: "my-topic",
  messages: [{ value: "raw message" }],
  acks: -1,
  timeout: 30000,
});
```

## Error Handling

```typescript
import { ValidationError, SendError, ConnectionError } from "@alt-stack/kafka-client-kafkajs";

try {
  await client.send("user-events", invalidData);
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Invalid message:", error.topic, error.details);
  } else if (error instanceof SendError) {
    console.error("Failed to send:", error.topic, error.cause);
  } else if (error instanceof ConnectionError) {
    console.error("Connection failed:", error.cause);
  }
}
```

---

// File: kafka/core-concepts/topics-and-procedures

# Topics and Procedures

Define Kafka topics with type-safe message schemas using `kafkaRouter`.

## Basic Topic Definition

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({
      message: z.object({
        userId: z.string(),
        eventType: z.string(),
      }),
    })
    .subscribe(({ input }) => {
      // input is the validated message
      console.log(input.userId);
    }),
});
```

## Message Validation

Messages are validated before the handler runs:

```typescript
const router = kafkaRouter({
  orders: procedure
    .input({
      message: z.object({
        orderId: z.string().uuid(),
        amount: z.number().positive(),
        currency: z.string().length(3),
      }),
    })
    .subscribe(({ input }) => {
      // Only called if message passes validation
      processOrder(input);
    }),
});
```

## Multiple Topics

```typescript
const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input }) => handleUserEvent(input)),

  "order-events": procedure
    .input({ message: OrderEventSchema })
    .subscribe(({ input }) => handleOrderEvent(input)),
});
```

## Output Validation

Optionally validate handler return values:

```typescript
const router = kafkaRouter({
  "process-data": procedure
    .input({
      message: z.object({ data: z.string() }),
    })
    .output(
      z.object({
        processed: z.boolean(),
        result: z.string(),
      })
    )
    .subscribe(({ input }) => ({
      processed: true,
      result: input.data.toUpperCase(),
    })),
});
```

## subscribe vs handler

- `.subscribe()` - Use in `kafkaRouter({})` config (topic determined by key)
- `.handler()` - Creates a pending procedure for manual registration

```typescript
// Using subscribe (recommended)
const router = kafkaRouter({
  "my-topic": procedure.input({ message: Schema }).subscribe(({ input }) => {}),
});

// Using handler for manual registration
const pendingProc = procedure.input({ message: Schema }).handler(({ input }) => {});
const router = createKafkaRouter();
router.registerPendingProcedure("my-topic", pendingProc);
```

---

// File: kafka/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/kafka-core kafkajs zod
```

## Peer Dependencies

- **kafkajs**: `^2.0.0` - Kafka client
- **zod**: `^3.25.0` - Schema validation

---

// File: kafka/getting-started/quickstart

# Quickstart

## Consumer

```typescript
import { init, kafkaRouter, createConsumer } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";
import { z } from "zod";

const UserEventSchema = z.object({
  userId: z.string(),
  eventType: z.enum(["created", "updated", "deleted"]),
  timestamp: z.number(),
});

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      console.log(`Event: ${input.eventType} for user ${input.userId}`);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-consumer",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});
```

## Producer (using Kafka Client)

For producers, use the Kafka client packages with AsyncAPI-generated types:

```typescript
// 1. Generate types: npx zod-asyncapi asyncapi.json -o ./generated-types.ts
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

Or with WarpStream:

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

---

// File: real-life/auth-service

# Auth Service

The authentication service handles user registration, login, and session management.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/api/signup` | Register new user |
| POST | `/api/login` | Authenticate user |
| POST | `/api/logout` | Invalidate session |
| GET | `/api/me` | Get current user |
| GET | `/api/validate` | Validate token (internal) |

## Implementation

```typescript title="apps/backend-auth/src/index.ts"
import { createDocsRouter, createServer, init, router, type HonoBaseContext } from "@alt-stack/server-hono";
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
});

const SessionSchema = z.object({
  token: z.string(),
  userId: z.string(),
  expiresAt: z.string().datetime(),
});

const factory = init<HonoBaseContext>();
const publicProc = factory.procedure;

const authRouter = router<HonoBaseContext>({
  "/signup": publicProc
    .input({
      body: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string().min(1),
      }),
    })
    .output(z.object({ user: UserSchema, session: SessionSchema }))
    .errors({
      409: z.object({ error: z.object({ code: z.literal("EMAIL_EXISTS"), message: z.string() }) }),
    })
    .post(({ input, ctx }) => {
      // Check if email exists, create user, create session
      // ...
    }),

  "/login": publicProc
    .input({
      body: z.object({
        email: z.string().email(),
        password: z.string(),
      }),
    })
    .output(z.object({ user: UserSchema, session: SessionSchema }))
    .errors({
      401: z.object({ error: z.object({ code: z.literal("INVALID_CREDENTIALS"), message: z.string() }) }),
    })
    .post(({ input, ctx }) => {
      // Verify credentials, create session
      // ...
    }),

  // Internal endpoint for other services to validate tokens
  "/validate": publicProc
    .output(z.object({ valid: z.boolean(), userId: z.string().optional() }))
    .get(({ ctx }) => {
      const auth = ctx.hono.req.header("Authorization") ?? "";
      const token = auth.replace("Bearer ", "");
      const session = sessions.get(token);
      if (!session || session.expiresAt < new Date()) {
        return { valid: false };
      }
      return { valid: true, userId: session.userId };
    }),
});
```

## Token Validation Endpoint

The `/validate` endpoint is designed for service-to-service communication. Other services can call it to verify tokens without implementing token parsing themselves.

```typescript
// In backend-logic
async function validateToken(token: string): Promise<string | null> {
  const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
    headers: { authorization: token },
  }).json<{ valid: boolean; userId?: string }>();
  
  return res.valid ? (res.userId ?? null) : null;
}
```

## Generating the OpenAPI Spec

```typescript title="apps/backend-auth/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateOpenAPISpec } from "@alt-stack/server-hono";
import { authRouter } from "./index.js";

const spec = generateOpenAPISpec({ api: authRouter }, {
  title: "Auth API",
  version: "1.0.0",
});

writeFileSync("openapi.json", JSON.stringify(spec, null, 2));
console.log("Generated openapi.json");
```

Run with:
```bash
pnpm --filter @real-life/backend-auth generate
```

---

// File: real-life/frontend

# Frontend

NextJS app consuming both backend services via generated SDKs.

## API Client

The frontend uses `@alt-stack/http-client-ky` for type-safe HTTP requests with SDK schemas:

```typescript title="apps/web/src/lib/api.ts"
import { createApiClient } from "@alt-stack/http-client-ky";
import { Request as AuthRequest, Response as AuthResponse } from "@real-life/backend-auth-sdk";
import { Request as LogicRequest, Response as LogicResponse } from "@real-life/backend-logic-sdk";

const AUTH_URL = process.env.NEXT_PUBLIC_AUTH_URL || "http://localhost:3001";
const LOGIC_URL = process.env.NEXT_PUBLIC_LOGIC_URL || "http://localhost:3002";

// Create type-safe clients
const authClient = createApiClient({
  baseUrl: AUTH_URL,
  Request: AuthRequest,
  Response: AuthResponse,
});

const logicClient = createApiClient({
  baseUrl: LOGIC_URL,
  Request: LogicRequest,
  Response: LogicResponse,
});

// Auth API
export const authApi = {
  async login(data: { email: string; password: string }) {
    const result = await authClient.post("/api/login", { body: data });
    if (!result.success) throw new Error("Login failed");
    return result.body;
  },

  async me(token: string) {
    const result = await authClient.get("/api/me", {
      headers: { authorization: `Bearer ${token}` },
    });
    if (!result.success) throw new Error("Failed to get user");
    return result.body;
  },
};

// Logic API
export const logicApi = {
  async listTasks(token?: string) {
    const result = await logicClient.get("/api/", {
      headers: token ? { authorization: `Bearer ${token}` } : undefined,
    });
    if (!result.success) throw new Error("Failed to list tasks");
    return result.body;
  },

  async createTask(token: string, data: { title: string; description?: string }) {
    const result = await logicClient.post("/api/", {
      body: data,
      headers: { authorization: `Bearer ${token}` },
    });
    if (!result.success) throw new Error("Failed to create task");
    return result.body;
  },
};
```

## Type Safety

The `http-client-ky` client provides full type inference from the SDK's `Request` and `Response` objects:

```typescript
// TypeScript knows:
// - Valid endpoints: "/api/", "/api/{id}"
// - Required params/body for each endpoint
// - Response body type for each status code
const result = await logicClient.get("/api/", {
  headers: token ? { authorization: `Bearer ${token}` } : undefined,
});

if (result.success) {
  // result.body is typed as Task[]
  result.body.forEach(task => {
    console.log(task.title);  // ✅ TypeScript knows this exists
    console.log(task.status); // ✅ "pending" | "in_progress" | "completed"
  });
} else {
  // result.error is typed based on the error response schema
  console.error(result.error);
}
```

## React Component

```typescript title="apps/web/src/app/page.tsx"
"use client";

import { useState, useEffect } from "react";
import { authApi, logicApi } from "@/lib/api";
import type { z } from "zod";
import type { TaskSchema } from "@real-life/backend-logic-sdk";

type Task = z.infer<typeof TaskSchema>;

export default function Home() {
  const [token, setToken] = useState<string | null>(null);
  const [user, setUser] = useState<{ id: string; email: string; name: string } | null>(null);
  const [tasks, setTasks] = useState<Task[]>([]);

  // Load token from localStorage
  useEffect(() => {
    const saved = localStorage.getItem("auth_token");
    if (saved) setToken(saved);
  }, []);

  // Fetch user and tasks when token changes
  useEffect(() => {
    if (!token) return;
    authApi.me(token).then(setUser).catch(() => setToken(null));
    logicApi.listTasks(token).then(setTasks);
  }, [token]);

  const handleLogin = async (email: string, password: string) => {
    const result = await authApi.login({ email, password });
    localStorage.setItem("auth_token", result.session.token);
    setToken(result.session.token);
  };

  const handleCreateTask = async (title: string) => {
    if (!token) return;
    const task = await logicApi.createTask(token, { title });
    setTasks([...tasks, task]);
  };

  // ... render UI
}
```

## NextJS Configuration

Configure transpilation for workspace packages:

```javascript title="apps/web/next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: [
    "@real-life/backend-auth-sdk",
    "@real-life/backend-logic-sdk",
  ],
};

module.exports = nextConfig;
```

---

// File: real-life/index

# Real Life Example

A complete example showing how to use all Alt-stack packages together in a production-like setup.

## Overview

This example demonstrates a task management system with:

- **2 Backend Services** (Hono): Authentication and business logic
- **Background Workers** (WarpStream): Notifications and report generation
- **NextJS Frontend**: Consumes both services via generated SDKs
- **Type-safe SDKs**: Generated from OpenAPI/AsyncAPI specs

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                          NextJS Web App                          │
│              (uses http-client-ky + generated SDKs)              │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    │                       │
                    ▼                       ▼
        ┌───────────────────┐   ┌───────────────────┐
        │   backend-auth    │   │   backend-logic   │
        │   (Hono server)   │   │   (Hono server)   │
        │                   │   │                   │
        │ - POST /signup    │◄──│ validates tokens  │
        │ - POST /login     │   │                   │
        │ - POST /logout    │   │ - GET/POST /tasks │
        │ - GET /me         │   │ - PUT/DELETE /{id}│
        │ - GET /validate   │   │                   │
        └───────────────────┘   └─────────┬─────────┘
                                          │
                                          │ triggers jobs
                                          ▼
                                ┌───────────────────┐
                                │     WarpStream    │
                                │     Workers       │
                                │                   │
                                │ - send-notification│
                                │ - generate-report │
                                └───────────────────┘
```

## Key Takeaways

### 1. End-to-End Type Safety

Types flow from Zod schemas through OpenAPI/AsyncAPI specs to generated SDKs:

```typescript
// Define once in backend-logic
const TaskSchema = z.object({
  id: z.string(),
  title: z.string(),
  status: z.enum(["pending", "in_progress", "completed"]),
});

// Automatically available in frontend via SDK
import type { TaskSchema } from "@real-life/backend-logic-sdk";
type Task = z.infer<typeof TaskSchema>;
```

### 2. Service-to-Service Auth

The logic service validates tokens by calling the auth service's internal endpoint:

```typescript
// backend-logic calls backend-auth
async function validateToken(token: string): Promise<string | null> {
  const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
    headers: { authorization: token },
  }).json<{ valid: boolean; userId?: string }>();
  return res.valid ? res.userId ?? null : null;
}
```

### 3. Protected Procedures with Middleware

Create reusable authenticated procedures:

```typescript
const protectedProc = factory.procedure
  .errors({ 401: z.object({ error: z.object({ code: z.literal("UNAUTHORIZED") }) }) })
  .use(async ({ ctx, next }) => {
    if (!ctx.userId) throw ctx.error({ error: { code: "UNAUTHORIZED", ... } });
    return next({ ctx: { userId: ctx.userId } }); // narrow type
  });
```

### 4. Type-Safe Background Jobs

Trigger workers with full type inference from the SDK:

```typescript
import { Topics } from "@real-life/workers-sdk";

const client = await createWarpStreamClient({ jobs: Topics, ... });

// TypeScript knows the exact payload shape
await client.trigger("send-notification", {
  type: "task_created",  // must be valid enum
  userId: ctx.userId,
  taskId: id,
  taskTitle: input.body.title,
});
```

### 5. Built-in Telemetry

Enable [OpenTelemetry tracing](/guides/telemetry) with a single flag:

```typescript
const app = createServer(
  { api: taskRouter, docs: docsRouter },
  {
    createContext,
    telemetry: {
      enabled: env.NODE_ENV === "production",
      serviceName: "backend-logic",
      ignoreRoutes: ["/docs"],
    },
  },
);
```

### 6. SDK-First Frontend

The frontend uses generated SDKs with `http-client-ky` for fully typed API calls:

```typescript
import { createApiClient } from "@alt-stack/http-client-ky";
import { Request, Response } from "@real-life/backend-logic-sdk";

const client = createApiClient({ baseUrl, Request, Response });

// Full autocomplete for paths, params, body, and response
const result = await client.get("/api/{id}", {
  params: { id: "..." },
  headers: { authorization: `Bearer ${token}` },
});
if (result.success) {
  console.log(result.body.title); // TypeScript knows this exists
}
```

## What You'll Learn

| Topic | Description |
|-------|-------------|
| [Project Structure](./project-structure) | Monorepo layout and package organization |
| [Auth Service](./auth-service) | Building the authentication service |
| [Logic Service](./logic-service) | Business logic with auth integration |
| [Workers](./workers) | Background job processing with WarpStream |
| [Frontend](./frontend) | NextJS app with SDK consumption |
| [SDK Generation](./sdk-generation) | Generating and using type-safe SDKs |

## Quick Start

```bash
# Clone and navigate to example
cd examples/real-life

# Install dependencies
pnpm install

# Generate SDKs
pnpm generate:all

# Start all services (in separate terminals)
pnpm --filter @real-life/backend-auth dev   # Port 3001
pnpm --filter @real-life/backend-logic dev  # Port 3002
pnpm --filter @real-life/workers dev
pnpm --filter @real-life/web dev            # Port 3000
```

## Technologies Used

| Package | Technology | Purpose |
|---------|------------|---------|
| `@alt-stack/server-hono` | Hono | Type-safe HTTP servers with telemetry |
| `@alt-stack/workers-warpstream` | WarpStream/Kafka | Background job processing |
| `@alt-stack/workers-client-warpstream` | WarpStream/Kafka | Job triggering |
| `@alt-stack/zod-openapi` | OpenAPI | REST API SDK generation |
| `@alt-stack/zod-asyncapi` | AsyncAPI | Worker SDK generation |
| `@alt-stack/http-client-ky` | ky | Type-safe HTTP client with SDK integration |
| `@opentelemetry/api` | OpenTelemetry | Distributed tracing (optional) |
| `Next.js` | React | Frontend framework |

---

// File: real-life/logic-service

# Logic Service

The business logic service handles task management and triggers background workers.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | `/api/` | List all tasks |
| POST | `/api/` | Create task (auth required) |
| GET | `/api/{id}` | Get task by ID |
| PUT | `/api/{id}` | Update task (auth required) |
| DELETE | `/api/{id}` | Delete task (auth required) |

## Auth Integration

The service validates tokens by calling the auth service:

```typescript
const AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || "http://localhost:3001";

async function validateToken(token: string): Promise<string | null> {
  try {
    const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
      headers: { authorization: token },
    }).json<{ valid: boolean; userId?: string }>();
    return res.valid ? (res.userId ?? null) : null;
  } catch {
    return null;
  }
}

// Context creation
async function createContext(c: Context): Promise<AppContext> {
  const auth = c.req.header("Authorization");
  const userId = auth ? await validateToken(auth) : null;
  return { userId };
}
```

## Protected Procedures

```typescript
interface AppContext {
  userId: string | null;
}

const factory = init<AppContext>();

const protectedProc = factory.procedure
  .errors({
    401: z.object({ error: z.object({ code: z.literal("UNAUTHORIZED"), message: z.string() }) }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.userId) {
      throw ctx.error({ error: { code: "UNAUTHORIZED", message: "Authentication required" } });
    }
    return next({ ctx: { userId: ctx.userId } });
  });
```

## Worker Triggers

When tasks are created or completed, the service triggers background workers:

```typescript
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";
import { Topics } from "@real-life/workers-sdk";

const workerClient = await createWarpStreamClient({
  bootstrapServer: WARPSTREAM_URL,
  jobs: Topics,
});

// In create task handler
await workerClient.trigger("send-notification", {
  type: "task_created",
  userId: ctx.userId,
  taskId: id,
  taskTitle: input.body.title,
});

// In update task handler (when completed)
if (!wasCompleted && nowCompleted) {
  await workerClient.trigger("generate-report", {
    taskId: task.id,
    userId: ctx.userId,
    completedAt: task.updatedAt.toISOString(),
  });
}
```

## Full Router

```typescript
const taskRouter = router<AppContext>({
  "/": {
    get: factory.procedure
      .output(z.array(TaskSchema))
      .handler(() => Array.from(tasks.values())),

    post: protectedProc
      .input({
        body: z.object({
          title: z.string().min(1).max(200),
          description: z.string().max(1000).optional(),
        }),
      })
      .output(TaskSchema)
      .handler(async ({ input, ctx }) => {
        const task = createTask(input.body, ctx.userId);
        await workerClient.trigger("send-notification", { ... });
        return task;
      }),
  },

  "{id}": {
    get: factory.procedure
      .input({ params: z.object({ id: z.string().uuid() }) })
      .output(TaskSchema)
      .errors({ 404: NotFoundError })
      .handler(({ input, ctx }) => {
        const task = tasks.get(input.params.id);
        if (!task) throw ctx.error({ error: { code: "NOT_FOUND", message: "Task not found" } });
        return task;
      }),

    put: protectedProc
      .input({
        params: z.object({ id: z.string().uuid() }),
        body: z.object({
          title: z.string().min(1).max(200).optional(),
          description: z.string().max(1000).optional(),
          status: z.enum(["pending", "in_progress", "completed"]).optional(),
        }),
      })
      .output(TaskSchema)
      .errors({ 404: NotFoundError, 403: ForbiddenError })
      .handler(async ({ input, ctx }) => {
        // Update task, trigger report if completed
        // ...
      }),

    delete: protectedProc
      .input({ params: z.object({ id: z.string().uuid() }) })
      .output(z.object({ success: z.boolean() }))
      .errors({ 404: NotFoundError, 403: ForbiddenError })
      .handler(({ input, ctx }) => {
        // Delete task
        // ...
      }),
  },
});
```

---

// File: real-life/project-structure

# Project Structure

The real-life example is organized as a pnpm monorepo with apps and packages.

## Directory Layout

```
examples/real-life/
├── package.json           # Workspace root
├── pnpm-workspace.yaml    # Workspace config
├── apps/
│   ├── backend-auth/      # Auth service (Hono)
│   │   ├── src/
│   │   │   ├── index.ts          # Server entry
│   │   │   └── generate-spec.ts  # OpenAPI generator
│   │   ├── openapi.json          # Generated spec
│   │   └── package.json
│   │
│   ├── backend-logic/     # Business logic service (Hono)
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   └── generate-spec.ts
│   │   ├── openapi.json
│   │   └── package.json
│   │
│   ├── workers/           # Background workers (WarpStream)
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   └── generate-spec.ts
│   │   ├── asyncapi.json
│   │   └── package.json
│   │
│   └── web/               # NextJS frontend
│       ├── src/
│       │   ├── app/
│       │   └── lib/api.ts
│       └── package.json
│
└── packages/
    ├── backend-auth-sdk/  # Generated OpenAPI SDK
    ├── backend-logic-sdk/ # Generated OpenAPI SDK
    └── workers-sdk/       # Generated AsyncAPI SDK
```

## Package Dependencies

```
@real-life/web
├── @real-life/backend-auth-sdk
├── @real-life/backend-logic-sdk
└── ky

@real-life/backend-logic
├── @alt-stack/server-hono
├── @alt-stack/workers-client-warpstream
├── @real-life/workers-sdk
└── ky (for calling backend-auth)

@real-life/backend-auth
└── @alt-stack/server-hono

@real-life/workers
└── @alt-stack/workers-warpstream
```

## Workspace Configuration

```yaml title="pnpm-workspace.yaml"
packages:
  - "apps/*"
  - "packages/*"
```

## Scripts

```json title="package.json"
{
  "scripts": {
    "dev": "pnpm -r run dev",
    "build": "pnpm -r run build",
    "generate:all": "pnpm -r run generate"
  }
}
```

Each app has a `generate` script that:
1. Runs `generate-spec.ts` to create the JSON spec
2. Runs the corresponding SDK package's `generate` script

```json title="apps/backend-auth/package.json"
{
  "scripts": {
    "generate": "tsx src/generate-spec.ts && pnpm --filter @real-life/backend-auth-sdk generate"
  }
}
```

---

// File: real-life/sdk-generation

# SDK Generation

Type-safe SDKs are generated from OpenAPI and AsyncAPI specs.

## Generation Flow

```
┌──────────────────────────────────────────────────────────────────┐
│ 1. Define routes with Zod schemas                                │
│    └── router({ "/users": procedure.output(UserSchema).get(...) })│
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 2. Generate spec file                                            │
│    └── generateOpenAPISpec({ api: router }) → openapi.json       │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 3. Generate SDK from spec                                        │
│    └── zod-openapi openapi.json -o src/index.ts                  │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 4. SDK exports Zod schemas + Request/Response types              │
│    └── import { UserSchema, Request, Response } from "sdk"       │
└──────────────────────────────────────────────────────────────────┘
```

## OpenAPI SDK (REST APIs)

### Generate Spec Script

```typescript title="apps/backend-auth/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateOpenAPISpec } from "@alt-stack/server-hono";
import { authRouter } from "./index.js";

const spec = generateOpenAPISpec({ api: authRouter }, {
  title: "Auth API",
  version: "1.0.0",
});

writeFileSync("openapi.json", JSON.stringify(spec, null, 2));
console.log("Generated openapi.json");
```

### SDK Package

```json title="packages/backend-auth-sdk/package.json"
{
  "name": "@real-life/backend-auth-sdk",
  "scripts": {
    "generate": "zod-openapi ../../apps/backend-auth/openapi.json -o src/index.ts"
  },
  "devDependencies": {
    "@alt-stack/zod-openapi": "workspace:*"
  }
}
```

### Generated Output

```typescript title="packages/backend-auth-sdk/src/index.ts (generated)"
import { z } from "zod";

export const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
});
export type User = z.infer<typeof UserSchema>;

export const Request = {
  "/api/signup": {
    POST: {
      body: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string().min(1),
      }),
    },
  },
  // ...
} as const;

export const Response = {
  "/api/signup": {
    POST: {
      "200": z.object({ user: UserSchema, session: SessionSchema }),
      "409": z.object({ error: z.object({ code: z.literal("EMAIL_EXISTS"), message: z.string() }) }),
    },
  },
  // ...
} as const;
```

## AsyncAPI SDK (Workers)

### Generate Spec Script

```typescript title="apps/workers/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateAsyncAPISpec } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./index.js";

const spec = generateAsyncAPISpec(jobRouter, {
  title: "Real Life Workers",
  version: "1.0.0",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

### SDK Package

```json title="packages/workers-sdk/package.json"
{
  "name": "@real-life/workers-sdk",
  "scripts": {
    "generate": "zod-asyncapi ../../apps/workers/asyncapi.json -o src/index.ts"
  },
  "devDependencies": {
    "@alt-stack/zod-asyncapi": "workspace:*"
  }
}
```

### Generated Output

```typescript title="packages/workers-sdk/src/index.ts (generated)"
import { z } from "zod";

export const SendNotificationPayloadSchema = z.object({
  type: z.enum(["task_created", "task_completed", "task_assigned"]),
  userId: z.string(),
  taskId: z.string(),
  taskTitle: z.string(),
});

export const Topics = {
  "send-notification": SendNotificationPayloadSchema,
  "generate-report": GenerateReportPayloadSchema,
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Running Generation

```bash
# Generate all specs and SDKs
pnpm generate:all

# Or individually
pnpm --filter @real-life/backend-auth generate
pnpm --filter @real-life/backend-logic generate
pnpm --filter @real-life/workers generate
```

## CI/CD Integration

See [CI/CD SDK Generation](/guides/ci-cd-sdk-generation) for automating SDK generation in GitHub Actions.

---

// File: real-life/workers

# Workers

Background job processing using WarpStream (Kafka-compatible).

## Job Definitions

```typescript title="apps/workers/src/index.ts"
import { createWorker, init, workerRouter } from "@alt-stack/workers-warpstream";
import { z } from "zod";

const { procedure } = init();

export const jobRouter = workerRouter({
  "send-notification": procedure
    .input({
      payload: z.object({
        type: z.enum(["task_created", "task_completed", "task_assigned"]),
        userId: z.string(),
        taskId: z.string(),
        taskTitle: z.string(),
      }),
    })
    .task(async ({ input }) => {
      console.log(`[Notification] ${input.type} for user ${input.userId}`);
      // Send email, push notification, etc.
    }),

  "generate-report": procedure
    .input({
      payload: z.object({
        taskId: z.string(),
        userId: z.string(),
        completedAt: z.string().datetime(),
      }),
    })
    .task(async ({ input }) => {
      console.log(`[Report] Generating report for task ${input.taskId}`);
      // Generate PDF, store in S3, etc.
    }),
});
```

## Starting the Worker

```typescript
const worker = await createWorker(jobRouter, {
  kafka: { brokers: [WARPSTREAM_URL] },
  groupId: GROUP_ID,
});

console.log("Workers running, waiting for jobs...");

// Graceful shutdown
process.on("SIGINT", async () => {
  await worker.disconnect();
  process.exit(0);
});

await new Promise(() => {});
```

## Generating the AsyncAPI Spec

```typescript title="apps/workers/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateAsyncAPISpec } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./index.js";

const spec = generateAsyncAPISpec(jobRouter, {
  title: "Real Life Workers",
  version: "1.0.0",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

## SDK Generation

The generated SDK exports a `Topics` object for type-safe job triggering:

```typescript title="packages/workers-sdk/src/index.ts (generated)"
import { z } from "zod";

export const SendNotificationPayloadSchema = z.object({
  type: z.enum(["task_created", "task_completed", "task_assigned"]),
  userId: z.string(),
  taskId: z.string(),
  taskTitle: z.string(),
});

export const GenerateReportPayloadSchema = z.object({
  taskId: z.string(),
  userId: z.string(),
  completedAt: z.string(),
});

export const Topics = {
  "send-notification": SendNotificationPayloadSchema,
  "generate-report": GenerateReportPayloadSchema,
} as const;
```

## Consuming the SDK

```typescript
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";
import { Topics } from "@real-life/workers-sdk";

const client = await createWarpStreamClient({
  bootstrapServer: "warpstream.example.com:9092",
  jobs: Topics,
});

// Type-safe: TypeScript knows the payload shape
await client.trigger("send-notification", {
  type: "task_created",  // ✅ Must be valid enum value
  userId: "user-123",
  taskId: "task-456",
  taskTitle: "My Task",
});

// ❌ TypeScript error: invalid payload
await client.trigger("send-notification", {
  invalid: "field",
});
```

---

// File: result/async

# Async Utilities

Work with async operations using `ResultAsync`, `fromPromise()`, `tryCatch()`, and `tryCatchAsync()`.

## ResultAsync

Type alias for a Promise that resolves to a Result:

```typescript
type ResultAsync<A, E extends ResultError> = Promise<Result<A, E>>;
```

Use this type for functions that perform async operations and return Results:

```typescript
import { type ResultAsync, ok, err, TaggedError } from "@alt-stack/result";

class FetchError extends TaggedError {
  readonly _tag = "FetchError";
  constructor(message: string) {
    super(message);
  }
}

async function fetchUser(id: string): ResultAsync<User, FetchError> {
  try {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      return err(new FetchError(`HTTP ${response.status}`));
    }
    const user = await response.json();
    return ok(user);
  } catch (e) {
    return err(new FetchError(String(e)));
  }
}
```

## fromPromise()

Convert a Promise to a ResultAsync by catching rejections:

```typescript
import { fromPromise, TaggedError } from "@alt-stack/result";

class NetworkError extends TaggedError {
  readonly _tag = "NetworkError";
  constructor(public readonly cause: unknown) {
    super(cause instanceof Error ? cause.message : String(cause));
  }
}

const result = await fromPromise(
  fetch("/api/data").then((r) => r.json()),
  (error) => new NetworkError(error)
);
// Result<unknown, NetworkError>
```

### Type Signature

```typescript
function fromPromise<A, E extends ResultError>(
  promise: Promise<A>,
  onReject: (error: unknown) => E
): ResultAsync<A, E>;
```

### Behavior

- If the promise resolves, returns `Ok` with the value
- If the promise rejects, calls `onReject` with the rejection reason and returns `Err`

### Examples

**Wrapping fetch:**

```typescript
const userResult = await fromPromise(
  fetch("/api/user/123").then((r) => {
    if (!r.ok) throw new Error(`HTTP ${r.status}`);
    return r.json();
  }),
  (error) => new FetchError(error)
);
```

**Database operations:**

```typescript
const queryResult = await fromPromise(
  db.query("SELECT * FROM users WHERE id = ?", [userId]),
  (error) => new DatabaseError(error)
);
```

**External APIs:**

```typescript
const weatherResult = await fromPromise(
  weatherApi.getForecast(location),
  (error) => new WeatherApiError(error)
);
```

## tryCatch()

Wrap a synchronous function that might throw:

```typescript
import { tryCatch, TaggedError } from "@alt-stack/result";

class ParseError extends TaggedError {
  readonly _tag = "ParseError";
  constructor(message: string) {
    super(message);
  }
}

const result = tryCatch(
  () => JSON.parse(userInput),
  (error) => new ParseError(error instanceof Error ? error.message : "Parse failed")
);
// Result<unknown, ParseError>
```

### Type Signature

```typescript
function tryCatch<A, E extends ResultError>(
  fn: () => A,
  onError: (error: unknown) => E
): Result<A, E>;
```

### Behavior

- Executes the function in a try-catch
- If it returns successfully, returns `Ok` with the value
- If it throws, calls `onError` with the thrown value and returns `Err`

### Examples

**JSON parsing:**

```typescript
const configResult = tryCatch(
  () => JSON.parse(configString),
  (error) => new ConfigParseError(error)
);

if (isOk(configResult)) {
  applyConfig(configResult.value);
}
```

**Regex operations:**

```typescript
const regexResult = tryCatch(
  () => new RegExp(userPattern),
  (error) => new InvalidRegexError(userPattern, error)
);
```

**Validation:**

```typescript
const validated = tryCatch(
  () => schema.parse(input),
  (error) => new ValidationError(error)
);
```

## tryCatchAsync()

Wrap an async function that might throw or reject:

```typescript
import { tryCatchAsync, TaggedError } from "@alt-stack/result";

class ApiError extends TaggedError {
  readonly _tag = "ApiError";
  constructor(message: string, public readonly statusCode?: number) {
    super(message);
  }
}

const result = await tryCatchAsync(
  async () => {
    const response = await fetch("/api/data");
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }
    return response.json();
  },
  (error) => new ApiError(error instanceof Error ? error.message : "Request failed")
);
```

### Type Signature

```typescript
function tryCatchAsync<A, E extends ResultError>(
  fn: () => Promise<A>,
  onError: (error: unknown) => E
): ResultAsync<A, E>;
```

### Behavior

- Executes the async function
- If it resolves, returns `Ok` with the value
- If it throws synchronously or rejects, calls `onError` and returns `Err`

### Examples

**Fetching with error handling:**

```typescript
const fetchUserResult = await tryCatchAsync(
  async () => {
    const response = await fetch(`/api/users/${id}`);
    if (!response.ok) {
      throw new Error(`User fetch failed: ${response.status}`);
    }
    return response.json() as Promise<User>;
  },
  (error) => new FetchError(error)
);
```

**Database transactions:**

```typescript
const transactionResult = await tryCatchAsync(
  async () => {
    await db.beginTransaction();
    await db.insert("users", userData);
    await db.insert("profiles", profileData);
    await db.commit();
    return { userId, profileId };
  },
  async (error) => {
    await db.rollback();
    return new TransactionError(error);
  }
);
```

**File operations:**

```typescript
const fileResult = await tryCatchAsync(
  async () => {
    const content = await fs.readFile(path, "utf-8");
    return JSON.parse(content);
  },
  (error) => new FileReadError(path, error)
);
```

## Combining with Other Utilities

Async Results work with all other Result utilities:

```typescript
import { tryCatchAsync, flatMap, map, match, isOk } from "@alt-stack/result";

// Chaining async operations
async function processUser(id: string) {
  const userResult = await tryCatchAsync(
    () => fetchUser(id),
    (e) => new FetchError(e)
  );

  if (isOk(userResult)) {
    const profileResult = await tryCatchAsync(
      () => fetchProfile(userResult.value.profileId),
      (e) => new FetchError(e)
    );

    return map(profileResult, (profile) => ({
      user: userResult.value,
      profile,
    }));
  }

  return userResult;
}

// Pattern matching on async result
const message = match(await fetchUserResult, {
  ok: (user) => `Loaded ${user.name}`,
  err: (error) => `Failed: ${error.message}`,
});
```

## fromPromise vs tryCatchAsync

| Function | Input | Catches |
|----------|-------|---------|
| `fromPromise` | Existing Promise | Promise rejections only |
| `tryCatchAsync` | Function returning Promise | Sync throws AND Promise rejections |

**Use `fromPromise`** when you have an existing Promise:

```typescript
const promise = someLibrary.doSomething();
const result = await fromPromise(promise, handleError);
```

**Use `tryCatchAsync`** when you're creating the Promise and might throw synchronously:

```typescript
const result = await tryCatchAsync(
  async () => {
    validateInput(input); // Might throw synchronously
    return await fetchData(input); // Might reject
  },
  handleError
);
```

---

// File: result/combinators

# Combinators

Combine and observe Results with `all()`, `firstOk()`, `tap()`, and `tapError()`.

## all()

Combine multiple Results into a single Result containing an array of values. Fails fast on the first error:

```typescript
import { ok, err, all, TaggedError } from "@alt-stack/result";

class ValidationError extends TaggedError {
  readonly _tag = "ValidationError";
  constructor(public readonly field: string) {
    super(`Invalid field: ${field}`);
  }
}

const results = [
  ok({ name: "Alice" }),
  ok({ name: "Bob" }),
  ok({ name: "Charlie" }),
];

const combined = all(results);
// Result<[{ name: string }, { name: string }, { name: string }], ValidationError>

if (isOk(combined)) {
  console.log(combined.value);
  // [{ name: "Alice" }, { name: "Bob" }, { name: "Charlie" }]
}
```

### Type Signature

```typescript
function all<T extends readonly Result<any, ResultError>[]>(
  results: T
): Result<
  { [K in keyof T]: T[K] extends Result<infer A, any> ? A : never },
  T[number] extends Result<any, infer E> ? E : never
>;
```

### Fail-Fast Behavior

Returns the first error encountered:

```typescript
const results = [
  ok(1),
  err(new ValidationError("email")), // First error
  err(new ValidationError("name")),  // Never checked
];

const combined = all(results);
// Err<ValidationError> with field: "email"
```

### Examples

**Validating multiple fields:**

```typescript
function validateUser(input: unknown) {
  return all([
    validateName(input.name),
    validateEmail(input.email),
    validateAge(input.age),
  ]);
}

const result = validateUser(formData);
if (isOk(result)) {
  const [name, email, age] = result.value;
  createUser({ name, email, age });
}
```

**Fetching multiple resources:**

```typescript
const [user, profile, settings] = unwrap(
  all([
    await getUser(userId),
    await getProfile(userId),
    await getSettings(userId),
  ])
);
```

## firstOk()

Return the first successful Result, or aggregate all errors:

```typescript
import { ok, err, firstOk, TaggedError } from "@alt-stack/result";

class CacheError extends TaggedError {
  readonly _tag = "CacheError";
  constructor(message: string) {
    super(message);
  }
}

class DatabaseError extends TaggedError {
  readonly _tag = "DatabaseError";
  constructor(message: string) {
    super(message);
  }
}

const results = [
  err(new CacheError("Cache miss")),
  ok({ id: "123", name: "Alice" }), // First success
  ok({ id: "456", name: "Bob" }),   // Not checked
];

const first = firstOk(results);
// Ok<{ id: string; name: string }>
```

### Type Signature

```typescript
function firstOk<A, E extends ResultError>(
  results: Result<A, E>[]
): Result<A, ResultAggregateError<E>>;
```

### ResultAggregateError

When all Results are errors, returns a `ResultAggregateError` containing all errors:

```typescript
import { ResultAggregateError } from "@alt-stack/result";

const results = [
  err(new CacheError("Cache miss")),
  err(new DatabaseError("Connection failed")),
];

const result = firstOk(results);

if (isErr(result) && result.error instanceof ResultAggregateError) {
  console.log(result.error.errors);
  // [CacheError, DatabaseError]

  for (const e of result.error.errors) {
    console.log(e._tag, e.message);
  }
}
```

### Use Cases

**Fallback strategies:**

```typescript
const userData = firstOk([
  await getFromCache(userId),
  await getFromDatabase(userId),
  await getFromBackup(userId),
]);
```

**Multiple data sources:**

```typescript
const config = firstOk([
  loadFromEnv(),
  loadFromFile("./config.json"),
  ok(defaultConfig),
]);
```

## tap()

Execute a side effect on success without changing the Result:

```typescript
import { ok, err, tap } from "@alt-stack/result";

const result = ok({ id: "123", name: "Alice" });

const same = tap(result, (user) => {
  console.log(`Loaded user: ${user.name}`);
  analytics.track("user_loaded", { userId: user.id });
});
// Returns the same Result, side effect executed
```

### Type Signature

```typescript
function tap<A, E extends ResultError>(
  result: Result<A, E>,
  fn: (value: A) => void
): Result<A, E>;
```

### Behavior

- If `Ok`, executes the function and returns the same `Ok`
- If `Err`, returns the same `Err` without calling the function

### Examples

**Logging:**

```typescript
const result = tap(getUserResult, (user) => {
  logger.info("User fetched successfully", { userId: user.id });
});
```

**Metrics:**

```typescript
const result = tap(operationResult, () => {
  metrics.increment("operations.success");
});
```

**Caching:**

```typescript
const result = tap(fetchResult, (data) => {
  cache.set(cacheKey, data, { ttl: 3600 });
});
```

## tapError()

Execute a side effect on error without changing the Result:

```typescript
import { ok, err, tapError, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Not found: ${id}`);
  }
}

const result = err(new NotFoundError("123"));

const same = tapError(result, (error) => {
  console.error(`Error occurred: ${error._tag}`);
  errorReporter.capture(error);
});
// Returns the same Result, side effect executed
```

### Type Signature

```typescript
function tapError<A, E extends ResultError>(
  result: Result<A, E>,
  fn: (error: E) => void
): Result<A, E>;
```

### Behavior

- If `Err`, executes the function and returns the same `Err`
- If `Ok`, returns the same `Ok` without calling the function

### Examples

**Error logging:**

```typescript
const result = tapError(operationResult, (error) => {
  logger.error("Operation failed", {
    errorType: error._tag,
    message: error.message,
  });
});
```

**Error reporting:**

```typescript
const result = tapError(apiResult, (error) => {
  sentry.captureException(error);
});
```

**Metrics:**

```typescript
const result = tapError(result, (error) => {
  metrics.increment(`errors.${error._tag}`);
});
```

## Combining tap and tapError

Chain both to observe all outcomes:

```typescript
const result = tap(
  tapError(operationResult, (error) => {
    logger.error("Failed", { error: error._tag });
    metrics.increment("failures");
  }),
  (value) => {
    logger.info("Succeeded", { value });
    metrics.increment("successes");
  }
);
```

## Comparison

| Function | Success Behavior | Error Behavior | Returns |
|----------|-----------------|----------------|---------|
| `all` | Combines all values | Fails on first error | Single Result with array |
| `firstOk` | Returns first success | Aggregates all errors | Single Result |
| `tap` | Executes side effect | Unchanged | Same Result |
| `tapError` | Unchanged | Executes side effect | Same Result |

## Real-World Example

```typescript
import { all, tap, tapError, tryCatchAsync } from "@alt-stack/result";

async function processOrder(orderId: string) {
  // Fetch all required data
  const dataResult = all([
    await tryCatchAsync(() => getOrder(orderId), (e) => new OrderError(e)),
    await tryCatchAsync(() => getCustomer(customerId), (e) => new CustomerError(e)),
    await tryCatchAsync(() => getInventory(productId), (e) => new InventoryError(e)),
  ]);

  // Log the outcome
  const logged = tap(
    tapError(dataResult, (error) => {
      logger.error("Order processing failed", { orderId, error: error._tag });
    }),
    ([order, customer, inventory]) => {
      logger.info("Order data loaded", { orderId, customerId: customer.id });
    }
  );

  // Process the order
  if (isOk(logged)) {
    const [order, customer, inventory] = logged.value;
    return processOrderWithData(order, customer, inventory);
  }

  return logged;
}
```

---

// File: result/constructors

# Constructors

Create Result values with `ok()` and `err()`.

## ok()

Creates a success Result containing a value:

```typescript
import { ok } from "@alt-stack/result";

// With a value
const result = ok({ id: "123", name: "Alice" });
// Result<{ id: string; name: string }, never>

// Without a value (void)
const voidResult = ok();
// Result<void, never>
```

### Type Signature

```typescript
function ok<A>(value: A): Ok<A>;
function ok(): Ok<void>;
```

### Examples

```typescript
// Primitive values
const numberResult = ok(42);
const stringResult = ok("hello");
const boolResult = ok(true);

// Objects
const userResult = ok({ id: "123", name: "Alice", email: "alice@example.com" });

// Arrays
const listResult = ok([1, 2, 3]);

// Void (no value)
const doneResult = ok();
```

## err()

Creates a failure Result containing an error. The error must extend `Error` and have a `_tag` property:

```typescript
import { err, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
  }
}

const result = err(new NotFoundError("123"));
// Result<never, NotFoundError>
```

### Type Signature

```typescript
function err<E extends ResultError>(error: E): Err<E>;
```

### Error Requirements

Errors passed to `err()` must satisfy the `ResultError` type:

```typescript
type ResultError = Error & { readonly _tag: string };
```

This means:
1. Must extend JavaScript's `Error` class
2. Must have a `_tag` property with a string literal type

### Creating Errors

**Option 1: Extend TaggedError (recommended)**

```typescript
import { TaggedError } from "@alt-stack/result";

class ValidationError extends TaggedError {
  readonly _tag = "ValidationError";
  constructor(
    public readonly field: string,
    message: string
  ) {
    super(message);
  }
}
```

**Option 2: Extend Error directly**

```typescript
class DatabaseError extends Error {
  readonly _tag = "DatabaseError" as const;
  constructor(
    message: string,
    public readonly code: string
  ) {
    super(message);
    this.name = "DatabaseError";
  }
}
```

### Examples

```typescript
// Simple error
const notFound = err(new NotFoundError("user-123"));

// Error with metadata
class RateLimitError extends TaggedError {
  readonly _tag = "RateLimitError";
  constructor(
    public readonly retryAfter: number,
    public readonly limit: number
  ) {
    super(`Rate limit exceeded. Retry after ${retryAfter}s`);
  }
}

const rateLimited = err(new RateLimitError(60, 100));

// Accessing error properties
if (isErr(rateLimited)) {
  console.log(rateLimited.error.retryAfter); // 60
  console.log(rateLimited.error.limit); // 100
}
```

## Usage in Functions

Combine `ok()` and `err()` in functions that return `Result`:

```typescript
import { ok, err, type Result, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`User ${id} not found`);
  }
}

class InactiveError extends TaggedError {
  readonly _tag = "InactiveError";
  constructor(public readonly id: string) {
    super(`User ${id} is inactive`);
  }
}

interface User {
  id: string;
  name: string;
  active: boolean;
}

function getActiveUser(
  id: string
): Result<User, NotFoundError | InactiveError> {
  const user = db.find(id);

  if (!user) {
    return err(new NotFoundError(id));
  }

  if (!user.active) {
    return err(new InactiveError(id));
  }

  return ok(user);
}
```

## Void Returns

Use `ok()` without arguments for functions that succeed without returning a value:

```typescript
function deleteUser(id: string): Result<void, NotFoundError> {
  const user = db.find(id);
  if (!user) {
    return err(new NotFoundError(id));
  }

  db.delete(id);
  return ok(); // Success with no value
}
```

---

// File: result/extraction

# Extraction

Extract values from Results with `unwrap()`, `unwrapOr()`, `unwrapOrElse()`, `getOrUndefined()`, and `getErrorOrUndefined()`.

## unwrap()

Get the value or throw the error:

```typescript
import { ok, err, unwrap, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(message: string) {
    super(message);
  }
}

// Success case
const value = unwrap(ok(42)); // 42

// Error case - throws!
const value2 = unwrap(err(new NotFoundError("Not found"))); // throws NotFoundError
```

### Type Signature

```typescript
function unwrap<A, E extends ResultError>(result: Result<A, E>): A;
```

### When to Use

Use `unwrap()` sparingly, only when:
- You're certain the Result is `Ok`
- Throwing is acceptable behavior
- Testing scenarios

```typescript
// In tests where failure should fail the test
const user = unwrap(await createTestUser());
expect(user.name).toBe("Test User");

// After validation that guarantees success
const validated = validateInput(input);
if (isErr(validated)) {
  throw validated.error;
}
// At this point we know it's Ok
const value = unwrap(validated);
```

## unwrapOr()

Get the value or return a default:

```typescript
import { ok, err, unwrapOr } from "@alt-stack/result";

const successResult = ok({ name: "Alice" });
const errorResult = err(new NotFoundError("User not found"));

// Success case - returns value
const user1 = unwrapOr(successResult, { name: "Guest" });
// { name: "Alice" }

// Error case - returns default
const user2 = unwrapOr(errorResult, { name: "Guest" });
// { name: "Guest" }
```

### Type Signature

```typescript
function unwrapOr<A, E extends ResultError>(result: Result<A, E>, defaultValue: A): A;
```

### Use Cases

```typescript
// Default values for optional data
const theme = unwrapOr(getUserPreference("theme"), "light");

// Fallback for failed operations
const config = unwrapOr(loadConfig(), defaultConfig);

// Safe property access
const count = unwrapOr(getItemCount(), 0);
```

## unwrapOrElse()

Get the value or compute a default from the error:

```typescript
import { ok, err, unwrapOrElse } from "@alt-stack/result";

const result = err(new NotFoundError("user-123"));

const value = unwrapOrElse(result, (error) => {
  console.log(`Using default because: ${error.message}`);
  return { id: "default", name: "Guest" };
});
```

### Type Signature

```typescript
function unwrapOrElse<A, E extends ResultError>(
  result: Result<A, E>,
  fn: (error: E) => A
): A;
```

### Use Cases

**Logging errors while providing defaults:**

```typescript
const user = unwrapOrElse(getUser(id), (error) => {
  logger.warn(`Failed to get user: ${error.message}`);
  return guestUser;
});
```

**Computing defaults based on error type:**

```typescript
const data = unwrapOrElse(fetchData(), (error) => {
  switch (error._tag) {
    case "NetworkError":
      return cachedData;
    case "NotFoundError":
      return [];
    default:
      return defaultData;
  }
});
```

**Lazy evaluation:**

```typescript
// The function is only called if the result is an error
const config = unwrapOrElse(loadConfig(), () => computeExpensiveDefault());
```

## getOrUndefined()

Get the value or `undefined`:

```typescript
import { ok, err, getOrUndefined } from "@alt-stack/result";

const success = ok({ name: "Alice" });
const failure = err(new NotFoundError("Not found"));

getOrUndefined(success); // { name: "Alice" }
getOrUndefined(failure); // undefined
```

### Type Signature

```typescript
function getOrUndefined<A, E extends ResultError>(result: Result<A, E>): A | undefined;
```

### Use Cases

**Optional chaining:**

```typescript
const user = getOrUndefined(getUser(id));
const name = user?.name ?? "Unknown";
```

**Conditional rendering:**

```typescript
const data = getOrUndefined(result);
if (data) {
  renderData(data);
}
```

**Array filtering:**

```typescript
const results = [getUser("1"), getUser("2"), getUser("3")];
const users = results.map(getOrUndefined).filter(Boolean);
// Only successful results
```

## getErrorOrUndefined()

Get the error or `undefined`:

```typescript
import { ok, err, getErrorOrUndefined } from "@alt-stack/result";

const success = ok({ name: "Alice" });
const failure = err(new NotFoundError("Not found"));

getErrorOrUndefined(success); // undefined
getErrorOrUndefined(failure); // NotFoundError
```

### Type Signature

```typescript
function getErrorOrUndefined<A, E extends ResultError>(
  result: Result<A, E>
): E | undefined;
```

### Use Cases

**Error logging:**

```typescript
const error = getErrorOrUndefined(result);
if (error) {
  logger.error(error);
}
```

**Collecting errors:**

```typescript
const results = await Promise.all(items.map(process));
const errors = results.map(getErrorOrUndefined).filter(Boolean);

if (errors.length > 0) {
  reportErrors(errors);
}
```

**Error metrics:**

```typescript
const error = getErrorOrUndefined(result);
if (error) {
  metrics.increment(`errors.${error._tag}`);
}
```

## Comparison

| Function | Returns | Throws | Use When |
|----------|---------|--------|----------|
| `unwrap` | Value | Error | You're certain it's Ok, or throwing is acceptable |
| `unwrapOr` | Value or default | Never | You have a static default value |
| `unwrapOrElse` | Value or computed | Never | Default depends on error or is expensive to compute |
| `getOrUndefined` | Value or undefined | Never | Working with optional values |
| `getErrorOrUndefined` | Error or undefined | Never | Inspecting errors without type guards |

## Safety Guidelines

**Prefer safe extraction methods:**

```typescript
// Good - handles both cases
const value = unwrapOr(result, defaultValue);

// Good - explicit handling
if (isOk(result)) {
  return result.value;
}
return handleError(result.error);

// Use with caution - can throw
const value = unwrap(result);
```

**Use `unwrap()` only when failure is exceptional:**

```typescript
// Good - test assertion
const user = unwrap(createTestUser());

// Bad - runtime uncertainty
const user = unwrap(getUser(id)); // Might throw!

// Better
const userResult = getUser(id);
if (isErr(userResult)) {
  return err(userResult.error);
}
const user = userResult.value;
```

---

// File: result/index

# Result

Type-safe error handling with explicit success and failure states.

## Overview

The `@alt-stack/result` package provides a `Result<A, E>` type for explicit error handling without exceptions. Instead of throwing errors, functions return a `Result` that is either `Ok` (success) or `Err` (failure).

```typescript
import { ok, err, isOk, isErr, type Result } from "@alt-stack/result";

function divide(a: number, b: number): Result<number, DivisionError> {
  if (b === 0) {
    return err(new DivisionError("Cannot divide by zero"));
  }
  return ok(a / b);
}

const result = divide(10, 2);
if (isOk(result)) {
  console.log(result.value); // 5
}
```

## Installation

```bash
pnpm add @alt-stack/result
# or
npm install @alt-stack/result
# or
yarn add @alt-stack/result
```

## Why Result?

Traditional exception handling has drawbacks:

- **Hidden control flow** - Exceptions can be thrown from anywhere, making code hard to follow
- **No type information** - TypeScript can't track what errors a function might throw
- **Easy to forget** - Nothing forces you to handle potential errors

The Result pattern solves these:

- **Explicit** - Errors are part of the return type, visible in the function signature
- **Type-safe** - TypeScript knows exactly what errors can occur
- **Exhaustive** - You can ensure all error cases are handled at compile time

## Core Types

### Result

A discriminated union of `Ok<A>` (success) or `Err<E>` (failure):

```typescript
type Result<A, E extends ResultError = never> = Ok<A> | Err<E>;
```

### Ok

Contains the success value:

```typescript
interface Ok<A> {
  readonly _tag: "Ok";
  readonly value: A;
}
```

### Err

Contains the error:

```typescript
interface Err<E extends ResultError> {
  readonly _tag: "Err";
  readonly error: E;
}
```

## Error Requirements

Errors must extend JavaScript's `Error` class and have a `_tag` property with a string literal type. This enables exhaustive pattern matching:

```typescript
class NotFoundError extends Error {
  readonly _tag = "NotFoundError" as const;
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
    this.name = "NotFoundError";
  }
}

class ValidationError extends Error {
  readonly _tag = "ValidationError" as const;
  constructor(public readonly field: string, message: string) {
    super(message);
    this.name = "ValidationError";
  }
}
```

### TaggedError Base Class

For convenience, extend `TaggedError` which automatically sets `name` from `_tag`:

```typescript
import { TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
  }
}
// error.name automatically returns "NotFoundError"
```

## Basic Usage

### Creating Results

```typescript
import { ok, err } from "@alt-stack/result";

// Success with value
const success = ok({ id: "123", name: "Alice" });

// Success without value (void)
const voidSuccess = ok();

// Error
const failure = err(new NotFoundError("123"));
```

### Checking Results

```typescript
import { isOk, isErr } from "@alt-stack/result";

if (isOk(result)) {
  console.log(result.value);
}

if (isErr(result)) {
  console.log(result.error._tag, result.error.message);
}
```

### Exhaustive Error Handling

The `_tag` property enables TypeScript to verify all error cases are handled:

```typescript
type GetUserError = NotFoundError | ValidationError | DatabaseError;

function handleError(result: Result<User, GetUserError>) {
  if (isErr(result)) {
    switch (result.error._tag) {
      case "NotFoundError":
        console.log(`User ${result.error.id} not found`);
        break;
      case "ValidationError":
        console.log(`Invalid field: ${result.error.field}`);
        break;
      case "DatabaseError":
        console.log(`Database error: ${result.error.message}`);
        break;
      // TypeScript ensures all cases are handled
    }
  }
}
```

## Complete Example

```typescript
import {
  ok,
  err,
  isOk,
  isErr,
  map,
  match,
  TaggedError,
  type Result,
} from "@alt-stack/result";

// Define errors
class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly userId: string) {
    super(`User ${userId} not found`);
  }
}

class InactiveError extends TaggedError {
  readonly _tag = "InactiveError";
  constructor(public readonly userId: string) {
    super(`User ${userId} is inactive`);
  }
}

// Define types
interface User {
  id: string;
  name: string;
  active: boolean;
}

// Function returning Result
function getActiveUser(
  id: string
): Result<User, NotFoundError | InactiveError> {
  const user = db.find(id);

  if (!user) {
    return err(new NotFoundError(id));
  }

  if (!user.active) {
    return err(new InactiveError(id));
  }

  return ok(user);
}

// Using the result
const result = getActiveUser("123");

const message = match(result, {
  ok: (user) => `Welcome, ${user.name}!`,
  err: (error) => {
    switch (error._tag) {
      case "NotFoundError":
        return `User ${error.userId} does not exist`;
      case "InactiveError":
        return `User ${error.userId} is deactivated`;
    }
  },
});
```

## Framework Integration

The Result type is used throughout Altstack:

- **Server** - Route handlers return Results with HTTP status codes
- **Kafka** - Message handlers return Results with error codes
- **Workers** - Job handlers return Results with error codes

Each framework re-exports the Result utilities, but you can also import directly from `@alt-stack/result` for standalone use.

## Next Steps

- [Constructors](./constructors) - Creating `ok()` and `err()` values
- [Type Guards](./type-guards) - `isOk()` and `isErr()` for narrowing
- [Transformations](./transformations) - `map()`, `flatMap()`, `mapError()`
- [Extraction](./extraction) - `unwrap()`, `unwrapOr()`, `getOrUndefined()`
- [Pattern Matching](./pattern-matching) - `match()` and `fold()`
- [Async Utilities](./async) - `fromPromise()`, `tryCatch()`, `tryCatchAsync()`
- [Combinators](./combinators) - `all()`, `firstOk()`, `tap()`
- [Type Inference](./type-inference) - `InferErrorTag`, `NarrowError`

---

// File: result/pattern-matching

# Pattern Matching

Handle both success and error cases with `match()` and `fold()`.

## match()

Handle both `Ok` and `Err` cases with an object of handlers:

```typescript
import { ok, err, match, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
  }
}

const result = ok({ id: "123", name: "Alice" });

const message = match(result, {
  ok: (user) => `Welcome, ${user.name}!`,
  err: (error) => `Error: ${error.message}`,
});
// "Welcome, Alice!"
```

### Type Signature

```typescript
function match<A, E extends ResultError, B, C>(
  result: Result<A, E>,
  handlers: {
    ok: (value: A) => B;
    err: (error: E) => C;
  }
): B | C;
```

### Examples

**Returning different types:**

```typescript
const response = match(getUserResult, {
  ok: (user) => ({ status: 200, body: user }),
  err: (error) => ({ status: 404, body: { error: error.message } }),
});
```

**Side effects:**

```typescript
match(result, {
  ok: (value) => {
    console.log("Success:", value);
    analytics.track("success");
  },
  err: (error) => {
    console.error("Error:", error);
    analytics.track("error", { type: error._tag });
  },
});
```

**Exhaustive error handling within match:**

```typescript
type UserError = NotFoundError | ValidationError | DatabaseError;

const message = match(result as Result<User, UserError>, {
  ok: (user) => `User: ${user.name}`,
  err: (error) => {
    switch (error._tag) {
      case "NotFoundError":
        return `User ${error.id} not found`;
      case "ValidationError":
        return `Invalid: ${error.field}`;
      case "DatabaseError":
        return `Database error: ${error.message}`;
    }
  },
});
```

## fold()

Reduce a Result to a single value with separate handlers:

```typescript
import { ok, err, fold } from "@alt-stack/result";

const result = ok(42);

const doubled = fold(
  result,
  (error) => 0,        // Error handler (first)
  (value) => value * 2 // Success handler (second)
);
// 84
```

### Type Signature

```typescript
function fold<A, E extends ResultError, B>(
  result: Result<A, E>,
  onErr: (error: E) => B,
  onOk: (value: A) => B
): B;
```

### Behavior

- Both handlers must return the same type
- Error handler is the first argument (matches the conventional `Either` "left" position)
- Success handler is the second argument

### Examples

**Converting to nullable:**

```typescript
const maybeUser = fold(
  getUserResult,
  () => null,
  (user) => user
);
// User | null
```

**Computing derived values:**

```typescript
const status = fold(
  operationResult,
  (error) => ({ success: false, error: error.message }),
  (value) => ({ success: true, data: value })
);
```

**Metrics:**

```typescript
const metricValue = fold(
  result,
  (error) => {
    metrics.increment("errors");
    return 0;
  },
  (value) => {
    metrics.increment("successes");
    return value.count;
  }
);
```

## match vs fold

Both functions handle success and error cases, but differ in syntax:

**match** - Object with named handlers:

```typescript
match(result, {
  ok: (value) => handleSuccess(value),
  err: (error) => handleError(error),
});
```

**fold** - Positional arguments (error first, then success):

```typescript
fold(
  result,
  (error) => handleError(error),
  (value) => handleSuccess(value)
);
```

### When to Use Each

**Use `match` when:**
- You want explicit, named cases for readability
- The handlers are complex or multi-line
- You're working with a team unfamiliar with functional patterns

**Use `fold` when:**
- You prefer the traditional Either/Result convention
- You're doing quick transformations
- You're chaining with other functional utilities

## Comparison with Type Guards

Type guards (`isOk`, `isErr`) and pattern matching serve different purposes:

**Type guards** - Conditional flow with side effects:

```typescript
if (isOk(result)) {
  doSomething(result.value);
  doSomethingElse();
  return result.value;
}
handleError(result.error);
```

**Pattern matching** - Expression-based transformations:

```typescript
const transformed = match(result, {
  ok: (value) => transform(value),
  err: (error) => defaultValue,
});
```

## Real-World Examples

**API Response:**

```typescript
function handleApiResult(result: Result<User, ApiError>): Response {
  return match(result, {
    ok: (user) =>
      new Response(JSON.stringify(user), {
        status: 200,
        headers: { "Content-Type": "application/json" },
      }),
    err: (error) =>
      new Response(JSON.stringify({ error: error.message }), {
        status: error._tag === "NotFoundError" ? 404 : 500,
        headers: { "Content-Type": "application/json" },
      }),
  });
}
```

**React Rendering:**

```typescript
function UserProfile({ userResult }: { userResult: Result<User, UserError> }) {
  return match(userResult, {
    ok: (user) => (
      <div>
        <h1>{user.name}</h1>
        <p>{user.email}</p>
      </div>
    ),
    err: (error) => (
      <div className="error">
        <p>Failed to load user: {error.message}</p>
      </div>
    ),
  });
}
```

**Logging:**

```typescript
fold(
  operationResult,
  (error) => {
    logger.error("Operation failed", { error: error._tag, message: error.message });
    return { logged: true, success: false };
  },
  (value) => {
    logger.info("Operation succeeded", { value });
    return { logged: true, success: true };
  }
);
```

---

// File: result/transformations

# Transformations

Transform Result values with `map()`, `flatMap()`, `mapError()`, and `catchError()`.

## map()

Transform the success value without changing the error type:

```typescript
import { ok, err, map } from "@alt-stack/result";

const result = ok({ id: "123", name: "Alice" });

const nameResult = map(result, (user) => user.name);
// Result<string, never>

if (isOk(nameResult)) {
  console.log(nameResult.value); // "Alice"
}
```

### Type Signature

```typescript
function map<A, E extends ResultError, B>(
  result: Result<A, E>,
  fn: (value: A) => B
): Result<B, E>;
```

### Behavior

- If `Ok`, applies the function and returns a new `Ok` with the result
- If `Err`, returns the same error unchanged

```typescript
// Ok case: function is applied
map(ok(5), (x) => x * 2); // ok(10)

// Err case: function is NOT applied
map(err(new MyError()), (x) => x * 2); // err(MyError)
```

## flatMap()

Chain operations that return Results (monadic bind):

```typescript
import { ok, err, flatMap, type Result, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(message: string) {
    super(message);
  }
}

class InactiveError extends TaggedError {
  readonly _tag = "InactiveError";
  constructor(message: string) {
    super(message);
  }
}

function getUser(id: string): Result<User, NotFoundError> {
  const user = db.find(id);
  return user ? ok(user) : err(new NotFoundError(`User ${id} not found`));
}

function validateActive(user: User): Result<User, InactiveError> {
  return user.active
    ? ok(user)
    : err(new InactiveError(`User ${user.id} is inactive`));
}

// Chain the operations
const result = flatMap(getUser("123"), validateActive);
// Result<User, NotFoundError | InactiveError>
```

### Type Signature

```typescript
function flatMap<A, E extends ResultError, B, E2 extends ResultError>(
  result: Result<A, E>,
  fn: (value: A) => Result<B, E2>
): Result<B, E | E2>;
```

### Behavior

- If `Ok`, applies the function and returns its result (which is itself a Result)
- If `Err`, returns the same error unchanged
- Error types are accumulated in a union

```typescript
// Ok case: function is applied, returns new Result
flatMap(ok(5), (x) => (x > 0 ? ok(x * 2) : err(new NegativeError())));

// Err case: function is NOT applied
flatMap(err(new MyError()), (x) => ok(x * 2)); // err(MyError)
```

### Chaining Multiple Operations

```typescript
const result = flatMap(getUser("123"), (user) =>
  flatMap(validateActive(user), (activeUser) =>
    flatMap(getProfile(activeUser.profileId), (profile) =>
      ok({ user: activeUser, profile })
    )
  )
);
// Result<{ user: User; profile: Profile }, NotFoundError | InactiveError | ProfileError>
```

## mapError()

Transform the error value without changing the success type:

```typescript
import { err, mapError, TaggedError } from "@alt-stack/result";

class InternalError extends TaggedError {
  readonly _tag = "InternalError";
  constructor(public readonly originalError: Error) {
    super("An internal error occurred");
  }
}

const result = err(new NotFoundError("123"));

const mapped = mapError(result, (error) => new InternalError(error));
// Result<never, InternalError>
```

### Type Signature

```typescript
function mapError<A, E extends ResultError, E2 extends ResultError>(
  result: Result<A, E>,
  fn: (error: E) => E2
): Result<A, E2>;
```

### Behavior

- If `Ok`, returns the same success unchanged
- If `Err`, applies the function and returns a new `Err` with the result

```typescript
// Err case: function is applied
mapError(err(new NotFoundError("x")), (e) => new WrappedError(e));

// Ok case: function is NOT applied
mapError(ok(5), (e) => new WrappedError(e)); // ok(5)
```

### Use Cases

**Wrapping errors:**

```typescript
const result = mapError(
  externalApiCall(),
  (error) => new ApiError(`External API failed: ${error.message}`)
);
```

**Adding context:**

```typescript
const result = mapError(getUser(id), (error) => ({
  ...error,
  context: { userId: id, timestamp: Date.now() },
}));
```

## catchError()

Recover from errors by providing a fallback:

```typescript
import { err, catchError, ok, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Not found: ${id}`);
  }
}

const result = err(new NotFoundError("123"));

const recovered = catchError(result, (error) => {
  if (error._tag === "NotFoundError") {
    return ok({ id: error.id, name: "Default User", isDefault: true });
  }
  return err(error); // Re-throw other errors
});
```

### Type Signature

```typescript
function catchError<A, E extends ResultError, B, E2 extends ResultError>(
  result: Result<A, E>,
  fn: (error: E) => Result<B, E2>
): Result<A | B, E2>;
```

### Behavior

- If `Ok`, returns the same success unchanged
- If `Err`, applies the function which can return either `Ok` (recovery) or `Err` (different error)

### Use Cases

**Provide default values:**

```typescript
const userResult = catchError(getUser(id), () =>
  ok({ id: "guest", name: "Guest User" })
);
```

**Handle specific errors:**

```typescript
const result = catchError(fetchData(), (error) => {
  switch (error._tag) {
    case "NotFoundError":
      return ok([]); // Return empty array for not found
    case "NetworkError":
      return ok(cachedData); // Use cache on network error
    default:
      return err(error); // Propagate other errors
  }
});
```

**Transform to different error:**

```typescript
const result = catchError(parseJson(input), (error) =>
  err(new ValidationError(`Invalid JSON: ${error.message}`))
);
```

## Combining Transformations

Transformations can be combined for complex workflows:

```typescript
import { map, flatMap, mapError, catchError } from "@alt-stack/result";

const result = flatMap(getUser(id), (user) =>
  map(
    catchError(
      getProfile(user.profileId),
      () => ok({ bio: "No bio available" }) // Default profile
    ),
    (profile) => ({ ...user, profile })
  )
);
```

## Comparison

| Function | Input | Output | Use When |
|----------|-------|--------|----------|
| `map` | `A => B` | Same error type | Transforming success values |
| `flatMap` | `A => Result<B, E2>` | Accumulated errors | Chaining Result-returning functions |
| `mapError` | `E => E2` | Same success type | Transforming or wrapping errors |
| `catchError` | `E => Result<B, E2>` | Success type union | Recovering from errors |

---

// File: result/type-guards

# Type Guards

Narrow Result types with `isOk()` and `isErr()`.

## isOk()

Type guard that narrows a Result to its `Ok` variant:

```typescript
import { ok, err, isOk } from "@alt-stack/result";

const result = ok({ id: "123", name: "Alice" });

if (isOk(result)) {
  // TypeScript knows result is Ok<{ id: string; name: string }>
  console.log(result.value.name); // "Alice"
}
```

### Type Signature

```typescript
function isOk<A, E extends ResultError>(result: Result<A, E>): result is Ok<A>;
```

## isErr()

Type guard that narrows a Result to its `Err` variant:

```typescript
import { err, isErr, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
  }
}

const result = err(new NotFoundError("123"));

if (isErr(result)) {
  // TypeScript knows result is Err<NotFoundError>
  console.log(result.error._tag); // "NotFoundError"
  console.log(result.error.id); // "123"
}
```

### Type Signature

```typescript
function isErr<A, E extends ResultError>(result: Result<A, E>): result is Err<E>;
```

## Basic Pattern

The standard pattern for handling Results:

```typescript
import { isOk, isErr, type Result } from "@alt-stack/result";

function handleResult(result: Result<User, NotFoundError>) {
  if (isOk(result)) {
    console.log("User:", result.value.name);
    return;
  }

  // TypeScript knows this is the error case
  console.log("Error:", result.error.message);
}
```

Or using `isErr` first:

```typescript
function handleResult(result: Result<User, NotFoundError>) {
  if (isErr(result)) {
    console.log("Error:", result.error.message);
    return;
  }

  // TypeScript knows this is the success case
  console.log("User:", result.value.name);
}
```

## Exhaustive Error Handling

The `_tag` property enables exhaustive `switch` statements:

```typescript
import { isErr, type Result, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Resource ${id} not found`);
  }
}

class ValidationError extends TaggedError {
  readonly _tag = "ValidationError";
  constructor(public readonly field: string) {
    super(`Invalid field: ${field}`);
  }
}

class DatabaseError extends TaggedError {
  readonly _tag = "DatabaseError";
  constructor(message: string) {
    super(message);
  }
}

type UserError = NotFoundError | ValidationError | DatabaseError;

function handleUserResult(result: Result<User, UserError>) {
  if (isErr(result)) {
    switch (result.error._tag) {
      case "NotFoundError":
        // TypeScript narrows to NotFoundError
        console.log(`User ${result.error.id} not found`);
        break;
      case "ValidationError":
        // TypeScript narrows to ValidationError
        console.log(`Invalid field: ${result.error.field}`);
        break;
      case "DatabaseError":
        // TypeScript narrows to DatabaseError
        console.log(`Database error: ${result.error.message}`);
        break;
    }
    return;
  }

  console.log("User:", result.value.name);
}
```

### Compile-Time Exhaustiveness

Add a `default` case to ensure all errors are handled:

```typescript
if (isErr(result)) {
  switch (result.error._tag) {
    case "NotFoundError":
      return "Not found";
    case "ValidationError":
      return "Invalid input";
    case "DatabaseError":
      return "Database error";
    default:
      // TypeScript error if any case is missing
      const _exhaustive: never = result.error;
      throw new Error(`Unhandled error: ${_exhaustive}`);
  }
}
```

If you add a new error type but forget to handle it, TypeScript will report an error at compile time.

## Early Return Pattern

A common pattern is to handle errors first with early returns:

```typescript
async function processUser(id: string): Promise<string> {
  const userResult = await getUser(id);

  if (isErr(userResult)) {
    return `Error: ${userResult.error.message}`;
  }

  const user = userResult.value;

  const profileResult = await getProfile(user.profileId);

  if (isErr(profileResult)) {
    return `Error: ${profileResult.error.message}`;
  }

  const profile = profileResult.value;

  return `${user.name} - ${profile.bio}`;
}
```

## Combining with Transformations

Type guards work well with other Result utilities:

```typescript
import { isOk, map, flatMap } from "@alt-stack/result";

const result = getUser("123");

// Check first
if (isOk(result)) {
  const nameResult = map(result, (user) => user.name);
  // Safe to use
}

// Or use transformations directly
const nameResult = map(
  result,
  (user) => user.name
);

if (isOk(nameResult)) {
  console.log(nameResult.value);
}
```

## Type Inference

The guards preserve full type information:

```typescript
type MyResult = Result<
  { id: string; data: number[] },
  NotFoundError | ValidationError
>;

function process(result: MyResult) {
  if (isOk(result)) {
    // result.value is { id: string; data: number[] }
    const sum = result.value.data.reduce((a, b) => a + b, 0);
  }

  if (isErr(result)) {
    // result.error is NotFoundError | ValidationError
    // Can switch on _tag to narrow further
  }
}
```

---

// File: result/type-inference

# Type Inference

Extract and narrow error types with `InferErrorTag`, `InferErrorTags`, `NarrowError`, `isResultError()`, and `assertResultError()`.

## InferErrorTag

Extract the `_tag` literal type from a single error class:

```typescript
import { type InferErrorTag, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly id: string) {
    super(`Not found: ${id}`);
  }
}

type Tag = InferErrorTag<NotFoundError>;
// "NotFoundError"
```

### Type Signature

```typescript
type InferErrorTag<E extends ResultError> = E["_tag"];
```

### Use Cases

**Type-safe error codes:**

```typescript
function logError<E extends ResultError>(error: E) {
  const tag: InferErrorTag<E> = error._tag;
  logger.error(`Error [${tag}]: ${error.message}`);
}
```

**Generic error handlers:**

```typescript
function createErrorHandler<E extends ResultError>() {
  return (error: E): { code: InferErrorTag<E>; message: string } => ({
    code: error._tag,
    message: error.message,
  });
}
```

## InferErrorTags

Extract all `_tag` values from a union of error types:

```typescript
import { type InferErrorTags, TaggedError } from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(message: string) {
    super(message);
  }
}

class ValidationError extends TaggedError {
  readonly _tag = "ValidationError";
  constructor(message: string) {
    super(message);
  }
}

class DatabaseError extends TaggedError {
  readonly _tag = "DatabaseError";
  constructor(message: string) {
    super(message);
  }
}

type AllErrors = NotFoundError | ValidationError | DatabaseError;
type AllTags = InferErrorTags<AllErrors>;
// "NotFoundError" | "ValidationError" | "DatabaseError"
```

### Type Signature

```typescript
type InferErrorTags<E extends ResultError> = E extends ResultError
  ? E["_tag"]
  : never;
```

### Use Cases

**Exhaustive type checking:**

```typescript
function handleAllErrors(tag: InferErrorTags<AllErrors>) {
  switch (tag) {
    case "NotFoundError":
      return 404;
    case "ValidationError":
      return 400;
    case "DatabaseError":
      return 500;
  }
}
```

**Error code constants:**

```typescript
const ERROR_CODES: Record<InferErrorTags<AllErrors>, number> = {
  NotFoundError: 404,
  ValidationError: 400,
  DatabaseError: 500,
};
```

## NarrowError

Narrow an error union to a specific error type by its `_tag`:

```typescript
import { type NarrowError, TaggedError } from "@alt-stack/result";

type AllErrors = NotFoundError | ValidationError | DatabaseError;

type OnlyNotFound = NarrowError<AllErrors, "NotFoundError">;
// NotFoundError

type OnlyValidation = NarrowError<AllErrors, "ValidationError">;
// ValidationError
```

### Type Signature

```typescript
type NarrowError<E extends ResultError, Tag extends string> = Extract<
  E,
  { _tag: Tag }
>;
```

### Use Cases

**Specific error handlers:**

```typescript
function handleNotFound(error: NarrowError<AllErrors, "NotFoundError">) {
  // error is typed as NotFoundError
  console.log(`Resource ${error.id} not found`);
}
```

**Conditional error handling:**

```typescript
function handleError<E extends AllErrors>(error: E) {
  if (error._tag === "NotFoundError") {
    // TypeScript narrows to NotFoundError
    const notFound: NarrowError<E, "NotFoundError"> = error;
    return { status: 404, id: notFound.id };
  }
  // Handle other errors...
}
```

## isResultError()

Runtime check if a value satisfies the `ResultError` type:

```typescript
import { isResultError, TaggedError } from "@alt-stack/result";

class MyError extends TaggedError {
  readonly _tag = "MyError";
  constructor(message: string) {
    super(message);
  }
}

const error = new MyError("Something went wrong");
const plainError = new Error("Plain error");

isResultError(error);      // true
isResultError(plainError); // false (no _tag)
isResultError("string");   // false (not an Error)
isResultError(null);       // false
```

### Type Signature

```typescript
function isResultError(error: unknown): error is ResultError;
```

### Use Cases

**Catching and wrapping:**

```typescript
try {
  await riskyOperation();
} catch (error) {
  if (isResultError(error)) {
    // error has _tag, safe to use with Result
    return err(error);
  }
  // Wrap unknown errors
  return err(new UnknownError(error));
}
```

**Type narrowing in generic code:**

```typescript
function processError(error: unknown) {
  if (isResultError(error)) {
    // TypeScript knows error is ResultError
    console.log(`Tagged error: ${error._tag}`);
    return error;
  }

  if (error instanceof Error) {
    return new WrappedError(error);
  }

  return new UnknownError(String(error));
}
```

## assertResultError()

Runtime assertion that throws if the value is not a `ResultError`:

```typescript
import { assertResultError, TaggedError } from "@alt-stack/result";

class MyError extends TaggedError {
  readonly _tag = "MyError";
  constructor(message: string) {
    super(message);
  }
}

const error = new MyError("test");
assertResultError(error);
// error is now typed as ResultError

const plainError = new Error("plain");
assertResultError(plainError);
// Throws: "Expected a ResultError with a _tag property, got: Error"
```

### Type Signature

```typescript
function assertResultError(error: unknown): asserts error is ResultError;
```

### Use Cases

**Validating error types:**

```typescript
function ensureResultError(error: unknown): ResultError {
  assertResultError(error);
  return error;
}
```

**Test assertions:**

```typescript
test("should return a ResultError", () => {
  const result = err(new NotFoundError("123"));
  if (isErr(result)) {
    assertResultError(result.error);
    expect(result.error._tag).toBe("NotFoundError");
  }
});
```

**Runtime validation:**

```typescript
async function handleThrown(thrown: unknown): Promise<ResultError> {
  try {
    assertResultError(thrown);
    return thrown;
  } catch {
    return new UnknownError(thrown);
  }
}
```

## Combining Type Utilities

```typescript
import {
  type Result,
  type InferErrorTags,
  type NarrowError,
  isErr,
  TaggedError,
} from "@alt-stack/result";

class NotFoundError extends TaggedError {
  readonly _tag = "NotFoundError";
  constructor(public readonly resourceId: string) {
    super(`Resource ${resourceId} not found`);
  }
}

class PermissionError extends TaggedError {
  readonly _tag = "PermissionError";
  constructor(public readonly action: string) {
    super(`Not allowed: ${action}`);
  }
}

type ApiError = NotFoundError | PermissionError;

// Get all possible error tags
type ApiErrorTags = InferErrorTags<ApiError>;
// "NotFoundError" | "PermissionError"

// Create handlers for specific errors
function handleApiError(error: ApiError): Response {
  switch (error._tag) {
    case "NotFoundError": {
      const notFound = error as NarrowError<ApiError, "NotFoundError">;
      return new Response(`Not found: ${notFound.resourceId}`, { status: 404 });
    }
    case "PermissionError": {
      const permission = error as NarrowError<ApiError, "PermissionError">;
      return new Response(`Forbidden: ${permission.action}`, { status: 403 });
    }
  }
}

// Use in result handling
function handleResult(result: Result<Data, ApiError>): Response {
  if (isErr(result)) {
    return handleApiError(result.error);
  }
  return new Response(JSON.stringify(result.value), { status: 200 });
}
```

## Summary

| Type/Function | Purpose |
|---------------|---------|
| `InferErrorTag<E>` | Get single error's `_tag` literal type |
| `InferErrorTags<E>` | Get union of all `_tag` values from error union |
| `NarrowError<E, Tag>` | Extract specific error type from union by tag |
| `isResultError(e)` | Runtime check if value is a `ResultError` |
| `assertResultError(e)` | Runtime assertion (throws if not `ResultError`) |

---

// File: workers-warpstream/core-concepts/custom-context

# Custom Context

Inject dependencies into job handlers.

## Define Context Type

```typescript
import { init } from "@alt-stack/workers-warpstream";

interface AppContext {
  db: Database;
  logger: Logger;
}

const { router, procedure } = init<AppContext>();

const jobRouter = router({
  "sync-user": procedure
    .input({ payload: z.object({ userId: z.string() }) })
    .task(async ({ input, ctx }) => {
      // Access injected dependencies
      ctx.logger.info(`Syncing user ${input.userId}`);
      const user = await ctx.db.users.find(input.userId);
      // ...
    }),
});
```

## Create Context

```typescript
import { createWorker } from "@alt-stack/workers-warpstream";

const worker = await createWorker(jobRouter, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  createContext: async (baseCtx) => {
    // baseCtx contains: jobId, jobName, attempt, topic, partition, offset, message
    return {
      db: getDatabase(),
      logger: createLogger({ jobId: baseCtx.jobId }),
    };
  },
});
```

## Base Context

Every job handler receives these built-in fields:

```typescript
interface WarpStreamContext {
  jobId: string;      // Unique execution ID
  jobName: string;    // Name of the job
  attempt: number;    // Retry attempt (starts at 1)
  topic: string;      // Kafka topic
  partition: number;  // Kafka partition
  offset: string;     // Message offset
  message: KafkaMessage;  // Raw Kafka message
}
```

---

// File: workers-warpstream/core-concepts/error-handling

# Error Handling

Handle job failures with the Result pattern.

For comprehensive documentation on the Result type, see the [Result documentation](/result).

## Result Pattern

Handlers return `Result<Errors, Output>`:

```typescript
import { init, ok, err } from "@alt-stack/workers-trigger";

const { router, procedure } = init();

const jobRouter = router({
  "process-payment": procedure
    .input({ payload: z.object({ orderId: z.string() }) })
    .errors({
      INSUFFICIENT_FUNDS: z.object({
        code: z.literal("INSUFFICIENT_FUNDS"),
        balance: z.number(),
      }),
      CARD_DECLINED: z.object({
        code: z.literal("CARD_DECLINED"),
        reason: z.string(),
      }),
    })
    .task(async ({ input }) => {
      const balance = await getBalance();
      if (balance < 0) {
        return err({
          data: {
            code: "INSUFFICIENT_FUNDS" as const,
            balance,
          },
        });
      }

      await processPayment(input.orderId);
      return ok();
    }),
});
```

## Error Callback

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  onError: async (error, ctx) => {
    console.error(`Job ${ctx.jobName} failed:`, error);

    // Send to error tracking
    await sentry.captureException(error, {
      extra: {
        jobId: ctx.jobId,
        jobName: ctx.jobName,
        attempt: ctx.attempt,
      },
    });
  },
});
```

## Success Returns

Use `ok()` for all successful returns:

```typescript
// Return data
return ok({ orderId: "123", status: "processed" });

// Void return
return ok();
```

## Retries

Kafka consumer retries are handled at the Kafka level. Configure dead letter queues in your Kafka setup for failed messages.

## See Also

- [Result Documentation](/result) - Complete guide to the Result type

---

// File: workers-warpstream/core-concepts/job-client

# Job Client

Type-safe producer for enqueuing jobs.

## Basic Usage

```typescript
import { createJobClient } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

const client = await createJobClient(jobRouter, {
  kafka: { brokers: ["warpstream.example.com:9092"] },
});

// Fully typed - invalid job names or payloads are compile errors
await client.enqueue("send-email", {
  to: "user@example.com",
  subject: "Hello",
  body: "World",
});

await client.disconnect();
```

## Options

```typescript
const client = await createJobClient(router, {
  // Kafka connection
  kafka: { brokers: ["localhost:9092"] },
  
  // Or pass an existing Kafka instance
  kafka: existingKafkaInstance,
  
  // Routing strategy (must match consumer)
  routing: { type: "topic-per-job" },
  
  // Client ID
  clientId: "my-producer",
  
  // Error callback
  onError: (error) => console.error(error),
});
```

## Partition Keys

Route related jobs to the same partition:

```typescript
await client.enqueue(
  "process-order",
  { orderId: "123", items: [...] },
  { key: "user-456" }  // All jobs for this user go to same partition
);
```

## Custom Headers

```typescript
await client.enqueue(
  "send-notification",
  { userId: "123", message: "Hello" },
  { headers: { "x-priority": "high", "x-source": "api" } }
);
```

---

// File: workers-warpstream/core-concepts/middleware

# Middleware

Add cross-cutting logic to job handlers.

## Basic Middleware

```typescript
const { router, procedure } = init<AppContext>();

const loggedProcedure = procedure.use(async ({ ctx, next }) => {
  console.log(`Starting job: ${ctx.jobName}`);
  const start = Date.now();
  
  const result = await next();
  
  console.log(`Completed in ${Date.now() - start}ms`);
  return result;
});

const jobRouter = router({
  "my-job": loggedProcedure
    .input({ payload: z.object({ id: z.string() }) })
    .task(async ({ input }) => {
      // Logging happens automatically
    }),
});
```

## Extend Context

```typescript
const withMetrics = procedure.use(async ({ ctx, next }) => {
  return next({
    ctx: {
      metrics: new MetricsClient(),
    },
  });
});

// Now ctx.metrics is available in handlers
const jobRouter = router({
  "tracked-job": withMetrics
    .input({ payload: z.object({ id: z.string() }) })
    .task(async ({ ctx }) => {
      ctx.metrics.increment("jobs.processed");
    }),
});
```

## Chain Middleware

```typescript
const authedProcedure = procedure
  .use(loggingMiddleware)
  .use(metricsMiddleware)
  .use(rateLimitMiddleware);
```

---

// File: workers-warpstream/core-concepts/routing-strategies

# Routing Strategies

Two strategies for routing jobs through Kafka.

## Topic-per-Job (Default)

Each job name becomes a Kafka topic:

```
job "send-email"     → topic "send-email"
job "process-image"  → topic "process-image"
```

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing: { type: "topic-per-job" },
});
```

With a prefix:

```typescript
routing: { type: "topic-per-job", topicPrefix: "jobs." }
// job "send-email" → topic "jobs.send-email"
```

## Single-Queue

All jobs go to one topic with an envelope:

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing: { type: "single-queue", topic: "job-queue" },
});
```

Messages are wrapped:

```json
{ "jobName": "send-email", "payload": { "to": "user@example.com", ... } }
```

## Matching Producer and Consumer

Use the same routing strategy for both:

```typescript
const routing = { type: "single-queue", topic: "jobs" } as const;

// Consumer
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing,
});

// Producer
const client = await createJobClient(router, {
  kafka: { brokers: ["localhost:9092"] },
  routing,
});
```

---

// File: workers-warpstream/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/workers-warpstream kafkajs zod
```

## Peer Dependencies

- **kafkajs**: `^2.0.0` - Kafka client
- **zod**: `^3.25.0 || ^4.0.0` - Schema validation

---

// File: workers-warpstream/getting-started/quickstart

# Quickstart

Build async job queues using WarpStream/Kafka with type-safe producers and consumers.

## Define Jobs

```typescript
import { init } from "@alt-stack/workers-warpstream";
import { z } from "zod";

const { router, procedure } = init();

const jobRouter = router({
  "send-email": procedure
    .input({
      payload: z.object({
        to: z.string().email(),
        subject: z.string(),
        body: z.string(),
      }),
    })
    .task(async ({ input, ctx }) => {
      console.log(`Sending email to ${input.to}`);
      // Send email logic here
    }),

  "process-image": procedure
    .input({
      payload: z.object({
        imageUrl: z.string().url(),
        operations: z.array(z.enum(["resize", "crop", "compress"])),
      }),
    })
    .task(async ({ input }) => {
      console.log(`Processing image: ${input.imageUrl}`);
    }),
});

export { jobRouter };
```

## Start Worker

```typescript
import { createWorker } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

async function main() {
  const worker = await createWorker(jobRouter, {
    kafka: { brokers: ["warpstream.example.com:9092"] },
    groupId: "job-workers",
  });

  console.log("Worker running, waiting for jobs...");

  // Graceful shutdown
  process.on("SIGINT", async () => {
    await worker.disconnect();
    process.exit(0);
  });

  // Block until shutdown
  await new Promise(() => {});
}

main();
```

## Enqueue Jobs

```typescript
import { createJobClient } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

const client = await createJobClient(jobRouter, {
  kafka: { brokers: ["warpstream.example.com:9092"] },
});

// Type-safe: only valid job names and payloads allowed
await client.enqueue("send-email", {
  to: "user@example.com",
  subject: "Welcome!",
  body: "Thanks for signing up.",
});

await client.enqueue("process-image", {
  imageUrl: "https://example.com/image.jpg",
  operations: ["resize", "compress"],
});
```

---

// File: workers-warpstream/guides/sdk-generation

# SDK Generation

Generate a type-safe SDK from your worker definitions to trigger jobs without importing router code.

## Overview

The SDK generation workflow:

1. Define workers with `workerRouter`
2. Generate AsyncAPI spec from the router
3. Generate TypeScript SDK from the spec
4. Use the SDK with worker clients

This allows services to trigger workers without depending on the worker implementation code.

## Generate AsyncAPI Spec

```typescript
// generate-spec.ts
import { generateAsyncAPISpec } from "@alt-stack/workers-core";
import { appRouter } from "./routers";
import { writeFileSync } from "node:fs";

const spec = generateAsyncAPISpec(appRouter, {
  title: "Workers API",
  version: "1.0.0",
  description: "Background job definitions",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

Run it:

```bash
npx tsx generate-spec.ts
```

:::note
Only `task` and `queue` procedures are included in the spec. Cron jobs are excluded since they don't accept external payloads.
:::

## Generate TypeScript SDK

Use the `asyncapi-to-zod` CLI to generate Zod schemas:

```bash
npx asyncapi-to-zod asyncapi.json -o ./sdk/index.ts
```

This generates:

```typescript
// sdk/index.ts (auto-generated)
import { z } from 'zod';

export const SendWelcomeEmailPayloadSchema = z.object({
  userId: z.string(),
  email: z.string().email(),
});
export type SendWelcomeEmailPayload = z.infer<typeof SendWelcomeEmailPayloadSchema>;

export const ProcessImagePayloadSchema = z.object({
  imageUrl: z.string().url(),
});
export type ProcessImagePayload = z.infer<typeof ProcessImagePayloadSchema>;

export const Topics = {
  'send-welcome-email': SendWelcomeEmailPayloadSchema,
  'process-image': ProcessImagePayloadSchema,
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Use with Worker Clients

### Trigger.dev Client

```typescript
import { Topics } from "@myorg/workers-sdk";
import { createTriggerClient } from "@alt-stack/workers-client-trigger";

const client = createTriggerClient({ jobs: Topics });

// Type-safe: autocomplete for job names and payloads
await client.trigger("send-welcome-email", {
  userId: "user-123",
  email: "user@example.com",
});

// With options
await client.trigger("send-welcome-email", payload, {
  idempotencyKey: "unique-123",
  delay: "PT5M", // 5 minute delay
});
```

### WarpStream Client

```typescript
import { Topics } from "@myorg/workers-sdk";
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "cluster.warpstream.com:9092",
  jobs: Topics,
});

await client.trigger("send-welcome-email", {
  userId: "user-123",
  email: "user@example.com",
});

await client.disconnect();
```

## Batch Triggering

Trigger multiple jobs efficiently:

```typescript
await client.triggerBatch("process-image", [
  { imageUrl: "https://example.com/1.jpg" },
  { imageUrl: "https://example.com/2.jpg" },
  { imageUrl: "https://example.com/3.jpg" },
]);
```

## Publishing the SDK

Create a package for your SDK:

```json
{
  "name": "@myorg/workers-sdk",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "peerDependencies": {
    "zod": "^3.25.0 || ^4.0.0"
  }
}
```

Add a build script:

```json
{
  "scripts": {
    "generate": "tsx generate-spec.ts && asyncapi-to-zod asyncapi.json -o src/index.ts",
    "build": "tsup src/index.ts --format esm,cjs --dts"
  }
}
```

Other services can then install and use your SDK:

```bash
pnpm add @myorg/workers-sdk @alt-stack/workers-client-trigger
```

## Benefits

- **Decoupled**: Services don't need to import worker router code
- **Type-safe**: Full TypeScript support with autocomplete
- **Validated**: Payloads are validated before sending
- **Versioned**: SDK can be versioned independently