// File: client/core-concepts/basic-usage

# Basic Usage

Learn how to use the API client for making type-safe requests.

## Creating a Client

Use `createApiClient` to create a client instance:

```typescript
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
  headers: {
    Authorization: "Bearer token",
  },
});
```

## Making Requests

The client provides methods for different HTTP methods:

### GET Requests

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  query: { include: "profile" },
});
```

### POST Requests

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "alice@example.com",
  },
});
```

### PUT Requests

```typescript
const result = await client.put("/users/{id}", {
  params: { id: "123" },
  body: { name: "Alice Updated", email: "alice@example.com" },
});
```

### PATCH Requests

```typescript
const result = await client.patch("/users/{id}", {
  params: { id: "123" },
  body: { email: "newemail@example.com" },
});
```

### DELETE Requests

```typescript
const result = await client.delete("/users/{id}", {
  params: { id: "123" },
});
```

## Handling Responses

All methods return a result object that can be either a success or error:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // Type-safe access to response body
  console.log(result.body);
  console.log(result.code); // Status code string, e.g., "200"
  console.log(result.raw); // Raw Response object for advanced use
} else {
  // Handle error - check if it's a defined error or unexpected
  if (typeof result.code === "string") {
    // Server returned a defined error response
    console.error(result.code, result.error);
  } else {
    // Unexpected error (network, validation, etc.)
    console.error(result.error);
  }
}
```

## Request Options

You can pass additional options to requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  headers: {
    "X-Custom-Header": "value",
  },
  timeout: 5000, // milliseconds
  retries: 3, // number of retry attempts
  shouldRetry: ({ response }) => response?.status >= 500, // custom retry logic
});
```

| Option | Type | Description |
|--------|------|-------------|
| `params` | `object` | Path parameters to interpolate into the URL |
| `query` | `object` | Query parameters to append to the URL |
| `body` | `object` | Request body (required for POST, PUT, PATCH) |
| `headers` | `object` | Additional headers to include |
| `timeout` | `number` | Request timeout in milliseconds |
| `retries` | `number` | Number of retry attempts |
| `shouldRetry` | `function` | Custom retry logic callback |

See [Error Handling](./error-handling.md#custom-retry-logic) for more details on `shouldRetry`.

---

// File: client/core-concepts/error-handling

# Error Handling

The client provides comprehensive error handling with typed error responses.

## Response Types

Every request returns a result that can be one of three types:

1. **Success Response** - Request succeeded
2. **Error Response** - Server returned an error response
3. **Unexpected Error Response** - Network, validation, or unexpected error

## Success Response

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body);
  // result.code contains the status code (e.g., "200", "201")
}
```

## Error Response

When the server returns an error response (non-2xx status):

```typescript
const result = await client.post("/users", {
  body: { name: "Alice" },
});

if (!result.success && typeof result.code === "string") {
  // Server error response (typed error from Response schemas)
  // result.error is typed based on the error schema for this status code
  console.error(result.code); // HTTP status code (e.g., "404", "500")
  console.error(result.error); // Typed error body based on schema
}
```

## Unexpected Error Response

For network errors, validation errors, or other unexpected issues:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (!result.success && typeof result.code === "number") {
  // Unexpected error response (not defined in Response schemas)
  if (result.error instanceof Error) {
    console.error(result.error.message); // Error message
    // error may be UnexpectedApiClientError with additional properties
  } else {
    console.error("Unexpected error:", result.error);
  }
  console.error(result.code); // HTTP status code as number
}
```

## Error Classes

The client exports error classes for programmatic handling:

| Class | Description |
|-------|-------------|
| `ApiClientError` | Base class for all client errors |
| `ValidationError` | Request/response validation failed |
| `UnexpectedApiClientError` | Network error or unexpected response |
| `TimeoutError` | Request exceeded timeout |

```typescript
import {
  ValidationError,
  UnexpectedApiClientError,
  TimeoutError,
  ApiClientError,
} from "@alt-stack/http-client-fetch";

try {
  await client.get("/users/{id}", {
    params: { id: 123 },
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation error:", error.validationErrors);
  } else if (error instanceof TimeoutError) {
    console.error(`Request timed out after ${error.timeout}ms`);
  } else if (error instanceof UnexpectedApiClientError) {
    console.error("Request failed:", error.message, error.code);
  } else if (error instanceof ApiClientError) {
    console.error("Client error:", error.message);
  }
}
```

## Retry Logic

The client includes built-in retry logic with exponential backoff:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3, // Will retry up to 3 times
});
```

By default, retries are automatically performed for:
- Network errors

Retries are **not** performed by default for:
- Validation errors
- Client errors (4xx status codes)
- Server errors (5xx status codes) - these are valid HTTP responses

### Custom Retry Logic

Use the `shouldRetry` option to customize retry behavior:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3,
  shouldRetry: ({ attempt, error, response }) => {
    // Retry on 5xx server errors
    if (response?.status >= 500) return true;
    // Retry on rate limiting
    if (response?.status === 429) return true;
    // Retry on network errors
    if (error) return true;
    return false;
  },
});
```

The `shouldRetry` callback receives a context object with:
- `attempt` - Current attempt number (0-indexed)
- `error` - Error thrown during request (network errors, timeouts)
- `response` - HTTP response received (status, statusText, data)

#### Examples

**Retry on 5xx server errors:**

```typescript
shouldRetry: ({ response }) => response?.status !== undefined && response.status >= 500
```

**Limit retries regardless of `retries` option:**

```typescript
shouldRetry: ({ attempt }) => attempt < 2
```

**Retry on specific error codes:**

```typescript
shouldRetry: ({ response }) => {
  const retryableCodes = [500, 502, 503, 504, 429];
  return response?.status !== undefined && retryableCodes.includes(response.status);
}
```

**Custom logic combining error and response:**

```typescript
shouldRetry: ({ error, response }) => {
  // Always retry network errors
  if (error) return true;
  // Retry rate limits and server errors
  if (response?.status === 429 || (response?.status ?? 0) >= 500) return true;
  return false;
}
```

## Timeouts

Set a timeout for requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  timeout: 5000, // 5 seconds
});
```

If the request exceeds the timeout, a `TimeoutError` is thrown with the `timeout` property indicating the configured timeout in milliseconds.

---

// File: client/core-concepts/validation

# Validation

The client automatically validates request parameters, query strings, and request bodies using Zod schemas.

## Automatic Validation

When you make a request, the client automatically validates:

1. **Path parameters** - Validated against the `params` schema
2. **Query parameters** - Validated against the `query` schema
3. **Request body** - Validated against the `body` schema
4. **Response data** - Validated against the `output` schema

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "invalid-email", // ❌ This will throw ValidationError
  },
});
```

## Validation Errors

If validation fails, the client throws a `ValidationError`:

```typescript
import { ValidationError } from "@alt-stack/http-client-fetch";

try {
  await client.get("/users/{id}", {
    params: { id: 123 }, // ❌ Should be string
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation failed:", error.message);
    console.error("Validation errors:", error.validationErrors);
  }
}
```

The `ValidationError` includes:
- `message`: Human-readable error message
- `validationErrors`: Validation error details from Zod
- `endpoint`: The endpoint that failed validation
- `method`: The HTTP method that failed validation

## Type Safety

TypeScript ensures you pass the correct types at compile time:

```typescript
// ✅ TypeScript knows this is correct
await client.get("/users/{id}", {
  params: { id: "123" },
});

// ❌ TypeScript error - id must be string
await client.get("/users/{id}", {
  params: { id: 123 },
});
```

## Response Validation

Response data is automatically validated when received:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is validated and typed
  console.log(result.body.name); // ✅ Type-safe
}
```

If the response doesn't match the expected schema, an error is returned in the result.

---

// File: client/getting-started/installation

# Installation

Choose the HTTP client binding that fits your needs:

## Using Native Fetch

```bash
pnpm add @alt-stack/http-client-fetch zod
```

## Using Ky

```bash
pnpm add @alt-stack/http-client-ky zod
```

## Peer Dependencies

- **zod**: `^4.0.0`

## Requirements

1. A server built with `@alt-stack/server-hono` that exposes an OpenAPI spec
2. Generated `Request` and `Response` types from the OpenAPI spec (see [Server Integration](../guides/server-integration))

## Package Comparison

| Package | Description | Best For |
|---------|-------------|----------|
| `@alt-stack/http-client-fetch` | Native fetch API | Simple use cases, browser/Node.js |
| `@alt-stack/http-client-ky` | Ky library | Advanced features like hooks, pre-configured instances |

---

// File: client/getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates how to use the type-safe API client.

## Basic Example

First, ensure your server generates an OpenAPI spec and Request/Response types:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });
const openApiSpec = generateOpenAPISpec({ api: router }, {
  title: "My API",
  version: "1.0.0",
});

export { openApiSpec };
export default app;
```

Then generate Request and Response types from the OpenAPI spec (see [Server Integration](../guides/server-integration) for details), and use the client:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

// Make a type-safe API call
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // TypeScript knows the shape of result.body
  console.log(result.body.name); // ✅ Type-safe
  console.log(result.body.email); // ✅ Type-safe
  // Access raw Response if needed
  console.log(result.raw.headers.get("x-request-id"));
} else {
  // Handle error
  console.error(result.error);
}
```

## Features

- **Type-safe**: Full TypeScript inference from server types
- **Validation**: Automatic runtime validation using Zod schemas
- **Error handling**: Typed error responses
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters
- **Raw response access**: Access underlying Response/KyResponse for advanced use cases

---

// File: client/guides/server-integration

# Server Integration

Learn how to integrate the client with your Altstack server.

## Overview

To use the client with your server, you need:

1. Generate an OpenAPI spec from your server router
2. Generate `Request` and `Response` types from the OpenAPI spec
3. Create a client instance with these types

## Step 1: Generate OpenAPI Spec

On your server, generate the OpenAPI spec:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });

// Generate OpenAPI spec
const openApiSpec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
  }
);

export { openApiSpec };
export default app;
```

## Step 2: Generate Request and Response Types

Use the `@alt-stack/zod-openapi` package to generate TypeScript types:

```typescript
// generate-types.ts
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";
import { openApiSpec } from "./server.js";
import { writeFileSync } from "fs";

const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});

writeFileSync("./src/generated-types.ts", generatedCode);
```

This generates a file with:
- Zod schemas for all request parameters, query strings, bodies, and responses
- `Request` object with lookup for request schemas
- `Response` object with lookup for response schemas organized by status code

Example generated output:

```typescript
// generated-types.ts
import { z } from "zod";

export const GetUsersIdParamsSchema = z.object({
  id: z.string(),
});

export const GetUsersId200ResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

export const GetUsersId404ErrorResponseSchema = z.object({
  error: z.object({
    code: z.literal("NOT_FOUND"),
    message: z.string(),
  }),
});

export const Request = {
  "/users/{id}": {
    GET: {
      params: GetUsersIdParamsSchema,
    },
  },
} as const;

export const Response = {
  "/users/{id}": {
    GET: {
      "200": GetUsersId200ResponseSchema,
      "404": GetUsersId404ErrorResponseSchema,
    },
  },
} as const;
```

## Step 3: Create Client

Now create the client using the generated types:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/http-client-fetch";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

export { client };
```

## Step 4: Use the Client

Now you can make type-safe API calls:

```typescript
import { client } from "./client.js";

// Type-safe GET request
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body.name); // ✅ Type-safe
}
```

## Keeping Types in Sync

It's recommended to regenerate types whenever you change your server routes. You can:

1. **Manual regeneration**: Run your type generation script when routes change
2. **Watch mode**: Use a file watcher to regenerate on route changes
3. **Build step**: Include type generation in your build process

## Sharing Types Between Projects

If your client is in a separate project from your server:

1. Export the OpenAPI spec from your server project
2. Share it via npm package, git submodule, or API endpoint
3. Generate types in your client project from the shared spec

Example: Export spec as JSON endpoint:

```typescript
// server.ts
const docsRouter = createDocsRouter({ api: router });
app.route("/docs", docsRouter);

// Access at /docs/openapi.json
```

Then fetch and generate types in client:

```typescript
// client project
const response = await fetch("http://localhost:3000/docs/openapi.json");
const openApiSpec = await response.json();
const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});
```

---

// File: core-concepts/combining-routers

# Combining Routers

Organize your API by combining multiple routers using the new tRPC-style `router()` function. Routers can be nested, and paths combine automatically.

## Basic Router Combination

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

// User routes
const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      const { input } = opts;
      return { id: input.id, name: "Alice" };
    }),

  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .post((opts) => {
      return { id: "1" };
    }),
});

// Post routes
const postsRouter = router({
  list: publicProcedure
    .output(
      z.array(
        z.object({
          id: z.string(),
          title: z.string(),
        })
      )
    )
    .get(() => {
      return [{ id: "1", title: "Hello World" }];
    }),
});

// Combine routers - keys become path prefixes
const appRouter = router({
  users: userRouter,  // Routes prefixed with /users
  posts: postsRouter, // Routes prefixed with /posts
});

const app = createServer({
  api: appRouter,
});

// Routes available at:
// - GET /api/users/{id}
// - POST /api/users/create
// - GET /api/posts/list
```

## Nested Routers

Routers can be nested within other routers. Paths combine automatically:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const productRouter = router({
  "favorites/me": publicProcedure.get(() => {
    return [];
  }),
});

const userRouter = router({
  profile: publicProcedure.get(() => {
    return { id: "1" };
  }),
});

// Nested routers
const appRouter = router({
  products: productRouter,  // /products/favorites/me
  users: userRouter,        // /users/profile
});

// Final paths:
// - GET /products/favorites/me
// - GET /users/profile
```

## Multiple Routers with Same Prefix

You can pass arrays of routers for the same prefix in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const app = createServer({
  api: [v1Router, v2Router], // Both routers prefixed with /api
});
```

This is useful for versioning APIs or organizing routes by feature.

## Nested Routes with Compound Paths

To achieve nested routes like `/api/v1/*` and `/api/v2/*`, use compound prefixes in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const adminRouter = router({
  settings: publicProcedure.get(() => []),
});

const app = createServer({
  "api/v1": v1Router,
  "api/v2": v2Router,
  admin: adminRouter,
});
```

Results in routes like:
- `/api/v1/users` - All v1Router routes
- `/api/v2/users` - All v2Router routes
- `/admin/settings` - All adminRouter routes

---

// File: core-concepts/custom-context

# Custom Context

Define custom context (similar to tRPC) to pass data like database connections or authentication info.

## Defining Context

Create a context type and a function to create it:

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import type { Context } from "hono";
import { z } from "zod";

// Define your context type
interface AppContext {
  db: Database;
  user: User | null;
}

// Create context function
async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthenticatedUser(c);
  return {
    db: database,
    user,
  };
}

// Create factory and router with context type
const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.db and ctx.user are typed and available
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    return {
      id: ctx.user.id,
      name: ctx.user.name,
    };
  });

// Create server with createContext
const app = createServer({
  users: router,
}, {
  createContext,
});
```

## Accessing Hono Context

Access the raw Hono context for advanced use cases:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
    }),
  })
  .handler((ctx) => {
    // Access raw Hono context
    const headers = ctx.hono.req.header();
    const ip = ctx.hono.req.header("x-forwarded-for");
    
    return { id: ctx.input.id };
  });
```

The `ctx.hono` property gives you full access to the underlying Hono context for headers, cookies, environment variables, and other advanced features.

---

// File: core-concepts/error-handling

# Error Handling

Define error schemas and use `ok()` / `err()` for type-safe error responses with the Result pattern.

## Defining Error Schemas

Specify error schemas using `.errors()`:

```typescript
import { init, router, ok, err } from "@alt-stack/server-hono";

const factory = init();

const userRouter = router({
  "{id}": factory.procedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(z.object({ id: z.string(), name: z.string() }))
    .errors({
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    })
    .get(({ input }) => {
      const user = findUser(input.params.id);

      if (!user) {
        // Return error with _httpCode for status code
        return err({
          _httpCode: 404 as const,
          data: {
            error: {
              code: "NOT_FOUND" as const,
              message: `User ${input.params.id} not found`,
            },
          },
        });
      }

      return ok(user);
    }),
});
```

## Multiple Error Types

Define multiple error status codes:

```typescript
const userRouter = router({
  "/": factory.procedure
    .input({
      body: z.object({ email: z.string().email() }),
    })
    .output(z.object({ id: z.string() }))
    .errors({
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
      409: z.object({
        error: z.object({
          code: z.literal("CONFLICT"),
          message: z.string(),
        }),
      }),
    })
    .post(({ input }) => {
      if (userExists(input.body.email)) {
        return err({
          _httpCode: 409 as const,
          data: {
            error: {
              code: "CONFLICT" as const,
              message: "User already exists",
            },
          },
        });
      }

      const user = createUser(input.body);
      return ok({ id: user.id });
    }),
});
```

## HTTP Status Codes

The `_httpCode` field determines the HTTP response status:

```typescript
return err({
  _httpCode: 404 as const,  // Sets HTTP status to 404
  data: { error: { code: "NOT_FOUND" as const, message: "Not found" } },
});
```

Without `_httpCode`, errors default to 500.

## Validation Errors

Input validation errors are automatic. When validation fails, a `400` response is returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

## Middleware Errors

Middleware can return `err()` just like handlers. Define errors with `.errors()` before `.use()`:

```typescript
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.user) {
      return err({
        _httpCode: 401 as const,
        data: {
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        },
      });
    }
    return next({ ctx: { user: ctx.user } });
  });
```

## See Also

- [Result Type](./result-type) - Complete guide to Result utilities

---

// File: core-concepts/input-validation

# Input Validation

Automatic validation of path parameters, query parameters, and request body using Zod schemas.

## Validation Sources

Inputs can be validated from three sources:

- **params**: Path parameters (e.g., `/users/{id}`)
- **query**: Query string parameters (e.g., `?limit=10&offset=0`)
- **body**: Request body for POST/PUT/PATCH requests

## Example

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .get((opts) => {
      // opts.input.params.id (from params)
      // opts.input.query.limit (from query)
      // opts.input.query.offset (from query)
      const { input } = opts;
      return { id: input.params.id };
    }),
});
```

## String Input Constraints

Since HTTP path parameters and query strings are always strings, `params` and `query` schemas are constrained at **compile-time** to only accept Zod types that can parse string input. This prevents runtime errors from invalid schema configurations.

| Schema | Input Type | Allowed in params/query? |
|--------|-----------|--------------------------|
| `z.string()` | `string` | ✅ |
| `z.enum(["a", "b"])` | `"a" \| "b"` | ✅ (string literals) |
| `z.coerce.number()` | `unknown` | ✅ (coerces strings) |
| `z.string().transform(...)` | `string` | ✅ (transform) |
| `z.codec(z.string(), ...)` | `string` | ✅ (Zod 4 codec) |
| `z.number()` | `number` | ❌ compile error |
| `z.boolean()` | `boolean` | ❌ compile error |
| `z.array(...)` | `T[]` | ❌ compile error |

```typescript
// ✅ Valid - all fields accept string input
.input({
  params: z.object({ id: z.string() }),
  query: z.object({ page: z.coerce.number() }),
})

// ❌ Compile error - z.number() doesn't accept string input
.input({
  query: z.object({ page: z.number() }), // Error!
})
```

:::tip Use z.coerce for numeric parameters
Since query strings are always strings, use `z.coerce.number()` instead of `z.number()` to automatically convert string values like `"42"` to numbers.
:::

### Zod 4 Codecs

[Zod 4 codecs](https://zod.dev/codecs) provide bidirectional transformation between input and output types. They work seamlessly with params/query since the input schema determines what the field accepts:

```typescript
// Define a codec that transforms ISO strings to Date objects
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString),
    encode: (date) => date.toISOString(),
  }
);

// ✅ Valid - input type is string (from z.iso.datetime())
.input({
  query: z.object({
    since: stringToDate, // Accepts: "2024-01-15T10:30:00.000Z"
  }),
})
.get(({ input }) => {
  // input.query.since is typed as Date (the output type)
  const date: Date = input.query.since;
  return { events: getEventsSince(date) };
})
```

:::note Body has no string constraint
The `body` field has no string input constraint since request bodies are parsed as JSON and can contain any JSON-serializable types.
:::

## Path Parameter Validation

When using path parameters in the route key (e.g., `{id}`), TypeScript enforces that you must provide a `params` schema with matching keys:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  // ✅ Valid - params.id matches {id} in path
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      return { id: opts.input.params.id };
    }),

  // ❌ TypeScript error - missing params.id for {id} path
  // "{id}": publicProcedure.get(() => ({ id: "1" })),
});
```

## Validation Errors

When validation fails, a `400` response is automatically returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

The handler is only called if all inputs pass validation, ensuring type safety and runtime safety.

## Combining Input Types

You can combine params, query, and body validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.enum(["profile", "posts"]).optional(),
      }),
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      const { input } = opts;
      // All inputs are validated and typed:
      // input.params.id (from params)
      // input.query.include (from query, optional)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

---

// File: core-concepts/middleware

# Middleware

Apply middleware to procedures to add cross-cutting concerns like authentication, logging, or rate limiting.

## Procedure-Level Middleware

Apply middleware to specific procedures using `.use()`:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .use(async (opts) => {
      // Log before handler
      const { ctx, next } = opts;
      console.log("Creating user:", ctx.input.name);
      return next();
    })
    .post((opts) => {
      return { id: "1" };
    }),
});
```

## Context Extension

Middleware can extend the context by passing updated context to `next()`. This follows the tRPC pattern:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  console.log(`Request took ${duration}ms`);
  return result;
};

const authMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const user = await authenticate(ctx.hono.req);
  if (!user) {
    return ctx.hono.json({ error: "Unauthorized" }, 401);
  }
  // Extend context - user is now non-null in subsequent handlers
  return next({ ctx: { user } });
};

const protectedProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware);

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null
      const { ctx } = opts;
      return { id: ctx.user!.id, name: ctx.user!.name };
    }),
});
```

## Multiple Middleware

Chain multiple middleware on the same procedure:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: any) => {
  console.log("Request started");
  return opts.next();
};

const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

const adminMiddleware = async (opts: any) => {
  if (opts.ctx.user?.role !== "admin") {
    return new Response("Forbidden", { status: 403 });
  }
  return opts.next();
};

const adminProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware)
  .use(adminMiddleware);

export const adminRouter = router({
  settings: adminProcedure.get(() => {
    return { admin: true };
  }),
});
```

Middleware executes in the order they're defined.

## Reusable Procedures

Create reusable procedures with middleware to reuse authentication or other middleware across multiple routes. See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for details:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  // Auth middleware
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

// Use procedures
export const appRouter = router({
  hello: publicProc.get(() => "hello"),
  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      return opts.ctx.user!;
    }),
});
```

## Middleware Chaining and Context Flow

Middleware can chain together, with each middleware able to extend the context:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
  requestId: string;
  isAdmin: boolean;
}

const factory = init<AppContext>();

// First middleware adds requestId
const requestIdMiddleware = async (opts: any) => {
  const requestId = crypto.randomUUID();
  return opts.next({ ctx: { requestId } });
};

// Second middleware adds user
const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

// Third middleware adds isAdmin based on user role
const adminCheckMiddleware = async (opts: any) => {
  const isAdmin = opts.ctx.user?.role === "admin";
  return opts.next({ ctx: { isAdmin } });
};

const adminProcedure = factory.procedure
  .use(requestIdMiddleware)
  .use(authMiddleware)
  .use(adminCheckMiddleware);

export const adminRouter = router({
  dashboard: adminProcedure
    .input({})
    .get((opts) => {
      // All context extensions are available
      const { ctx } = opts;
      return {
        requestId: ctx.requestId,
        userId: ctx.user!.id,
        isAdmin: ctx.isAdmin,
      };
    }),
});
```

---

// File: core-concepts/output-validation

# Output Validation

Optionally validate response data to ensure handlers return the expected structure.

## Basic Usage

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // Return value is validated against output schema
    return {
      id: ctx.input.id,
      name: "Alice",
    };
  });
```

## Benefits

- **Runtime safety**: Catch bugs during development when handlers return incorrect data
- **Type safety**: TypeScript ensures your return value matches the schema
- **Documentation**: Output schemas serve as API documentation

## Optional Output Validation

Output validation is optional. If you omit the `output` field, no validation is performed, but you lose type safety for the return value:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    // No output validation
  })
  .handler((ctx) => {
    return { id: ctx.input.id };
  });
```

---

// File: core-concepts/result-type

# Result Type

Handlers return a `Result<E, A>` type for explicit error handling, inspired by Effect-TS.

## Overview

The `@alt-stack/result` package provides a type-safe way to handle errors in handlers. Instead of throwing exceptions, handlers return `Result` types that make errors explicit in the type system.

```typescript
import { ok, err, type Result } from "@alt-stack/server-hono";

// Success: wrap value in ok()
return ok({ id: "123", name: "John" });

// Error: wrap error in err()
return err({ _httpCode: 404, data: { error: { code: "NOT_FOUND", message: "User not found" } } });
```

## Basic Usage

### Returning Success

Use `ok()` to return successful values:

```typescript
const handler = procedure
  .output(z.object({ id: z.string(), name: z.string() }))
  .get(({ input }) => {
    const user = { id: "123", name: "John" };
    return ok(user);
  });
```

### Returning Errors

Use `err()` to return typed errors. Include `_httpCode` to set the HTTP status code:

```typescript
const handler = procedure
  .output(UserSchema)
  .errors({
    404: z.object({
      error: z.object({
        code: z.literal("NOT_FOUND"),
        message: z.string(),
      }),
    }),
  })
  .get(({ input }) => {
    const user = findUser(input.params.id);

    if (!user) {
      return err({
        _httpCode: 404 as const,
        data: {
          error: {
            code: "NOT_FOUND" as const,
            message: `User ${input.params.id} not found`,
          },
        },
      });
    }

    return ok(user);
  });
```

## Error Structure

Errors have two optional tags:
- `_httpCode`: HTTP status code (e.g., 404, 500)
- `data`: The error payload matching your error schema

```typescript
return err({
  _httpCode: 400 as const,
  data: {
    error: {
      code: "VALIDATION_ERROR" as const,
      message: "Invalid input",
    },
  },
});
```

## Type Inference

Error types are inferred from your `.errors()` definitions. TypeScript ensures you can only return errors that match defined schemas:

```typescript
procedure
  .errors({
    404: z.object({ error: z.object({ code: z.literal("NOT_FOUND"), message: z.string() }) }),
    409: z.object({ error: z.object({ code: z.literal("CONFLICT"), message: z.string() }) }),
  })
  .handler(({ input }) => {
    // TypeScript knows errors must match 404 or 409 schemas
    if (!exists) {
      return err({ _httpCode: 404 as const, data: { error: { code: "NOT_FOUND" as const, message: "Not found" } } });
    }
    if (conflict) {
      return err({ _httpCode: 409 as const, data: { error: { code: "CONFLICT" as const, message: "Already exists" } } });
    }
    return ok(result);
  });
```

## Result Utilities

The result package includes utility functions:

### Type Guards

```typescript
import { isOk, isErr } from "@alt-stack/server-hono";

const result = await handler();
if (isOk(result)) {
  console.log(result.value);
}
if (isErr(result)) {
  console.log(result.error);
}
```

### Pattern Matching

```typescript
import { match } from "@alt-stack/server-hono";

const message = match(result, {
  ok: (value) => `Success: ${value.name}`,
  err: (error) => `Error: ${error.data.error.message}`,
});
```

### Transformations

```typescript
import { map, flatMap, mapError } from "@alt-stack/server-hono";

// Transform success value
const mapped = map(result, (user) => user.name);

// Chain operations
const chained = flatMap(result, (user) => {
  if (!user.active) return err({ _code: 1, data: { message: "Inactive" } });
  return ok(user.profile);
});

// Transform error
const withNewError = mapError(result, (e) => ({ ...e, logged: true }));
```

### Extraction

```typescript
import { unwrap, unwrapOr } from "@alt-stack/server-hono";

// Get value or throw (use sparingly)
const value = unwrap(result);

// Get value or default
const valueOrDefault = unwrapOr(result, defaultUser);
```

### Try-Catch Wrappers

```typescript
import { tryCatch, tryCatchAsync } from "@alt-stack/server-hono";

// Wrap sync function
const result = tryCatch(
  () => JSON.parse(input),
  (e) => ({ _code: 1, data: { message: "Invalid JSON" } })
);

// Wrap async function
const asyncResult = await tryCatchAsync(
  () => fetchUser(id),
  (e) => ({ _httpCode: 500 as const, data: { error: { code: "FETCH_ERROR", message: String(e) } } })
);
```

## Middleware

Middleware can return `err()` just like handlers. Define errors with `.errors()` before `.use()`:

```typescript
const protectedProcedure = procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.user) {
      return err({
        _httpCode: 401 as const,
        data: {
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        },
      });
    }
    return next({ ctx: { user: ctx.user } });
  });
```

Handlers also return Result types:

```typescript
const handler = protectedProcedure.get(({ ctx }) => {
  return ok({ user: ctx.user });
});
```

## Kafka/Workers Result

For Kafka and Workers, use `InferMessageErrors` instead of HTTP codes:

```typescript
import { ok, err } from "@alt-stack/kafka-core";

const handler = procedure
  .errors({
    INVALID_USER: z.object({ error: z.object({ code: z.string(), message: z.string() }) }),
  })
  .subscribe(({ input }) => {
    if (!input.userId) {
      return err({ data: { error: { code: "INVALID_USER", message: "User ID required" } } });
    }
    return ok();
  });
```

---

// File: core-concepts/reusable-procedures

# Reusable Procedures

Create reusable procedures with middleware to follow the tRPC pattern. This allows you to define common authentication, validation, or other middleware once and reuse it across multiple routes.

## Basic Pattern

Use `publicProcedure` or `init()` to create procedures:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    // `ctx.user` is nullable
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    // ✅ Pass updated context where user is non-null
    return next({
      ctx: {
        user: ctx.user, // ✅ user value is known to be non-null now
      },
    });
  });

// Create a router using the new tRPC-style API
export const appRouter = router({
  hello: publicProc.get(() => {
    return "hello world";
  }),

  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null after middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        name: ctx.user!.name,
      };
    }),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => {
      return { secret: "sauce" };
    }),
});
```

## Configuring Procedures

Procedures support the same configuration methods as regular routes:

### Setting Default Input

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const validatedProcedure = publicProcedure.input({
  query: z.object({
    apiKey: z.string().min(1),
  }),
});

// All routes using this procedure will require apiKey in query
export const dataRouter = router({
  list: validatedProcedure
    .input({
      body: z.object({ filter: z.string() }), // Additional input
    })
    .get((opts) => {
      // opts.input.apiKey is available (from procedure)
      // opts.input.filter is available (from route)
      const { input } = opts;
      return [];
    }),
});
```

### Setting Default Output

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const jsonProcedure = publicProcedure.output(
  z.object({
    success: z.boolean(),
  })
);

export const actionRouter = router({
  create: jsonProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post((opts) => {
      // output is automatically set from procedure
      return { success: true };
    }),
});
```

### Setting Default Errors

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const errorProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const protectedRouter = router({
  data: errorProcedure
    .input({})
    .output(z.string())
    .get((opts) => {
      const { ctx } = opts;
      if (someCondition) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Not authorized",
          },
        });
      }
      return "success";
    }),
});
```

### Combining Procedure and Route Errors

Errors defined on procedures are automatically merged with errors defined on routes. Route errors take precedence when the same status code is defined in both:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

// Procedure defines common authentication error
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const userRouter = router({
  "{id}": apiProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(z.object({ id: z.string(), name: z.string() }))
    .errors({
      // 401 is inherited from procedure
      // Add additional route-specific errors
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
      403: z.object({
        error: z.object({
          code: z.literal("FORBIDDEN"),
          message: z.string(),
        }),
      }),
    })
    .get((opts) => {
      const { input, ctx } = opts;
      const user = findUser(input.id);

      if (!user) {
        // Can throw 404 error (defined on route)
        throw ctx.error({
          error: {
            code: "NOT_FOUND",
            message: "User not found",
          },
        });
      }

      if (!canAccessUser(user)) {
        // Can throw 403 error (defined on route)
        throw ctx.error({
          error: {
            code: "FORBIDDEN",
            message: "Access denied",
          },
        });
      }

      if (!isAuthenticated()) {
        // Can throw 401 error (inherited from procedure)
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Authentication required",
          },
        });
      }

      return user;
    }),
});
```

In this example, the route has access to all three error types:
- `401 UNAUTHORIZED` from the procedure
- `404 NOT_FOUND` from the route
- `403 FORBIDDEN` from the route

**Union of Error Schemas**: If both the procedure and route define an error with the same status code, the schemas are unioned. This means `ctx.error()` can accept either schema for that status code:

```typescript
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const settingsRouter = router({
  me: apiProcedure
    .input({})
    .errors({
      // Route defines a different 401 error schema - they will be unioned
      401: z.object({
        error: z.object({
          code: z.literal("SESSION_EXPIRED"),
          message: z.string(),
          redirect: z.string().url(),
        }),
      }),
    })
    .get((opts) => {
      const { ctx } = opts;
      // Can throw 401 with either UNAUTHORIZED or SESSION_EXPIRED
      throw ctx.error({
        error: {
          code: "SESSION_EXPIRED",
          message: "Your session has expired",
          redirect: "https://example.com/login",
        },
      });
    }),
});
```

## Middleware Chaining

Middleware can be chained to build up context:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const authProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  const user = await getUser(ctx);
  if (!user) {
    throw ctx.error({ code: "UNAUTHORIZED" });
  }
  return next({ ctx: { user } });
});

const adminProcedure = authProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (ctx.user.role !== "admin") {
    throw ctx.error({ code: "FORBIDDEN" });
  }
  return next({ ctx: { isAdmin: true } });
});

export const adminRouter = router({
  settings: adminProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user and opts.ctx.isAdmin are both available
      const { ctx } = opts;
      return { admin: ctx.isAdmin };
    }),
});
```

## Common Patterns

### Public and Protected Routes

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(authMiddleware);

export const appRouter = router({
  hello: publicProc.get(() => "hello"),

  profile: protectedProcedure
    .input({})
    .get((opts) => {
      return opts.ctx.user!; // Non-null due to middleware
    }),
});
```

### Role-Based Procedures

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { role: string } | null;
}

const factory = init<AppContext>();

const requireRole = (role: string) =>
  factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next();
  });

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  delete: adminProcedure.get(() => ({ success: true })),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure.post(() => ({ success: true })),
});
```

### Rate Limited Procedures

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const rateLimitedProcedure = publicProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  const rateLimitKey = getRateLimitKey(ctx);
  if (await isRateLimited(rateLimitKey)) {
    return new Response("Too many requests", { status: 429 });
  }
  await incrementRateLimit(rateLimitKey);
  return next();
});

export const apiRouter = router({
  data: rateLimitedProcedure.get(() => {
    return { data: [] };
  }),
});
```

---

// File: getting-started/basic-routes

# Basic Routes

Define routes using the tRPC-style API with support for all HTTP methods.

## Route Methods

The router supports all standard HTTP methods:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure.get(() => {
    return [];
  }),
  
  create: publicProcedure.post(() => {
    return { id: "1" };
  }),
  
  update: publicProcedure.put(() => {
    return { id: "1" };
  }),
  
  patch: publicProcedure.patch(() => {
    return { id: "1" };
  }),
  
  remove: publicProcedure.delete(() => {
    return { success: true };
  }),
});
```

## Path Parameters

Extract parameters from the URL path. Path parameters in the route key (e.g., `{id}`) are automatically validated:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      // opts.input.id is typed as string
      const { input } = opts;
      return {
        id: input.id,
        name: "Alice",
      };
    }),
});
```

**Type Safety**: TypeScript will automatically detect an error if you use a path parameter like `{id}` but don't provide the corresponding `params.id` in your input schema. For example, this would cause a TypeScript error:

```typescript
// ❌ TypeScript error: Missing required path parameter 'id' in params
export const userRouter = router({
  "{id}": publicProcedure.get((opts) => {
    return { id: "1" };
  }),
});
```

You must include `params: z.object({ id: z.string() })` (or the appropriate type) when using `{id}` in your route path.

## Query Parameters

Extract query string parameters:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure
    .input({
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
        search: z.string().optional(),
      }),
    })
    .get((opts) => {
      // opts.input.query.limit, opts.input.query.offset, opts.input.query.search are typed
      const { input } = opts;
      return [];
    }),
});
```

:::tip Use z.coerce for numeric query parameters
Query strings are always strings in HTTP. Use `z.coerce.number()` to automatically convert string values like `"10"` to numbers. See [Input Validation](/core-concepts/input-validation#string-input-constraints) for more details.
:::

## Request Body

Handle POST/PUT/PATCH requests with typed request bodies:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .post((opts) => {
      // opts.input.name and opts.input.email are typed
      const { input } = opts;
      return {
        id: "1",
        name: input.name,
      };
    }),
});
```

## Combining Input Sources

You can combine params, query, and body:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        notify: z.coerce.boolean().optional(),
      }),
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      // All inputs are available and typed
      const { input } = opts;
      // input.params.id (from params)
      // input.query.notify (from query)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

## Output Validation

You can specify output schemas for validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
});

export const userRouter = router({
  get: publicProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(UserSchema)
    .get((opts) => {
      return {
        id: opts.input.id,
        name: "Alice",
        email: "alice@example.com",
      };
    }),
});
```

---

// File: getting-started/installation

# Installation

Choose an adapter based on your preferred HTTP framework.

## Hono Adapter (Recommended)

Best for new projects, edge deployments, and serverless environments.

```bash
pnpm add @alt-stack/server-hono hono zod
# or
npm install @alt-stack/server-hono hono zod
# or
yarn add @alt-stack/server-hono hono zod
```

### Peer Dependencies

- **hono**: `^4.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Express Adapter

Best for existing Express applications or teams familiar with Express.

```bash
pnpm add @alt-stack/server-express express zod
# or
npm install @alt-stack/server-express express zod
# or
yarn add @alt-stack/server-express express zod
```

For TypeScript users:
```bash
pnpm add -D @types/express
```

### Peer Dependencies

- **express**: `^4.0.0 || ^5.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Which Adapter Should I Choose?

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards API) | Mature, well-tested |
| Bundle size | Smaller | Larger ecosystem |
| Edge/Serverless | Native support (Cloudflare, Vercel) | Requires adapters |
| Middleware ecosystem | Growing | Extensive |
| Learning curve | Familiar if you know fetch | Familiar if you know Express |

**Recommendation**: Use `@alt-stack/server-hono` for new projects. Use `@alt-stack/server-express` if you're adding to an existing Express app or need specific Express middleware.

## Migration from @alt-stack/server

If you're using the deprecated `@alt-stack/server` package:

```bash
# Remove old package
pnpm remove @alt-stack/server

# Install new package
pnpm add @alt-stack/server-hono hono zod
```

Then update your imports:

```typescript
// Before
import { createServer, router } from "@alt-stack/server";

// After
import { createServer, router } from "@alt-stack/server-hono";
```

The API remains the same - only the import path changes.

---

// File: getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates the core concepts.

## Basic Example

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.id is typed as string (from params)
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  })
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.name and ctx.input.email are typed (from body)
    return {
      id: "1",
      name: ctx.input.name,
    };
  });

const app = createServer({
  api: router,
});

// Use with your favorite Hono adapter
export default app;
```

This example shows:
- Type-safe route definitions with Zod schemas
- Automatic input validation from params, query, and body
- Type inference in handlers
- Combining routes into a server

---

// File: guides/asyncapi-to-typescript

# AsyncAPI to TypeScript

Generate TypeScript types and Zod schemas from AsyncAPI specifications using the `zod-asyncapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-asyncapi
# or
npm install @alt-stack/zod-asyncapi
```

## CLI Usage

```bash
npx zod-asyncapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-asyncapi asyncapi.json

# Generate from URL (e.g., from your running Kafka producer)
npx zod-asyncapi http://localhost:3000/asyncapi.json

# Specify output file
npx zod-asyncapi asyncapi.json -o src/kafka-types.ts
```

## Generated Output

Given an AsyncAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Message schemas** for each topic
- **Topics lookup object** for easy schema access

### Example

For an AsyncAPI spec with a `User` schema and `user-events` topic:

```typescript
/**
 * This file was automatically generated from AsyncAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

// Component Schemas
export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

// Topic Message Schemas
export const UserEventsMessageSchema = UserSchema;
export type UserEventsMessage = z.infer<typeof UserEventsMessageSchema>;

// Topics Object
export const Topics = {
  'user-events': UserEventsMessageSchema
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Using Generated Types with Kafka Client

The generated `Topics` object works directly with `@alt-stack/kafka-client-kafkajs` or `@alt-stack/kafka-client-warpstream`:

### KafkaJS Producer

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending - topic names and message shapes are validated
await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});

await client.disconnect();
```

### WarpStream Producer

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToAsyncApiSchema } from "@alt-stack/zod-asyncapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToAsyncApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-asyncapi asyncapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/kafka-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Workflow: Server to Client

A typical workflow:

1. **Server defines Kafka topics** with Zod schemas using `@alt-stack/kafka-core`
2. **Server exposes AsyncAPI spec** at an endpoint
3. **Client generates types** using `zod-asyncapi`
4. **Client uses Kafka client** with generated types

```bash
# Generate types from running server
npx zod-asyncapi http://localhost:3000/asyncapi.json -o src/kafka-types.ts
```

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { asyncApiToZodTsCode } from "@alt-stack/zod-asyncapi";

const asyncApiSpec = {
  asyncapi: "3.0.0",
  info: { title: "My API", version: "1.0.0" },
  channels: {
    userEvents: {
      address: "user-events",
      messages: {
        UserCreated: { $ref: "#/components/messages/UserCreated" },
      },
    },
  },
  components: {
    messages: {
      UserCreated: {
        payload: { $ref: "#/components/schemas/User" },
      },
    },
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
};

const generatedCode = asyncApiToZodTsCode(
  asyncApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
);

console.log(generatedCode);
```

---

// File: guides/better-auth-integration

# Better Auth Integration

Integrate Better Auth for authentication with your server framework. Better Auth handles session management, authentication flows, and user management.

## Setup

First, install Better Auth:

```bash
pnpm add better-auth
# or
npm install better-auth
# or
yarn add better-auth
```

Create your Better Auth configuration:

```typescript
// src/auth.ts
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { z } from "zod";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg", // or your database provider
  }),
  emailAndPassword: {
    enabled: true,
  },
  // Add other auth providers as needed
});
```

## Validating User Session with Zod

Better Auth returns session data that should be validated. Use Zod to ensure type safety and validate the user structure:

```typescript
import { z } from "zod";
import { auth } from "./auth.js";

// Define your user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  // Add other user fields as needed
});

// Schema for Better Auth session
const SessionSchema = z.object({
  user: UserSchema,
  session: z.object({
    id: z.string(),
    userId: z.string(),
    expiresAt: z.date(),
  }),
});

// Infer TypeScript types from Zod schemas
export type User = z.infer<typeof UserSchema>;
export type Session = z.infer<typeof SessionSchema>;

export async function getAuthSession(request: Request): Promise<Session | null> {
  const session = await auth.api.getSession({ headers: request.headers });
  
  // Validate and parse the session with safeParse for optional validation
  const result = SessionSchema.safeParse(session);
  
  if (!result.success) {
    // Log validation errors in development
    if (process.env.NODE_ENV === "development") {
      console.warn("Session validation failed:", result.error);
    }
    return null;
  }
  
  return result.data;
}

// Or if you only need the user:
export async function getAuthUser(request: Request): Promise<User | null> {
  const session = await getAuthSession(request);
  return session?.user ?? null;
}
```

## Mounting Better Auth Routes

Mount Better Auth routes alongside your server framework routes. Better Auth handles all `/api/auth/*` routes:

```typescript
import { Hono } from "hono";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create base Hono app
const app = new Hono();

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount your server framework routes
const serverApp = createServer({
  todos: todosRouter,
});

app.route("/", serverApp);

export default app;
```

## Adding User to Context

Add the authenticated user to your custom context so it's available in all handlers. Use Zod validation to ensure type safety:

```typescript
import { createServer } from "@alt-stack/server-hono";
import { getAuthUser, type User } from "./auth.js";
import type { Context } from "hono";
import { z } from "zod";

interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return {
    user,
  };
}

const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      email: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    // ctx.user is fully typed based on UserSchema
    return {
      id: ctx.user.id,
      email: ctx.user.email,
      name: ctx.user.name,
    };
  });

const app = createServer({
  users: router,
}, {
  createContext,
});
```

---

// File: guides/ci-cd-sdk-generation

# CI/CD SDK Generation

Automatically generate and publish TypeScript SDKs from your API schemas using GitHub Actions.

## Overview

Alt Stack provides example GitHub Action workflows for automating SDK generation:

| Workflow | Use Case |
|----------|----------|
| `generate-openapi-sdk.yml` | Generate types from OpenAPI and commit to repo |
| `generate-asyncapi-sdk.yml` | Generate types from AsyncAPI and commit to repo |
| `publish-openapi-schema.yml` | Publish OpenAPI SDK as npm package |
| `publish-asyncapi-schema.yml` | Publish AsyncAPI SDK as npm package |

## Setup for a TypeScript Project

### Prerequisites

Your project should have:
- A `package.json` with a `generate-spec` script
- Node.js 20+ and pnpm (or npm/yarn)

### Project Structure

```
my-api/
├── .github/
│   └── workflows/
│       └── generate-sdk.yml    # Your workflow file
├── src/
│   ├── index.ts                # Your API server
│   ├── router.ts               # Your router definition
│   └── generate-spec.ts        # Script to generate spec
├── openapi.json                # Generated spec (committed)
├── generated-types.ts          # Generated SDK (auto-committed)
├── package.json
└── tsconfig.json
```

## Generate OpenAPI SDK (In-Repo)

This workflow generates TypeScript types from your OpenAPI spec and commits them to your repository.

### Step 1: Create the Workflow

Create `.github/workflows/generate-sdk.yml`:

```yaml
name: Generate SDK

on:
  push:
    branches: [main]
    paths: ['src/**', 'openapi.json']
  pull_request:
    paths: ['src/**', 'openapi.json']

env:
  OPENAPI_FILE: 'openapi.json'
  OUTPUT_PATH: 'generated-types.ts'

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile

      - run: pnpm add -D @alt-stack/zod-openapi

      - name: Generate spec
        run: npm run generate-spec --if-present || true

      - name: Generate SDK
        run: npx zod-openapi ${{ env.OPENAPI_FILE }} -o ${{ env.OUTPUT_PATH }}

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet ${{ env.OUTPUT_PATH }}; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.OUTPUT_PATH }}
          git commit -m "chore: regenerate types [skip ci]"
          git push

      - name: Fail if outdated (PR)
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated types are outdated. Run locally:"
          echo "npm run generate-spec && npx zod-openapi ${{ env.OPENAPI_FILE }} -o ${{ env.OUTPUT_PATH }}"
          exit 1
```

### Step 2: Define Your Router

```typescript title="src/router.ts"
import { init, router } from '@alt-stack/server-hono';
import { z } from 'zod';

const { publicProcedure } = init();

export const appRouter = router({
  getUser: publicProcedure
    .input({ params: z.object({ id: z.string() }) })
    .output(z.object({ id: z.string(), name: z.string() }))
    .get('/users/:id', async ({ input }) => {
      return { id: input.params.id, name: 'John' };
    }),
});
```

### Step 3: Create Generate Script

```typescript title="src/generate-spec.ts"
import { writeFileSync } from 'fs';
import { generateOpenAPISpec } from '@alt-stack/server-hono';
import { appRouter } from './router';

const spec = generateOpenAPISpec(appRouter, {
  title: 'My API',
  version: '1.0.0',
});

writeFileSync('openapi.json', JSON.stringify(spec, null, 2));
console.log('Generated openapi.json');
```

### Step 4: Add Scripts

```json title="package.json"
{
  "scripts": {
    "generate-spec": "tsx src/generate-spec.ts",
    "generate-types": "npm run generate-spec && npx zod-openapi openapi.json -o generated-types.ts"
  }
}
```

## Generate AsyncAPI SDK (In-Repo)

For Kafka/event-driven APIs using AsyncAPI.

### Step 1: Create the Workflow

```yaml title=".github/workflows/generate-sdk.yml"
name: Generate SDK

on:
  push:
    branches: [main]
    paths: ['src/**', 'asyncapi.json']
  pull_request:
    paths: ['src/**', 'asyncapi.json']

env:
  ASYNCAPI_FILE: 'asyncapi.json'
  OUTPUT_PATH: 'generated-types.ts'

jobs:
  generate:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile

      - run: pnpm add -D @alt-stack/zod-asyncapi

      - name: Generate spec
        run: npm run generate-spec --if-present || true

      - name: Generate SDK
        run: npx zod-asyncapi ${{ env.ASYNCAPI_FILE }} -o ${{ env.OUTPUT_PATH }}

      - name: Check for changes
        id: changes
        run: |
          if git diff --quiet ${{ env.OUTPUT_PATH }}; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit changes
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'push'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ${{ env.OUTPUT_PATH }}
          git commit -m "chore: regenerate types [skip ci]"
          git push

      - name: Fail if outdated (PR)
        if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
        run: |
          echo "::error::Generated types are outdated. Run locally:"
          echo "npm run generate-spec && npx zod-asyncapi ${{ env.ASYNCAPI_FILE }} -o ${{ env.OUTPUT_PATH }}"
          exit 1
```

### Step 2: Create Your Kafka Router

```typescript title="src/router.ts"
import { init, kafkaRouter } from '@alt-stack/kafka-core';
import { z } from 'zod';

const { procedure } = init();

export const myRouter = kafkaRouter({
  userCreated: procedure
    .topic('user.created')
    .payload(z.object({
      userId: z.string(),
      email: z.string().email(),
      createdAt: z.string().datetime(),
    }))
    .handler(async ({ payload }) => {
      console.log('User created:', payload.userId);
    }),
});
```

### Step 3: Add Generate Script

```typescript title="src/generate-spec.ts"
import { writeFileSync } from 'fs';
import { generateAsyncAPISpec } from '@alt-stack/kafka-core';
import { myRouter } from './router';

const spec = generateAsyncAPISpec(myRouter, {
  title: 'My Kafka API',
  version: '1.0.0',
});

writeFileSync('asyncapi.json', JSON.stringify(spec, null, 2));
console.log('Generated asyncapi.json');
```

```json title="package.json"
{
  "scripts": {
    "generate-spec": "tsx src/generate-spec.ts",
    "generate-types": "npm run generate-spec && npx zod-asyncapi asyncapi.json -o generated-types.ts"
  }
}
```

## Publish SDK to npm

For publishing your SDK as a standalone npm package that consumers can install.

### Publish OpenAPI SDK

```yaml title=".github/workflows/publish-sdk.yml"
name: Publish SDK

on:
  push:
    branches: [main]
    paths: ['src/**']

env:
  OPENAPI_FILE: 'openapi.json'
  NPM_PACKAGE_NAME: '@my-org/my-api-sdk'

jobs:
  publish:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org/'

      - uses: pnpm/action-setup@v4

      - run: pnpm install --frozen-lockfile
      
      - run: pnpm add -D @alt-stack/zod-openapi

      - name: Generate spec
        run: npm run generate-spec

      - name: Generate SDK
        run: |
          mkdir -p sdk-package/src
          npx zod-openapi ${{ env.OPENAPI_FILE }} -o sdk-package/src/index.ts

      - name: Create package.json
        run: |
          VERSION=$(node -p "require('./package.json').version")
          cat > sdk-package/package.json << EOF
          {
            "name": "${{ env.NPM_PACKAGE_NAME }}",
            "version": "$VERSION",
            "type": "module",
            "main": "./dist/index.js",
            "types": "./dist/index.d.ts",
            "exports": {
              ".": {
                "types": "./dist/index.d.ts",
                "import": "./dist/index.js"
              }
            },
            "scripts": {
              "build": "tsup src/index.ts --format esm --dts"
            },
            "peerDependencies": {
              "zod": "^4.0.0"
            },
            "devDependencies": {
              "tsup": "^8.0.0",
              "typescript": "^5.0.0"
            }
          }
          EOF

      - name: Build and publish
        working-directory: sdk-package
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          pnpm install
          pnpm build
          npm publish --access public
```

### Required Secrets

Add `NPM_TOKEN` to your repository secrets:

1. Go to **Settings** → **Secrets and variables** → **Actions**
2. Click **New repository secret**
3. Name: `NPM_TOKEN`
4. Value: Your npm access token (from npmjs.com → Access Tokens)

## Using the Generated SDK

### In-Repo Types

```typescript
import { schemas, Request, Response } from './generated-types';

// Validate data
const user = schemas.User.parse(data);

// Type-safe request/response
type GetUserRequest = Request['GET /users/:id'];
type GetUserResponse = Response['GET /users/:id']['200'];
```

### Published SDK

```bash
pnpm add @my-org/my-api-sdk
```

```typescript
import { schemas, Request, Response } from '@my-org/my-api-sdk';

// Same usage as above
const user = schemas.User.parse(apiResponse);
```

## Local Development

Run the generation locally to test before pushing:

```bash
# Generate spec and types in one command
npm run generate-types

# Or step by step
npm run generate-spec
npx zod-openapi openapi.json -o generated-types.ts
```

## Best Practices

### Commit Both Spec and Types

Commit both your spec file (`openapi.json`/`asyncapi.json`) and generated types. This provides:
- Full history of API changes
- Easy diffing in PRs
- No runtime generation needed

### Version Synchronization

Keep your SDK version in sync with your API:

```yaml
- name: Read version
  id: version
  run: echo "version=$(node -p \"require('./package.json').version\")" >> $GITHUB_OUTPUT
```

### Conditional Publishing

Only publish when source files change:

```yaml
on:
  push:
    paths:
      - 'src/**'
      - '!src/**/*.test.ts'
```

### PR Validation

Fail PRs if generated types are outdated to catch schema changes:

```yaml
- name: Fail if outdated
  if: steps.changes.outputs.changed == 'true' && github.event_name == 'pull_request'
  run: exit 1
```

## Troubleshooting

### Spec Not Generating

- Check your `generate-spec` script is defined in package.json
- Ensure the router is exported correctly
- Verify all dependencies are installed

### Types Not Generating

- Check the spec file exists and is valid JSON
- Ensure `@alt-stack/zod-openapi` or `@alt-stack/zod-asyncapi` is installed
- Check for syntax errors in the spec

### npm Publish Failing

- Verify `NPM_TOKEN` secret is set correctly
- Check the package name is available on npm
- Ensure version hasn't already been published

---

// File: guides/client-side-usage

# Client-Side Usage

When making requests from the client, include credentials to support authentication cookies.

## Using Hono Client

Use the Hono client (`hc`) for type-safe API calls:

```typescript
import { hc } from "hono/client";

const client = hc("http://localhost:3000", {
  init: {
    credentials: "include", // Required for auth cookies
  },
});

// Make authenticated requests
const response = await client.api.users.profile.$get();
```

## Fetch with Credentials

When using standard `fetch`, ensure credentials are included:

```typescript
const response = await fetch("http://localhost:3000/api/users/profile", {
  method: "GET",
  credentials: "include", // Required for auth cookies
  headers: {
    "Content-Type": "application/json",
  },
});

const data = await response.json();
```

## Type-Safe API Calls

The Hono client provides type inference from your router definitions. The client automatically knows:

- Available routes
- Request methods
- Input types (params, query, body)
- Output types
- Error types

```typescript
// TypeScript knows this route exists and what it expects
const response = await client.api.users["{id}"].$get({
  param: {
    id: "123",
  },
  query: {
    include: "profile",
  },
});

// response.data is typed based on your output schema
console.log(response.data.name); // ✅ TypeScript knows this exists
```

## Error Handling

Handle errors type-safely:

```typescript
try {
  const response = await client.api.users["{id}"].$get({
    param: { id: "123" },
  });
  
  if (!response.ok) {
    // Handle error response
    const error = await response.json();
    console.error(error);
  }
} catch (error) {
  // Handle network errors
  console.error("Request failed:", error);
}
```

---

// File: guides/cors-configuration

# CORS Configuration

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call.

## Recommended: Global CORS with Better Auth

For most applications, applying CORS globally with credentials support works best:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth, getAuthUser } from "./auth.js";
import { todosRouter } from "./routes/todos.js";
import type { Context } from "hono";

// Create base app
const app = new Hono();

// Apply CORS globally (must be before routes)
app.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true, // Required for Better Auth cookies
  exposeHeaders: ["Set-Cookie"],
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create server framework app with context
interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return { user };
}

const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Mount server framework routes
app.route("/", serverApp);

export default app;
```

## Using Middleware Option

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call:

```typescript
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server with CORS and Better Auth routes
const app = createServer(
  {
    todos: todosRouter,
  },
  {
    createContext,
    middleware: {
      // Apply CORS globally
      "*": {
        methods: ["OPTIONS", "GET", "POST", "PUT", "PATCH", "DELETE"],
        handler: cors({
          origin: process.env.CLIENT_URL || "http://localhost:3000",
          allowHeaders: ["Content-Type", "Authorization"],
          allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
          credentials: true, // Required for Better Auth cookies
          exposeHeaders: ["Set-Cookie"],
        }) as any, // Type assertion for CORS middleware
      },
      // Mount Better Auth routes
      "/api/auth/*": {
        methods: ["GET", "POST"],
        handler: async (c) => auth.handler(c.req.raw),
      },
    },
  },
);

export default app;
```

**Key Points:**
- The `"*"` path applies middleware globally to all routes (framework and mounted routes)
- For `"*"` paths, the handler can be a Hono middleware function (like `cors()`) or a regular handler
- Other paths mount specific route handlers (like Better Auth)
- Middleware is applied before framework routes, ensuring CORS headers are set correctly

## Manual Setup

If you need more control, you can still apply CORS manually after `createServer`:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

const app = new Hono();

// Apply CORS specifically to Better Auth routes
app.use("/api/auth/*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "OPTIONS"],
  credentials: true,
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create and mount server framework routes
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

app.route("/", serverApp);

export default app;
```

## CORS Only for Server Framework Routes

Apply CORS to server framework routes only:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server framework app
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Apply CORS to server framework routes
serverApp.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true,
}));

const app = new Hono();

// Mount Better Auth routes (no CORS needed if same origin)
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount server framework routes with CORS
app.route("/", serverApp);

export default app;
```

---

// File: guides/openapi-documentation

# OpenAPI Documentation

Automatically generate and serve OpenAPI 3.0 documentation for your API using Zod 4's native `toJSONSchema()` function.

## Quick Start

Use `createDocsRouter` to automatically generate and serve OpenAPI documentation:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const apiRouter = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "Alice",
    email: "alice@example.com",
  }))
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
  }));

// Create docs router
const docsRouter = createDocsRouter(
  { api: apiRouter },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Mount both routers
const app = createServer({
  api: apiRouter,
  docs: docsRouter,
});
```

Now you can access:
- OpenAPI JSON spec at `/docs/openapi.json` (path determined by mount prefix `docs`)
- Interactive Swagger UI at `/docs` (path determined by mount prefix `docs`)

## Basic Usage

The `createDocsRouter` function takes the same router configuration as `createServer`, allowing it to automatically discover all your routes and generate complete OpenAPI documentation.

```typescript
import { init, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const router = factory.router()
  .get("/items", {
    input: {},
    output: z.array(z.object({ id: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter({ api: router });
```

## Customization Options

Customize paths, metadata, and enable/disable features:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    // OpenAPI metadata
    title: "Todo API",
    version: "2.0.0",
    description: "A simple todo API",
    
    // Custom OpenAPI spec path
    openapiPath: "openapi.json", // Default: "openapi.json"
    // Note: The docs path is determined by the router prefix when mounting in createServer
    
    // Enable/disable interactive docs
    enableDocs: true, // Default: true
  }
);
```

## Integration with createServer

The docs router integrates seamlessly with `createServer`:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const todosRouter = factory.router()
  .get("/", {
    input: {},
    output: z.array(z.object({ id: z.string(), title: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter(
  { todos: todosRouter },
  {
    title: "Todo API",
    version: "1.0.0",
  }
);

const app = createServer({
  todos: todosRouter,
  docs: docsRouter,
});
```

With this setup:
- API routes are available at `/todos/*`
- Documentation is available at `/docs/*`

## Manual OpenAPI Spec Generation

If you need the OpenAPI spec object directly (e.g., for external tools or custom documentation), use `generateOpenAPISpec`:

```typescript
import { generateOpenAPISpec } from "@alt-stack/server-hono";

const spec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Use the spec with external tools
console.log(JSON.stringify(spec, null, 2));
```

## What Gets Documented

The OpenAPI documentation automatically includes:

- **All routes** from your routers
- **Path parameters** (e.g., `/{id}`)
- **Query parameters** from query schemas
- **Request bodies** for POST/PUT/PATCH operations
- **Response schemas** from output schemas
- **Error responses** from error schemas
- **Operation IDs** automatically generated from route paths

## Example: Complete API Documentation

Here's a complete example with multiple route types:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  // GET with path and query params
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.string().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "John",
    email: "john@example.com",
  }))
  
  // POST with body
  .post("/users", {
    input: {
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
    email: ctx.input.email,
  }))
  
  // PATCH with path params and body
  .patch("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      body: z.object({
        name: z.string().optional(),
        email: z.string().email().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: ctx.input.name || "John",
    email: ctx.input.email || "john@example.com",
  }))
  
  // DELETE
  .delete("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      success: z.boolean(),
    }),
  })
  .handler(() => ({ success: true }));

const docsRouter = createDocsRouter({ api: router });
const app = createServer({ api: router, docs: docsRouter });
```

All routes are automatically documented with proper OpenAPI 3.0 schemas.

## Disabling Interactive Docs

If you only need the JSON spec (e.g., for external tools), disable the HTML docs:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    enableDocs: false, // Only serve /openapi.json, not /docs
  }
);
```

## How It Works

The OpenAPI generation uses Zod 4's native `toJSONSchema()` function with the `openapi-3.0` target. This means:

- All Zod schemas are automatically converted to JSON Schema
- Complex types (objects, arrays, unions, etc.) are properly documented
- String formats (email, UUID, URL, etc.) are recognized
- Validation constraints are included in the schema

The generated OpenAPI spec is fully compliant with OpenAPI 3.0 specification and can be used with any OpenAPI-compatible tools.

---

// File: guides/openapi-to-typescript

# OpenAPI to TypeScript

Generate TypeScript types and Zod schemas from OpenAPI specifications using the `zod-openapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-openapi
# or
npm install @alt-stack/zod-openapi
```

## CLI Usage

```bash
npx zod-openapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-openapi openapi.json

# Generate from URL (e.g., from your running server)
npx zod-openapi http://localhost:3000/docs/openapi.json

# Specify output file
npx zod-openapi openapi.json -o src/api-types.ts
```

## Generated Output

Given an OpenAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Request schemas** for params, query, headers, and body
- **Response schemas** for all status codes
- **Lookup objects** (`Request` and `Response`) for easy access

### Example

For an OpenAPI spec with a `User` schema and `/users/{id}` endpoint:

```typescript
/**
 * This file was automatically generated from OpenAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

export const GetUsersIdParams = z.object({ id: z.string() });
export const GetUsersId200Response = UserSchema;

export const Request = {
  '/users/{id}': {
    GET: {
      params: GetUsersIdParams,
    },
  },
} as const;

export const Response = {
  '/users/{id}': {
    GET: {
      '200': GetUsersId200Response,
    },
  },
} as const;
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToOpenApiSchema } from "@alt-stack/zod-openapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToOpenApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-openapi openapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/api-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Integration with @alt-stack/server

A typical workflow with `@alt-stack/server-hono`:

1. **Define your API** with Zod schemas on the server
2. **Generate OpenAPI spec** using `createDocsRouter`
3. **Generate client types** using the `zod-openapi` CLI

```bash
# Fetch OpenAPI from your running server and generate types
npx zod-openapi http://localhost:3000/docs/openapi.json -o src/api-types.ts
```

This gives you fully typed request/response schemas that match your server's API exactly.

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";

const openApiSpec = {
  components: {
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
  paths: {
    "/users/{id}": {
      get: {
        parameters: [
          { name: "id", in: "path", required: true, schema: { type: "string" } },
        ],
        responses: {
          "200": {
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/User" },
              },
            },
          },
        },
      },
    },
  },
};

const generatedCode = openApiToZodTsCode(
  openApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
  { includeRoutes: true }
);

console.log(generatedCode);
```

---

// File: guides/protected-routes

# Protected Routes

Follow the tRPC authorization pattern for type-safe protected routes. The middleware can pass an updated context to `next()` to narrow types.

## Reusable Procedures Pattern (Recommended)

The recommended way to create protected routes is using reusable procedures:

```typescript
import { router, publicProcedure, init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    return next({
      ctx: {
        user: ctx.user,
      },
    });
  });

// Use procedures to create routes
export const appRouter = router({
  hello: publicProc.get(() => "hello world"),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => ({
      secret: "sauce",
    })),
});

const app = createServer({ api: appRouter });
```

See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for more details.

## Procedure-Level Middleware Pattern

The middleware can narrow the context type by passing an updated context to `next()`:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string; name: string } | null;
}

const factory = init<AppContext>();

export const protectedRouter = router({
  profile: factory.procedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
        name: z.string(),
      })
    )
    .errors({
      401: z.object({
        error: z.object({
          code: z.literal("UNAUTHORIZED"),
          message: z.string(),
        }),
      }),
    })
    .use(async function isAuthed(opts) {
      const { ctx, next } = opts;
      // `ctx.user` is nullable
      if (!ctx.user) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        });
      }
      // ✅ Pass updated context where user is non-null (tRPC pattern)
      // This allows the context to have user as non-null for subsequent handlers
      return next({
        ctx: {
          user: ctx.user, // ✅ user value is known to be non-null now
        },
      });
    })
    .get((opts) => {
      // ✅ opts.ctx.user is now guaranteed to be non-null after the middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
        name: ctx.user!.name,
      };
    }),
});
```

## Mixed Public and Protected Routes

You can mix public and protected routes in the same router:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

export const appRouter = router({
  public: publicProc.get(() => ({ message: "Public content" })),

  private: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
      })
    )
    .get((opts) => {
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
      };
    }),
});
```

## Role-Based Access Control

You can validate user roles, permissions, or other attributes:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string; permissions: string[] } | null;
}

const factory = init<AppContext>();

// Middleware that requires specific role
const requireRole = (role: "admin" | "user" | "moderator") => {
  return factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user) {
      return new Response("Unauthorized", { status: 401 });
    }
    if (ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next({ ctx: { user: ctx.user } });
  });
};

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  users: adminProcedure
    .input({})
    .output(z.array(z.object({ id: z.string(), name: z.string() })))
    .get(() => {
      return getAllUsers();
    }),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post(() => {
      return { success: true };
    }),
});
```

## Type-Safe User Context

For better type safety, use Zod's type inference to create authenticated context types:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

// Your validated user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  role: z.enum(["admin", "user", "moderator"]),
  permissions: z.array(z.string()),
});

type User = z.infer<typeof UserSchema>;

interface AppContext {
  user: User | null;
}

const factory = init<AppContext>();

const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Optionally re-validate to ensure type safety
  const validatedUser = UserSchema.parse(ctx.user);

  // Return context with validated user
  return next({ ctx: { user: validatedUser } });
});

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .output(UserSchema)
    .get((opts) => {
      // opts.ctx.user is validated and typed
      const { ctx } = opts;
      return ctx.user!;
    }),
});
```

---

// File: guides/telemetry

# OpenTelemetry Integration

Altstack servers support [OpenTelemetry](https://opentelemetry.io/) for distributed tracing with minimal configuration. When enabled, every request is automatically traced with semantic HTTP attributes.

## Installation

First, install the OpenTelemetry packages:

```bash
pnpm add @opentelemetry/api @opentelemetry/sdk-trace-node @opentelemetry/exporter-trace-otlp-http
```

## Quick Start

Enable telemetry by passing `telemetry: true` to `createServer`:

```typescript
import { createServer, router, init } from "@alt-stack/server-hono";

const { procedure } = init<AppContext>();

const appRouter = router({
  "/todos": procedure
    .output(z.array(TodoSchema))
    .get(async () => {
      return await db.todos.findMany();
    }),
});

const app = createServer({ api: appRouter }, {
  createContext,
  telemetry: true, // Enable OpenTelemetry
});
```

## Configuration Options

For more control, pass a configuration object:

```typescript
const app = createServer({ api: appRouter }, {
  createContext,
  telemetry: {
    enabled: true,
    serviceName: "my-api",           // Custom service name (default: "altstack-server")
    ignoreRoutes: ["/health", "/metrics"], // Routes to skip tracing
  },
});
```

### Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable/disable telemetry |
| `serviceName` | `string` | `"altstack-server"` | Service name for traces |
| `ignoreRoutes` | `string[]` | `[]` | Routes to exclude from tracing |

## Span Attributes

Each request span includes these attributes following [OpenTelemetry HTTP semantic conventions](https://opentelemetry.io/docs/specs/semconv/http/http-spans/):

| Attribute | Example | Description |
|-----------|---------|-------------|
| `http.request.method` | `GET` | HTTP method |
| `http.route` | `/api/todos/{id}` | Route pattern (with path params) |
| `url.path` | `/api/todos/123` | Actual URL path |
| `http.response.status_code` | `200` | Response status code |

## Custom Spans and Attributes

Access the current span via `ctx.span` to add custom attributes or events:

```typescript
const todoRouter = router({
  "/todos/{id}": procedure
    .input({ params: z.object({ id: z.string() }) })
    .get(async ({ input, ctx }) => {
      // Add custom attributes
      ctx.span?.setAttribute("todo.id", input.params.id);
      
      // Add events for significant operations
      ctx.span?.addEvent("db-query-start");
      const todo = await db.todos.findUnique({ 
        where: { id: input.params.id } 
      });
      ctx.span?.addEvent("db-query-end");
      
      return todo;
    }),
});
```

## Setting Up the OTel SDK

Before your server starts, initialize the OpenTelemetry SDK. Here's a typical setup:

```typescript
// tracing.ts - import this before your server starts
import { NodeSDK } from "@opentelemetry/sdk-node";
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http";
import { Resource } from "@opentelemetry/resources";
import { ATTR_SERVICE_NAME } from "@opentelemetry/semantic-conventions";

const sdk = new NodeSDK({
  resource: new Resource({
    [ATTR_SERVICE_NAME]: "my-api",
  }),
  traceExporter: new OTLPTraceExporter({
    url: "http://localhost:4318/v1/traces", // OTLP HTTP endpoint
  }),
});

sdk.start();

// Graceful shutdown
process.on("SIGTERM", () => {
  sdk.shutdown().then(() => process.exit(0));
});
```

Then import this file at the top of your main entry point:

```typescript
// index.ts
import "./tracing.js"; // Must be first!
import { createServer } from "@alt-stack/server-hono";
// ... rest of your server code
```

## Example with Jaeger

To visualize traces locally with [Jaeger](https://www.jaegertracing.io/):

1. Run Jaeger with Docker:

```bash
docker run -d --name jaeger \
  -p 16686:16686 \
  -p 4318:4318 \
  jaegertracing/all-in-one:latest
```

2. Configure the OTLP exporter to send to Jaeger:

```typescript
const sdk = new NodeSDK({
  traceExporter: new OTLPTraceExporter({
    url: "http://localhost:4318/v1/traces",
  }),
});
```

3. View traces at http://localhost:16686

## Works with Both Adapters

Telemetry works identically with both Hono and Express adapters:

```typescript
// Hono
import { createServer } from "@alt-stack/server-hono";
const app = createServer({ api: router }, { telemetry: true });

// Express
import { createServer } from "@alt-stack/server-express";
const app = createServer({ api: router }, { telemetry: true });
```

## Graceful Degradation

If `@opentelemetry/api` is not installed, telemetry is silently disabled. This allows you to:

- Use the same code in development (without OTel) and production (with OTel)
- Keep `@opentelemetry/api` as a dev dependency in some environments

The `ctx.span` will be `undefined` when telemetry is disabled or not installed, so always use optional chaining:

```typescript
ctx.span?.setAttribute("key", "value"); // Safe even without OTel
```

---

// File: intro

# Introduction

Altstack is a type-safe full-stack framework with separate server and client packages, built with Zod validation. Inspired by tRPC's builder pattern, providing full type inference from a central router definition.

## Architecture

Altstack's server framework is split into a core package and framework-specific adapters:

### Server Packages

- **`@alt-stack/server-core`**: Framework-agnostic core containing types, router, middleware, and validation logic. Used as a dependency by the adapter packages.

- **`@alt-stack/server-hono`**: [Hono](https://hono.dev/) adapter - creates a Hono app with full type inference. **Recommended for new projects.**

- **`@alt-stack/server-express`**: [Express](https://expressjs.com/) adapter - creates an Express app with the same type-safe API.

### Client Packages

- **`@alt-stack/http-client-fetch`**: Type-safe API client using native fetch
- **`@alt-stack/http-client-ky`**: Type-safe API client using ky library

## Choosing an Adapter

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards) | Mature ecosystem |
| Edge/Serverless | Native support | Requires adapters |
| Context access | `ctx.hono` | `ctx.express.req/res` |
| Best for | New projects, edge | Existing Express apps |

## Server Features

- **Type-safe routes**: Full TypeScript inference from Zod schemas
- **Builder pattern**: Fluent API for defining routes with `.get()`, `.post()`, etc.
- **Type-safe errors**: `ctx.error()` with automatic status code inference from error schemas
- **Reusable procedures**: Create reusable procedures with middleware (tRPC-style pattern)
- **Middleware support**: Procedure-level middleware with context extension
- **Router combination**: Merge multiple routers with `.merge()`
- **Validation**: Automatic Zod validation for inputs and optional outputs
- **OpenAPI generation**: Generate OpenAPI specs and interactive Swagger UI
- **Native framework access**: Full access to underlying framework APIs

## Client Features

- **Type-safe API calls**: Full TypeScript inference from server-generated types
- **Automatic validation**: Runtime validation using Zod schemas
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters
- **Error handling**: Typed error responses with detailed error information

## Quick Example

```typescript
import { init, createServer, router } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();

const appRouter = router({
  "/hello": factory.procedure
    .output(z.object({ message: z.string() }))
    .get(() => ({ message: "Hello, World!" })),
});

const app = createServer({ api: appRouter });
export default app;
```

---

// File: kafka/core-concepts/combining-routers

# Combining Routers

Organize consumers by domain using nested routers.

## Nested Routers

Use nested `kafkaRouter` for topic prefixing:

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";

const { procedure } = init<AppContext>();

const userRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: UserCreatedSchema }).subscribe(handleUserCreated),
  updated: procedure.input({ message: UserUpdatedSchema }).subscribe(handleUserUpdated),
});

const orderRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: OrderCreatedSchema }).subscribe(handleOrderCreated),
  cancelled: procedure.input({ message: OrderCancelledSchema }).subscribe(handleOrderCancelled),
});

// Topics become: users/created, users/updated, orders/created, orders/cancelled
const mainRouter = kafkaRouter<AppContext>({
  users: userRouter,
  orders: orderRouter,
});
```

## Merging Flat Routers

Use `mergeKafkaRouters` to combine routers without prefixing:

```typescript
import { mergeKafkaRouters } from "@alt-stack/kafka-core";

const router1 = kafkaRouter({
  "user-events": procedure.input({ message: UserSchema }).subscribe(() => {}),
});

const router2 = kafkaRouter({
  "order-events": procedure.input({ message: OrderSchema }).subscribe(() => {}),
});

// Topics remain: user-events, order-events (no prefix)
const mainRouter = mergeKafkaRouters(router1, router2);
```

## Using init() Factory

```typescript
const { router, mergeRouters, procedure } = init<AppContext>();

const r1 = router();
r1.registerProcedure("events", procedure.input({ message: Schema }).subscribe(() => {}));

const r2 = router();
r2.registerProcedure("other", procedure.input({ message: Schema }).subscribe(() => {}));

const merged = mergeRouters(r1, r2);
```

---

// File: kafka/core-concepts/consumers

# Consumers

Create Kafka consumers from routers.

## Basic Setup

```typescript
import { createConsumer, kafkaRouter, init } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: z.object({ userId: z.string() }) })
    .subscribe(({ input }) => {
      console.log(input.userId);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-app",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});

// Consumer is connected and running
```

## Kafka Config Options

Pass config directly instead of a Kafka instance:

```typescript
const consumer = await createConsumer(router, {
  kafka: {
    clientId: "my-app",
    brokers: ["localhost:9092"],
    ssl: true,
    sasl: {
      mechanism: "plain",
      username: "user",
      password: "pass",
    },
  },
  groupId: "my-consumer-group",
});
```

## Consumer Options

```typescript
const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-consumer-group",
  consumerConfig: {
    sessionTimeout: 30000,
    heartbeatInterval: 3000,
    maxBytesPerPartition: 1048576,
  },
  createContext: (baseCtx) => ({ logger: getLogger() }),
  onError: (error) => console.error("Consumer error:", error),
});
```

## Graceful Shutdown

```typescript
const consumer = await createConsumer(router, options);

process.on("SIGTERM", async () => {
  await consumer.disconnect();
  process.exit(0);
});
```

---

// File: kafka/core-concepts/custom-context

# Custom Context

Extend the base context with application-specific properties.

## Base Context

Every handler receives:

```typescript
interface BaseKafkaContext {
  message: KafkaMessage; // Full kafkajs message (value, key, headers, timestamp)
  topic: string;
  partition: number;
  offset: string;
}
```

## Defining Custom Context

```typescript
import { init, kafkaRouter, createConsumer, type BaseKafkaContext } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
  db: Database;
}

// Initialize with context type
const { procedure } = init<AppContext>();

const router = kafkaRouter<AppContext>({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx has logger, db, plus base context
      ctx.logger.log(`Processing user ${input.userId}`);
      ctx.db.save(input);
    }),
});
```

## Creating Context

Provide `createContext` to the consumer:

```typescript
function createContext(baseCtx: BaseKafkaContext): AppContext {
  return {
    logger: {
      log: (msg: string) =>
        console.log(`[${baseCtx.topic}:${baseCtx.partition}] ${msg}`),
    },
    db: getDatabase(),
  };
}

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  createContext,
});
```

## Async Context

```typescript
async function createContext(baseCtx: BaseKafkaContext): Promise<AppContext> {
  const db = await getConnectionFromPool();
  return { logger: getLogger(), db };
}
```

## Middleware Context Extension

Middleware can add to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await authenticate(ctx.message.headers);
  return next({ ctx: { user } });
});

const router = kafkaRouter<AppContext>({
  protected: authMiddleware
    .input({ message: Schema })
    .subscribe(({ ctx }) => {
      // ctx.user is available
    }),
});
```

---

// File: kafka/core-concepts/error-handling

# Error Handling

Define typed error schemas using the Result pattern.

## Error Schemas

```typescript
import { init, kafkaRouter, ok, err } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "process-order": procedure
    .input({
      message: z.object({
        orderId: z.string(),
        amount: z.number(),
      }),
    })
    .errors({
      INVALID_ORDER: z.object({
        error: z.object({
          code: z.literal("INVALID_ORDER"),
          message: z.string(),
          orderId: z.string(),
        }),
      }),
      INSUFFICIENT_FUNDS: z.object({
        error: z.object({
          code: z.literal("INSUFFICIENT_FUNDS"),
          message: z.string(),
          required: z.number(),
          available: z.number(),
        }),
      }),
    })
    .subscribe(({ input }) => {
      if (!isValidOrder(input.orderId)) {
        return err({
          data: {
            error: {
              code: "INVALID_ORDER" as const,
              message: "Order not found",
              orderId: input.orderId,
            },
          },
        });
      }

      const available = getAvailableFunds();
      if (input.amount > available) {
        return err({
          data: {
            error: {
              code: "INSUFFICIENT_FUNDS" as const,
              message: "Insufficient funds",
              required: input.amount,
              available,
            },
          },
        });
      }

      processOrder(input);
      return ok();
    }),
});
```

## Consumer Error Handling

```typescript
import { createConsumer, ProcessingError } from "@alt-stack/kafka-core";

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  onError: (error) => {
    if (error instanceof ProcessingError) {
      console.error("Processing error:", error.code, error.details);
      sendToDeadLetterQueue(error);
    } else {
      console.error("Unexpected error:", error);
    }
  },
});
```

## Result Pattern

Handlers return `Result<Errors, Output>`:

```typescript
import { ok, err, isOk, isErr } from "@alt-stack/kafka-core";

// Success
return ok({ processed: true });

// Success with void
return ok();

// Error
return err({
  data: {
    error: { code: "FAILED" as const, message: "Processing failed" },
  },
});
```

## Error Types

The library exports:

- `KafkaError` - Base error class with `code`, `message`, and optional `details`
- `ValidationError` - Schema validation failures
- `ProcessingError` - Handler execution errors

---

// File: kafka/core-concepts/middleware

# Middleware

Add cross-cutting concerns like logging, metrics, or authentication.

## Basic Middleware

```typescript
const { procedure } = init();

const loggedProcedure = procedure.use(async ({ ctx, next }) => {
  console.log(`Processing message from ${ctx.topic}`);
  const result = await next();
  console.log(`Completed processing`);
  return result;
});

const router = kafkaRouter({
  events: loggedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input }) => {
      // Logging middleware runs before/after this
    }),
});
```

## Context Extension

Middleware can add properties to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await getUserFromMessage(ctx.message);
  return next({ ctx: { user } });
});

const router = kafkaRouter({
  "protected-events": authMiddleware
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx.user is available and typed
      console.log(`User: ${ctx.user.name}`);
    }),
});
```

## Reusable Middleware with createMiddleware

```typescript
import { createMiddleware } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
}

const metricsMiddleware = createMiddleware<AppContext>()(async ({ ctx, next }) => {
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  metrics.recordDuration(ctx.topic, duration);
  return result;
});
```

## Chaining Middleware

```typescript
const { procedure } = init<AppContext>();

const protectedProcedure = procedure
  .use(loggingMiddleware)
  .use(authMiddleware)
  .use(metricsMiddleware);

// All three middleware run in order
const router = kafkaRouter({
  events: protectedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {}),
});
```

## Piping Middleware Builders

```typescript
const authChain = createMiddleware<AppContext>()
  .pipe(validateSession)
  .pipe(loadUser);

// Use the chain
const protectedProcedure = procedure.use(authChain);
```

---

// File: kafka/core-concepts/producers

# Producers

Create type-safe Kafka producers using AsyncAPI-generated types.

## Installation

```bash
# Core + KafkaJS binding
pnpm add @alt-stack/kafka-client-core @alt-stack/kafka-client-kafkajs kafkajs zod

# Or for WarpStream
pnpm add @alt-stack/kafka-client-core @alt-stack/kafka-client-warpstream kafkajs zod
```

## Basic Setup

Use types generated from your AsyncAPI spec with `zod-asyncapi`:

```typescript
// 1. Generate types from AsyncAPI spec
// npx zod-asyncapi asyncapi.json -o ./generated-types.ts

// 2. Import generated types
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

// 3. Create type-safe client
const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// 4. Send messages with full type safety
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

## KafkaJS Client

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: {
    brokers: ["localhost:9092"],
    clientId: "my-app",
    ssl: true,
    sasl: { mechanism: "plain", username: "user", password: "pass" },
  },
  topics: Topics,
  producerConfig: {
    allowAutoTopicCreation: false,
  },
  onError: (error) => console.error("Producer error:", error),
});
```

## WarpStream Client

Optimized for WarpStream with recommended defaults (LZ4 compression, extended timeouts):

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
  clientId: "my-producer",
});
```

## Type-Safe Sending

```typescript
// TypeScript enforces valid topics and message shapes
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});

// Type error: "invalid-topic" doesn't exist
await client.send("invalid-topic", { data: "test" });

// Type error: missing required field
await client.send("user-events", { userId: "123" });
```

## Batch Sending

```typescript
await client.sendBatch("user-events", [
  { userId: "user-1", eventType: "created", timestamp: Date.now() },
  { userId: "user-2", eventType: "created", timestamp: Date.now() },
  { userId: "user-1", eventType: "updated", timestamp: Date.now() },
]);
```

## Send Options

```typescript
await client.send(
  "user-events",
  { userId: "123", eventType: "created", timestamp: Date.now() },
  {
    key: "user-123",              // Message key for partitioning
    partition: 0,                 // Explicit partition
    headers: { source: "api" },   // Custom headers
    timestamp: Date.now().toString(),
  }
);
```

## Disconnecting

```typescript
await client.disconnect();
```

## Accessing Raw Producer

For advanced use cases (transactions, producer events, etc.), access the underlying KafkaJS producer:

```typescript
// Access the raw kafkajs Producer
const rawProducer = client.producer;

// Use kafkajs features directly
await rawProducer.send({
  topic: "my-topic",
  messages: [{ value: "raw message" }],
  acks: -1,
  timeout: 30000,
});
```

## Error Handling

```typescript
import { ValidationError, SendError, ConnectionError } from "@alt-stack/kafka-client-kafkajs";

try {
  await client.send("user-events", invalidData);
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Invalid message:", error.topic, error.details);
  } else if (error instanceof SendError) {
    console.error("Failed to send:", error.topic, error.cause);
  } else if (error instanceof ConnectionError) {
    console.error("Connection failed:", error.cause);
  }
}
```

---

// File: kafka/core-concepts/topics-and-procedures

# Topics and Procedures

Define Kafka topics with type-safe message schemas using `kafkaRouter`.

## Basic Topic Definition

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({
      message: z.object({
        userId: z.string(),
        eventType: z.string(),
      }),
    })
    .subscribe(({ input }) => {
      // input is the validated message
      console.log(input.userId);
    }),
});
```

## Message Validation

Messages are validated before the handler runs:

```typescript
const router = kafkaRouter({
  orders: procedure
    .input({
      message: z.object({
        orderId: z.string().uuid(),
        amount: z.number().positive(),
        currency: z.string().length(3),
      }),
    })
    .subscribe(({ input }) => {
      // Only called if message passes validation
      processOrder(input);
    }),
});
```

## Multiple Topics

```typescript
const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input }) => handleUserEvent(input)),

  "order-events": procedure
    .input({ message: OrderEventSchema })
    .subscribe(({ input }) => handleOrderEvent(input)),
});
```

## Output Validation

Optionally validate handler return values:

```typescript
const router = kafkaRouter({
  "process-data": procedure
    .input({
      message: z.object({ data: z.string() }),
    })
    .output(
      z.object({
        processed: z.boolean(),
        result: z.string(),
      })
    )
    .subscribe(({ input }) => ({
      processed: true,
      result: input.data.toUpperCase(),
    })),
});
```

## subscribe vs handler

- `.subscribe()` - Use in `kafkaRouter({})` config (topic determined by key)
- `.handler()` - Creates a pending procedure for manual registration

```typescript
// Using subscribe (recommended)
const router = kafkaRouter({
  "my-topic": procedure.input({ message: Schema }).subscribe(({ input }) => {}),
});

// Using handler for manual registration
const pendingProc = procedure.input({ message: Schema }).handler(({ input }) => {});
const router = createKafkaRouter();
router.registerPendingProcedure("my-topic", pendingProc);
```

---

// File: kafka/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/kafka-core kafkajs zod
```

## Peer Dependencies

- **kafkajs**: `^2.0.0` - Kafka client
- **zod**: `^3.25.0` - Schema validation

---

// File: kafka/getting-started/quickstart

# Quickstart

## Consumer

```typescript
import { init, kafkaRouter, createConsumer } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";
import { z } from "zod";

const UserEventSchema = z.object({
  userId: z.string(),
  eventType: z.enum(["created", "updated", "deleted"]),
  timestamp: z.number(),
});

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      console.log(`Event: ${input.eventType} for user ${input.userId}`);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-consumer",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});
```

## Producer (using Kafka Client)

For producers, use the Kafka client packages with AsyncAPI-generated types:

```typescript
// 1. Generate types: npx zod-asyncapi asyncapi.json -o ./generated-types.ts
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

Or with WarpStream:

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

---

// File: real-life/auth-service

# Auth Service

The authentication service handles user registration, login, and session management.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| POST | `/api/signup` | Register new user |
| POST | `/api/login` | Authenticate user |
| POST | `/api/logout` | Invalidate session |
| GET | `/api/me` | Get current user |
| GET | `/api/validate` | Validate token (internal) |

## Implementation

```typescript title="apps/backend-auth/src/index.ts"
import { createDocsRouter, createServer, init, router, type HonoBaseContext } from "@alt-stack/server-hono";
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
});

const SessionSchema = z.object({
  token: z.string(),
  userId: z.string(),
  expiresAt: z.string().datetime(),
});

const factory = init<HonoBaseContext>();
const publicProc = factory.procedure;

const authRouter = router<HonoBaseContext>({
  "/signup": publicProc
    .input({
      body: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string().min(1),
      }),
    })
    .output(z.object({ user: UserSchema, session: SessionSchema }))
    .errors({
      409: z.object({ error: z.object({ code: z.literal("EMAIL_EXISTS"), message: z.string() }) }),
    })
    .post(({ input, ctx }) => {
      // Check if email exists, create user, create session
      // ...
    }),

  "/login": publicProc
    .input({
      body: z.object({
        email: z.string().email(),
        password: z.string(),
      }),
    })
    .output(z.object({ user: UserSchema, session: SessionSchema }))
    .errors({
      401: z.object({ error: z.object({ code: z.literal("INVALID_CREDENTIALS"), message: z.string() }) }),
    })
    .post(({ input, ctx }) => {
      // Verify credentials, create session
      // ...
    }),

  // Internal endpoint for other services to validate tokens
  "/validate": publicProc
    .output(z.object({ valid: z.boolean(), userId: z.string().optional() }))
    .get(({ ctx }) => {
      const auth = ctx.hono.req.header("Authorization") ?? "";
      const token = auth.replace("Bearer ", "");
      const session = sessions.get(token);
      if (!session || session.expiresAt < new Date()) {
        return { valid: false };
      }
      return { valid: true, userId: session.userId };
    }),
});
```

## Token Validation Endpoint

The `/validate` endpoint is designed for service-to-service communication. Other services can call it to verify tokens without implementing token parsing themselves.

```typescript
// In backend-logic
async function validateToken(token: string): Promise<string | null> {
  const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
    headers: { authorization: token },
  }).json<{ valid: boolean; userId?: string }>();
  
  return res.valid ? (res.userId ?? null) : null;
}
```

## Generating the OpenAPI Spec

```typescript title="apps/backend-auth/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateOpenAPISpec } from "@alt-stack/server-hono";
import { authRouter } from "./index.js";

const spec = generateOpenAPISpec({ api: authRouter }, {
  title: "Auth API",
  version: "1.0.0",
});

writeFileSync("openapi.json", JSON.stringify(spec, null, 2));
console.log("Generated openapi.json");
```

Run with:
```bash
pnpm --filter @real-life/backend-auth generate
```

---

// File: real-life/frontend

# Frontend

NextJS app consuming both backend services via generated SDKs.

## API Client

The frontend uses `@alt-stack/http-client-ky` for type-safe HTTP requests with SDK schemas:

```typescript title="apps/web/src/lib/api.ts"
import { createApiClient } from "@alt-stack/http-client-ky";
import { Request as AuthRequest, Response as AuthResponse } from "@real-life/backend-auth-sdk";
import { Request as LogicRequest, Response as LogicResponse } from "@real-life/backend-logic-sdk";

const AUTH_URL = process.env.NEXT_PUBLIC_AUTH_URL || "http://localhost:3001";
const LOGIC_URL = process.env.NEXT_PUBLIC_LOGIC_URL || "http://localhost:3002";

// Create type-safe clients
const authClient = createApiClient({
  baseUrl: AUTH_URL,
  Request: AuthRequest,
  Response: AuthResponse,
});

const logicClient = createApiClient({
  baseUrl: LOGIC_URL,
  Request: LogicRequest,
  Response: LogicResponse,
});

// Auth API
export const authApi = {
  async login(data: { email: string; password: string }) {
    const result = await authClient.post("/api/login", { body: data });
    if (!result.success) throw new Error("Login failed");
    return result.body;
  },

  async me(token: string) {
    const result = await authClient.get("/api/me", {
      headers: { authorization: `Bearer ${token}` },
    });
    if (!result.success) throw new Error("Failed to get user");
    return result.body;
  },
};

// Logic API
export const logicApi = {
  async listTasks(token?: string) {
    const result = await logicClient.get("/api/", {
      headers: token ? { authorization: `Bearer ${token}` } : undefined,
    });
    if (!result.success) throw new Error("Failed to list tasks");
    return result.body;
  },

  async createTask(token: string, data: { title: string; description?: string }) {
    const result = await logicClient.post("/api/", {
      body: data,
      headers: { authorization: `Bearer ${token}` },
    });
    if (!result.success) throw new Error("Failed to create task");
    return result.body;
  },
};
```

## Type Safety

The `http-client-ky` client provides full type inference from the SDK's `Request` and `Response` objects:

```typescript
// TypeScript knows:
// - Valid endpoints: "/api/", "/api/{id}"
// - Required params/body for each endpoint
// - Response body type for each status code
const result = await logicClient.get("/api/", {
  headers: token ? { authorization: `Bearer ${token}` } : undefined,
});

if (result.success) {
  // result.body is typed as Task[]
  result.body.forEach(task => {
    console.log(task.title);  // ✅ TypeScript knows this exists
    console.log(task.status); // ✅ "pending" | "in_progress" | "completed"
  });
} else {
  // result.error is typed based on the error response schema
  console.error(result.error);
}
```

## React Component

```typescript title="apps/web/src/app/page.tsx"
"use client";

import { useState, useEffect } from "react";
import { authApi, logicApi } from "@/lib/api";
import type { z } from "zod";
import type { TaskSchema } from "@real-life/backend-logic-sdk";

type Task = z.infer<typeof TaskSchema>;

export default function Home() {
  const [token, setToken] = useState<string | null>(null);
  const [user, setUser] = useState<{ id: string; email: string; name: string } | null>(null);
  const [tasks, setTasks] = useState<Task[]>([]);

  // Load token from localStorage
  useEffect(() => {
    const saved = localStorage.getItem("auth_token");
    if (saved) setToken(saved);
  }, []);

  // Fetch user and tasks when token changes
  useEffect(() => {
    if (!token) return;
    authApi.me(token).then(setUser).catch(() => setToken(null));
    logicApi.listTasks(token).then(setTasks);
  }, [token]);

  const handleLogin = async (email: string, password: string) => {
    const result = await authApi.login({ email, password });
    localStorage.setItem("auth_token", result.session.token);
    setToken(result.session.token);
  };

  const handleCreateTask = async (title: string) => {
    if (!token) return;
    const task = await logicApi.createTask(token, { title });
    setTasks([...tasks, task]);
  };

  // ... render UI
}
```

## NextJS Configuration

Configure transpilation for workspace packages:

```javascript title="apps/web/next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  transpilePackages: [
    "@real-life/backend-auth-sdk",
    "@real-life/backend-logic-sdk",
  ],
};

module.exports = nextConfig;
```

---

// File: real-life/index

# Real Life Example

A complete example showing how to use all Alt-stack packages together in a production-like setup.

## Overview

This example demonstrates a task management system with:

- **2 Backend Services** (Hono): Authentication and business logic
- **Background Workers** (WarpStream): Notifications and report generation
- **NextJS Frontend**: Consumes both services via generated SDKs
- **Type-safe SDKs**: Generated from OpenAPI/AsyncAPI specs

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                          NextJS Web App                          │
│              (uses http-client-ky + generated SDKs)              │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    │                       │
                    ▼                       ▼
        ┌───────────────────┐   ┌───────────────────┐
        │   backend-auth    │   │   backend-logic   │
        │   (Hono server)   │   │   (Hono server)   │
        │                   │   │                   │
        │ - POST /signup    │◄──│ validates tokens  │
        │ - POST /login     │   │                   │
        │ - POST /logout    │   │ - GET/POST /tasks │
        │ - GET /me         │   │ - PUT/DELETE /{id}│
        │ - GET /validate   │   │                   │
        └───────────────────┘   └─────────┬─────────┘
                                          │
                                          │ triggers jobs
                                          ▼
                                ┌───────────────────┐
                                │     WarpStream    │
                                │     Workers       │
                                │                   │
                                │ - send-notification│
                                │ - generate-report │
                                └───────────────────┘
```

## Key Takeaways

### 1. End-to-End Type Safety

Types flow from Zod schemas through OpenAPI/AsyncAPI specs to generated SDKs:

```typescript
// Define once in backend-logic
const TaskSchema = z.object({
  id: z.string(),
  title: z.string(),
  status: z.enum(["pending", "in_progress", "completed"]),
});

// Automatically available in frontend via SDK
import type { TaskSchema } from "@real-life/backend-logic-sdk";
type Task = z.infer<typeof TaskSchema>;
```

### 2. Service-to-Service Auth

The logic service validates tokens by calling the auth service's internal endpoint:

```typescript
// backend-logic calls backend-auth
async function validateToken(token: string): Promise<string | null> {
  const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
    headers: { authorization: token },
  }).json<{ valid: boolean; userId?: string }>();
  return res.valid ? res.userId ?? null : null;
}
```

### 3. Protected Procedures with Middleware

Create reusable authenticated procedures:

```typescript
const protectedProc = factory.procedure
  .errors({ 401: z.object({ error: z.object({ code: z.literal("UNAUTHORIZED") }) }) })
  .use(async ({ ctx, next }) => {
    if (!ctx.userId) throw ctx.error({ error: { code: "UNAUTHORIZED", ... } });
    return next({ ctx: { userId: ctx.userId } }); // narrow type
  });
```

### 4. Type-Safe Background Jobs

Trigger workers with full type inference from the SDK:

```typescript
import { Topics } from "@real-life/workers-sdk";

const client = await createWarpStreamClient({ jobs: Topics, ... });

// TypeScript knows the exact payload shape
await client.trigger("send-notification", {
  type: "task_created",  // must be valid enum
  userId: ctx.userId,
  taskId: id,
  taskTitle: input.body.title,
});
```

### 5. Built-in Telemetry

Enable [OpenTelemetry tracing](/guides/telemetry) with a single flag:

```typescript
const app = createServer(
  { api: taskRouter, docs: docsRouter },
  {
    createContext,
    telemetry: {
      enabled: env.NODE_ENV === "production",
      serviceName: "backend-logic",
      ignoreRoutes: ["/docs"],
    },
  },
);
```

### 6. SDK-First Frontend

The frontend uses generated SDKs with `http-client-ky` for fully typed API calls:

```typescript
import { createApiClient } from "@alt-stack/http-client-ky";
import { Request, Response } from "@real-life/backend-logic-sdk";

const client = createApiClient({ baseUrl, Request, Response });

// Full autocomplete for paths, params, body, and response
const result = await client.get("/api/{id}", {
  params: { id: "..." },
  headers: { authorization: `Bearer ${token}` },
});
if (result.success) {
  console.log(result.body.title); // TypeScript knows this exists
}
```

## What You'll Learn

| Topic | Description |
|-------|-------------|
| [Project Structure](./project-structure) | Monorepo layout and package organization |
| [Auth Service](./auth-service) | Building the authentication service |
| [Logic Service](./logic-service) | Business logic with auth integration |
| [Workers](./workers) | Background job processing with WarpStream |
| [Frontend](./frontend) | NextJS app with SDK consumption |
| [SDK Generation](./sdk-generation) | Generating and using type-safe SDKs |

## Quick Start

```bash
# Clone and navigate to example
cd examples/real-life

# Install dependencies
pnpm install

# Generate SDKs
pnpm generate:all

# Start all services (in separate terminals)
pnpm --filter @real-life/backend-auth dev   # Port 3001
pnpm --filter @real-life/backend-logic dev  # Port 3002
pnpm --filter @real-life/workers dev
pnpm --filter @real-life/web dev            # Port 3000
```

## Technologies Used

| Package | Technology | Purpose |
|---------|------------|---------|
| `@alt-stack/server-hono` | Hono | Type-safe HTTP servers with telemetry |
| `@alt-stack/workers-warpstream` | WarpStream/Kafka | Background job processing |
| `@alt-stack/workers-client-warpstream` | WarpStream/Kafka | Job triggering |
| `@alt-stack/zod-openapi` | OpenAPI | REST API SDK generation |
| `@alt-stack/zod-asyncapi` | AsyncAPI | Worker SDK generation |
| `@alt-stack/http-client-ky` | ky | Type-safe HTTP client with SDK integration |
| `@opentelemetry/api` | OpenTelemetry | Distributed tracing (optional) |
| `Next.js` | React | Frontend framework |

---

// File: real-life/logic-service

# Logic Service

The business logic service handles task management and triggers background workers.

## Endpoints

| Method | Path | Description |
|--------|------|-------------|
| GET | `/api/` | List all tasks |
| POST | `/api/` | Create task (auth required) |
| GET | `/api/{id}` | Get task by ID |
| PUT | `/api/{id}` | Update task (auth required) |
| DELETE | `/api/{id}` | Delete task (auth required) |

## Auth Integration

The service validates tokens by calling the auth service:

```typescript
const AUTH_SERVICE_URL = process.env.AUTH_SERVICE_URL || "http://localhost:3001";

async function validateToken(token: string): Promise<string | null> {
  try {
    const res = await ky.get(`${AUTH_SERVICE_URL}/api/validate`, {
      headers: { authorization: token },
    }).json<{ valid: boolean; userId?: string }>();
    return res.valid ? (res.userId ?? null) : null;
  } catch {
    return null;
  }
}

// Context creation
async function createContext(c: Context): Promise<AppContext> {
  const auth = c.req.header("Authorization");
  const userId = auth ? await validateToken(auth) : null;
  return { userId };
}
```

## Protected Procedures

```typescript
interface AppContext {
  userId: string | null;
}

const factory = init<AppContext>();

const protectedProc = factory.procedure
  .errors({
    401: z.object({ error: z.object({ code: z.literal("UNAUTHORIZED"), message: z.string() }) }),
  })
  .use(async ({ ctx, next }) => {
    if (!ctx.userId) {
      throw ctx.error({ error: { code: "UNAUTHORIZED", message: "Authentication required" } });
    }
    return next({ ctx: { userId: ctx.userId } });
  });
```

## Worker Triggers

When tasks are created or completed, the service triggers background workers:

```typescript
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";
import { Topics } from "@real-life/workers-sdk";

const workerClient = await createWarpStreamClient({
  bootstrapServer: WARPSTREAM_URL,
  jobs: Topics,
});

// In create task handler
await workerClient.trigger("send-notification", {
  type: "task_created",
  userId: ctx.userId,
  taskId: id,
  taskTitle: input.body.title,
});

// In update task handler (when completed)
if (!wasCompleted && nowCompleted) {
  await workerClient.trigger("generate-report", {
    taskId: task.id,
    userId: ctx.userId,
    completedAt: task.updatedAt.toISOString(),
  });
}
```

## Full Router

```typescript
const taskRouter = router<AppContext>({
  "/": {
    get: factory.procedure
      .output(z.array(TaskSchema))
      .handler(() => Array.from(tasks.values())),

    post: protectedProc
      .input({
        body: z.object({
          title: z.string().min(1).max(200),
          description: z.string().max(1000).optional(),
        }),
      })
      .output(TaskSchema)
      .handler(async ({ input, ctx }) => {
        const task = createTask(input.body, ctx.userId);
        await workerClient.trigger("send-notification", { ... });
        return task;
      }),
  },

  "{id}": {
    get: factory.procedure
      .input({ params: z.object({ id: z.string().uuid() }) })
      .output(TaskSchema)
      .errors({ 404: NotFoundError })
      .handler(({ input, ctx }) => {
        const task = tasks.get(input.params.id);
        if (!task) throw ctx.error({ error: { code: "NOT_FOUND", message: "Task not found" } });
        return task;
      }),

    put: protectedProc
      .input({
        params: z.object({ id: z.string().uuid() }),
        body: z.object({
          title: z.string().min(1).max(200).optional(),
          description: z.string().max(1000).optional(),
          status: z.enum(["pending", "in_progress", "completed"]).optional(),
        }),
      })
      .output(TaskSchema)
      .errors({ 404: NotFoundError, 403: ForbiddenError })
      .handler(async ({ input, ctx }) => {
        // Update task, trigger report if completed
        // ...
      }),

    delete: protectedProc
      .input({ params: z.object({ id: z.string().uuid() }) })
      .output(z.object({ success: z.boolean() }))
      .errors({ 404: NotFoundError, 403: ForbiddenError })
      .handler(({ input, ctx }) => {
        // Delete task
        // ...
      }),
  },
});
```

---

// File: real-life/project-structure

# Project Structure

The real-life example is organized as a pnpm monorepo with apps and packages.

## Directory Layout

```
examples/real-life/
├── package.json           # Workspace root
├── pnpm-workspace.yaml    # Workspace config
├── apps/
│   ├── backend-auth/      # Auth service (Hono)
│   │   ├── src/
│   │   │   ├── index.ts          # Server entry
│   │   │   └── generate-spec.ts  # OpenAPI generator
│   │   ├── openapi.json          # Generated spec
│   │   └── package.json
│   │
│   ├── backend-logic/     # Business logic service (Hono)
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   └── generate-spec.ts
│   │   ├── openapi.json
│   │   └── package.json
│   │
│   ├── workers/           # Background workers (WarpStream)
│   │   ├── src/
│   │   │   ├── index.ts
│   │   │   └── generate-spec.ts
│   │   ├── asyncapi.json
│   │   └── package.json
│   │
│   └── web/               # NextJS frontend
│       ├── src/
│       │   ├── app/
│       │   └── lib/api.ts
│       └── package.json
│
└── packages/
    ├── backend-auth-sdk/  # Generated OpenAPI SDK
    ├── backend-logic-sdk/ # Generated OpenAPI SDK
    └── workers-sdk/       # Generated AsyncAPI SDK
```

## Package Dependencies

```
@real-life/web
├── @real-life/backend-auth-sdk
├── @real-life/backend-logic-sdk
└── ky

@real-life/backend-logic
├── @alt-stack/server-hono
├── @alt-stack/workers-client-warpstream
├── @real-life/workers-sdk
└── ky (for calling backend-auth)

@real-life/backend-auth
└── @alt-stack/server-hono

@real-life/workers
└── @alt-stack/workers-warpstream
```

## Workspace Configuration

```yaml title="pnpm-workspace.yaml"
packages:
  - "apps/*"
  - "packages/*"
```

## Scripts

```json title="package.json"
{
  "scripts": {
    "dev": "pnpm -r run dev",
    "build": "pnpm -r run build",
    "generate:all": "pnpm -r run generate"
  }
}
```

Each app has a `generate` script that:
1. Runs `generate-spec.ts` to create the JSON spec
2. Runs the corresponding SDK package's `generate` script

```json title="apps/backend-auth/package.json"
{
  "scripts": {
    "generate": "tsx src/generate-spec.ts && pnpm --filter @real-life/backend-auth-sdk generate"
  }
}
```

---

// File: real-life/sdk-generation

# SDK Generation

Type-safe SDKs are generated from OpenAPI and AsyncAPI specs.

## Generation Flow

```
┌──────────────────────────────────────────────────────────────────┐
│ 1. Define routes with Zod schemas                                │
│    └── router({ "/users": procedure.output(UserSchema).get(...) })│
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 2. Generate spec file                                            │
│    └── generateOpenAPISpec({ api: router }) → openapi.json       │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 3. Generate SDK from spec                                        │
│    └── zod-openapi openapi.json -o src/index.ts                  │
└───────────────────────────────┬──────────────────────────────────┘
                                │
                                ▼
┌──────────────────────────────────────────────────────────────────┐
│ 4. SDK exports Zod schemas + Request/Response types              │
│    └── import { UserSchema, Request, Response } from "sdk"       │
└──────────────────────────────────────────────────────────────────┘
```

## OpenAPI SDK (REST APIs)

### Generate Spec Script

```typescript title="apps/backend-auth/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateOpenAPISpec } from "@alt-stack/server-hono";
import { authRouter } from "./index.js";

const spec = generateOpenAPISpec({ api: authRouter }, {
  title: "Auth API",
  version: "1.0.0",
});

writeFileSync("openapi.json", JSON.stringify(spec, null, 2));
console.log("Generated openapi.json");
```

### SDK Package

```json title="packages/backend-auth-sdk/package.json"
{
  "name": "@real-life/backend-auth-sdk",
  "scripts": {
    "generate": "zod-openapi ../../apps/backend-auth/openapi.json -o src/index.ts"
  },
  "devDependencies": {
    "@alt-stack/zod-openapi": "workspace:*"
  }
}
```

### Generated Output

```typescript title="packages/backend-auth-sdk/src/index.ts (generated)"
import { z } from "zod";

export const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
});
export type User = z.infer<typeof UserSchema>;

export const Request = {
  "/api/signup": {
    POST: {
      body: z.object({
        email: z.string().email(),
        password: z.string().min(8),
        name: z.string().min(1),
      }),
    },
  },
  // ...
} as const;

export const Response = {
  "/api/signup": {
    POST: {
      "200": z.object({ user: UserSchema, session: SessionSchema }),
      "409": z.object({ error: z.object({ code: z.literal("EMAIL_EXISTS"), message: z.string() }) }),
    },
  },
  // ...
} as const;
```

## AsyncAPI SDK (Workers)

### Generate Spec Script

```typescript title="apps/workers/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateAsyncAPISpec } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./index.js";

const spec = generateAsyncAPISpec(jobRouter, {
  title: "Real Life Workers",
  version: "1.0.0",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

### SDK Package

```json title="packages/workers-sdk/package.json"
{
  "name": "@real-life/workers-sdk",
  "scripts": {
    "generate": "zod-asyncapi ../../apps/workers/asyncapi.json -o src/index.ts"
  },
  "devDependencies": {
    "@alt-stack/zod-asyncapi": "workspace:*"
  }
}
```

### Generated Output

```typescript title="packages/workers-sdk/src/index.ts (generated)"
import { z } from "zod";

export const SendNotificationPayloadSchema = z.object({
  type: z.enum(["task_created", "task_completed", "task_assigned"]),
  userId: z.string(),
  taskId: z.string(),
  taskTitle: z.string(),
});

export const Topics = {
  "send-notification": SendNotificationPayloadSchema,
  "generate-report": GenerateReportPayloadSchema,
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Running Generation

```bash
# Generate all specs and SDKs
pnpm generate:all

# Or individually
pnpm --filter @real-life/backend-auth generate
pnpm --filter @real-life/backend-logic generate
pnpm --filter @real-life/workers generate
```

## CI/CD Integration

See [CI/CD SDK Generation](/guides/ci-cd-sdk-generation) for automating SDK generation in GitHub Actions.

---

// File: real-life/workers

# Workers

Background job processing using WarpStream (Kafka-compatible).

## Job Definitions

```typescript title="apps/workers/src/index.ts"
import { createWorker, init, workerRouter } from "@alt-stack/workers-warpstream";
import { z } from "zod";

const { procedure } = init();

export const jobRouter = workerRouter({
  "send-notification": procedure
    .input({
      payload: z.object({
        type: z.enum(["task_created", "task_completed", "task_assigned"]),
        userId: z.string(),
        taskId: z.string(),
        taskTitle: z.string(),
      }),
    })
    .task(async ({ input }) => {
      console.log(`[Notification] ${input.type} for user ${input.userId}`);
      // Send email, push notification, etc.
    }),

  "generate-report": procedure
    .input({
      payload: z.object({
        taskId: z.string(),
        userId: z.string(),
        completedAt: z.string().datetime(),
      }),
    })
    .task(async ({ input }) => {
      console.log(`[Report] Generating report for task ${input.taskId}`);
      // Generate PDF, store in S3, etc.
    }),
});
```

## Starting the Worker

```typescript
const worker = await createWorker(jobRouter, {
  kafka: { brokers: [WARPSTREAM_URL] },
  groupId: GROUP_ID,
});

console.log("Workers running, waiting for jobs...");

// Graceful shutdown
process.on("SIGINT", async () => {
  await worker.disconnect();
  process.exit(0);
});

await new Promise(() => {});
```

## Generating the AsyncAPI Spec

```typescript title="apps/workers/src/generate-spec.ts"
import { writeFileSync } from "fs";
import { generateAsyncAPISpec } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./index.js";

const spec = generateAsyncAPISpec(jobRouter, {
  title: "Real Life Workers",
  version: "1.0.0",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

## SDK Generation

The generated SDK exports a `Topics` object for type-safe job triggering:

```typescript title="packages/workers-sdk/src/index.ts (generated)"
import { z } from "zod";

export const SendNotificationPayloadSchema = z.object({
  type: z.enum(["task_created", "task_completed", "task_assigned"]),
  userId: z.string(),
  taskId: z.string(),
  taskTitle: z.string(),
});

export const GenerateReportPayloadSchema = z.object({
  taskId: z.string(),
  userId: z.string(),
  completedAt: z.string(),
});

export const Topics = {
  "send-notification": SendNotificationPayloadSchema,
  "generate-report": GenerateReportPayloadSchema,
} as const;
```

## Consuming the SDK

```typescript
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";
import { Topics } from "@real-life/workers-sdk";

const client = await createWarpStreamClient({
  bootstrapServer: "warpstream.example.com:9092",
  jobs: Topics,
});

// Type-safe: TypeScript knows the payload shape
await client.trigger("send-notification", {
  type: "task_created",  // ✅ Must be valid enum value
  userId: "user-123",
  taskId: "task-456",
  taskTitle: "My Task",
});

// ❌ TypeScript error: invalid payload
await client.trigger("send-notification", {
  invalid: "field",
});
```

---

// File: workers-warpstream/core-concepts/custom-context

# Custom Context

Inject dependencies into job handlers.

## Define Context Type

```typescript
import { init } from "@alt-stack/workers-warpstream";

interface AppContext {
  db: Database;
  logger: Logger;
}

const { router, procedure } = init<AppContext>();

const jobRouter = router({
  "sync-user": procedure
    .input({ payload: z.object({ userId: z.string() }) })
    .task(async ({ input, ctx }) => {
      // Access injected dependencies
      ctx.logger.info(`Syncing user ${input.userId}`);
      const user = await ctx.db.users.find(input.userId);
      // ...
    }),
});
```

## Create Context

```typescript
import { createWorker } from "@alt-stack/workers-warpstream";

const worker = await createWorker(jobRouter, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  createContext: async (baseCtx) => {
    // baseCtx contains: jobId, jobName, attempt, topic, partition, offset, message
    return {
      db: getDatabase(),
      logger: createLogger({ jobId: baseCtx.jobId }),
    };
  },
});
```

## Base Context

Every job handler receives these built-in fields:

```typescript
interface WarpStreamContext {
  jobId: string;      // Unique execution ID
  jobName: string;    // Name of the job
  attempt: number;    // Retry attempt (starts at 1)
  topic: string;      // Kafka topic
  partition: number;  // Kafka partition
  offset: string;     // Message offset
  message: KafkaMessage;  // Raw Kafka message
}
```

---

// File: workers-warpstream/core-concepts/error-handling

# Error Handling

Handle job failures with the Result pattern.

## Result Pattern

Handlers return `Result<Errors, Output>`:

```typescript
import { init, ok, err } from "@alt-stack/workers-trigger";

const { router, procedure } = init();

const jobRouter = router({
  "process-payment": procedure
    .input({ payload: z.object({ orderId: z.string() }) })
    .errors({
      INSUFFICIENT_FUNDS: z.object({
        code: z.literal("INSUFFICIENT_FUNDS"),
        balance: z.number(),
      }),
      CARD_DECLINED: z.object({
        code: z.literal("CARD_DECLINED"),
        reason: z.string(),
      }),
    })
    .task(async ({ input }) => {
      const balance = await getBalance();
      if (balance < 0) {
        return err({
          data: {
            code: "INSUFFICIENT_FUNDS" as const,
            balance,
          },
        });
      }

      await processPayment(input.orderId);
      return ok();
    }),
});
```

## Error Callback

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  onError: async (error, ctx) => {
    console.error(`Job ${ctx.jobName} failed:`, error);

    // Send to error tracking
    await sentry.captureException(error, {
      extra: {
        jobId: ctx.jobId,
        jobName: ctx.jobName,
        attempt: ctx.attempt,
      },
    });
  },
});
```

## Success Returns

Use `ok()` for all successful returns:

```typescript
// Return data
return ok({ orderId: "123", status: "processed" });

// Void return
return ok();
```

## Retries

Kafka consumer retries are handled at the Kafka level. Configure dead letter queues in your Kafka setup for failed messages.

---

// File: workers-warpstream/core-concepts/job-client

# Job Client

Type-safe producer for enqueuing jobs.

## Basic Usage

```typescript
import { createJobClient } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

const client = await createJobClient(jobRouter, {
  kafka: { brokers: ["warpstream.example.com:9092"] },
});

// Fully typed - invalid job names or payloads are compile errors
await client.enqueue("send-email", {
  to: "user@example.com",
  subject: "Hello",
  body: "World",
});

await client.disconnect();
```

## Options

```typescript
const client = await createJobClient(router, {
  // Kafka connection
  kafka: { brokers: ["localhost:9092"] },
  
  // Or pass an existing Kafka instance
  kafka: existingKafkaInstance,
  
  // Routing strategy (must match consumer)
  routing: { type: "topic-per-job" },
  
  // Client ID
  clientId: "my-producer",
  
  // Error callback
  onError: (error) => console.error(error),
});
```

## Partition Keys

Route related jobs to the same partition:

```typescript
await client.enqueue(
  "process-order",
  { orderId: "123", items: [...] },
  { key: "user-456" }  // All jobs for this user go to same partition
);
```

## Custom Headers

```typescript
await client.enqueue(
  "send-notification",
  { userId: "123", message: "Hello" },
  { headers: { "x-priority": "high", "x-source": "api" } }
);
```

---

// File: workers-warpstream/core-concepts/middleware

# Middleware

Add cross-cutting logic to job handlers.

## Basic Middleware

```typescript
const { router, procedure } = init<AppContext>();

const loggedProcedure = procedure.use(async ({ ctx, next }) => {
  console.log(`Starting job: ${ctx.jobName}`);
  const start = Date.now();
  
  const result = await next();
  
  console.log(`Completed in ${Date.now() - start}ms`);
  return result;
});

const jobRouter = router({
  "my-job": loggedProcedure
    .input({ payload: z.object({ id: z.string() }) })
    .task(async ({ input }) => {
      // Logging happens automatically
    }),
});
```

## Extend Context

```typescript
const withMetrics = procedure.use(async ({ ctx, next }) => {
  return next({
    ctx: {
      metrics: new MetricsClient(),
    },
  });
});

// Now ctx.metrics is available in handlers
const jobRouter = router({
  "tracked-job": withMetrics
    .input({ payload: z.object({ id: z.string() }) })
    .task(async ({ ctx }) => {
      ctx.metrics.increment("jobs.processed");
    }),
});
```

## Chain Middleware

```typescript
const authedProcedure = procedure
  .use(loggingMiddleware)
  .use(metricsMiddleware)
  .use(rateLimitMiddleware);
```

---

// File: workers-warpstream/core-concepts/routing-strategies

# Routing Strategies

Two strategies for routing jobs through Kafka.

## Topic-per-Job (Default)

Each job name becomes a Kafka topic:

```
job "send-email"     → topic "send-email"
job "process-image"  → topic "process-image"
```

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing: { type: "topic-per-job" },
});
```

With a prefix:

```typescript
routing: { type: "topic-per-job", topicPrefix: "jobs." }
// job "send-email" → topic "jobs.send-email"
```

## Single-Queue

All jobs go to one topic with an envelope:

```typescript
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing: { type: "single-queue", topic: "job-queue" },
});
```

Messages are wrapped:

```json
{ "jobName": "send-email", "payload": { "to": "user@example.com", ... } }
```

## Matching Producer and Consumer

Use the same routing strategy for both:

```typescript
const routing = { type: "single-queue", topic: "jobs" } as const;

// Consumer
const worker = await createWorker(router, {
  kafka: { brokers: ["localhost:9092"] },
  groupId: "workers",
  routing,
});

// Producer
const client = await createJobClient(router, {
  kafka: { brokers: ["localhost:9092"] },
  routing,
});
```

---

// File: workers-warpstream/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/workers-warpstream kafkajs zod
```

## Peer Dependencies

- **kafkajs**: `^2.0.0` - Kafka client
- **zod**: `^3.25.0 || ^4.0.0` - Schema validation

---

// File: workers-warpstream/getting-started/quickstart

# Quickstart

Build async job queues using WarpStream/Kafka with type-safe producers and consumers.

## Define Jobs

```typescript
import { init } from "@alt-stack/workers-warpstream";
import { z } from "zod";

const { router, procedure } = init();

const jobRouter = router({
  "send-email": procedure
    .input({
      payload: z.object({
        to: z.string().email(),
        subject: z.string(),
        body: z.string(),
      }),
    })
    .task(async ({ input, ctx }) => {
      console.log(`Sending email to ${input.to}`);
      // Send email logic here
    }),

  "process-image": procedure
    .input({
      payload: z.object({
        imageUrl: z.string().url(),
        operations: z.array(z.enum(["resize", "crop", "compress"])),
      }),
    })
    .task(async ({ input }) => {
      console.log(`Processing image: ${input.imageUrl}`);
    }),
});

export { jobRouter };
```

## Start Worker

```typescript
import { createWorker } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

async function main() {
  const worker = await createWorker(jobRouter, {
    kafka: { brokers: ["warpstream.example.com:9092"] },
    groupId: "job-workers",
  });

  console.log("Worker running, waiting for jobs...");

  // Graceful shutdown
  process.on("SIGINT", async () => {
    await worker.disconnect();
    process.exit(0);
  });

  // Block until shutdown
  await new Promise(() => {});
}

main();
```

## Enqueue Jobs

```typescript
import { createJobClient } from "@alt-stack/workers-warpstream";
import { jobRouter } from "./jobs";

const client = await createJobClient(jobRouter, {
  kafka: { brokers: ["warpstream.example.com:9092"] },
});

// Type-safe: only valid job names and payloads allowed
await client.enqueue("send-email", {
  to: "user@example.com",
  subject: "Welcome!",
  body: "Thanks for signing up.",
});

await client.enqueue("process-image", {
  imageUrl: "https://example.com/image.jpg",
  operations: ["resize", "compress"],
});
```

---

// File: workers-warpstream/guides/sdk-generation

# SDK Generation

Generate a type-safe SDK from your worker definitions to trigger jobs without importing router code.

## Overview

The SDK generation workflow:

1. Define workers with `workerRouter`
2. Generate AsyncAPI spec from the router
3. Generate TypeScript SDK from the spec
4. Use the SDK with worker clients

This allows services to trigger workers without depending on the worker implementation code.

## Generate AsyncAPI Spec

```typescript
// generate-spec.ts
import { generateAsyncAPISpec } from "@alt-stack/workers-core";
import { appRouter } from "./routers";
import { writeFileSync } from "node:fs";

const spec = generateAsyncAPISpec(appRouter, {
  title: "Workers API",
  version: "1.0.0",
  description: "Background job definitions",
});

writeFileSync("asyncapi.json", JSON.stringify(spec, null, 2));
console.log("Generated asyncapi.json");
```

Run it:

```bash
npx tsx generate-spec.ts
```

:::note
Only `task` and `queue` procedures are included in the spec. Cron jobs are excluded since they don't accept external payloads.
:::

## Generate TypeScript SDK

Use the `asyncapi-to-zod` CLI to generate Zod schemas:

```bash
npx asyncapi-to-zod asyncapi.json -o ./sdk/index.ts
```

This generates:

```typescript
// sdk/index.ts (auto-generated)
import { z } from 'zod';

export const SendWelcomeEmailPayloadSchema = z.object({
  userId: z.string(),
  email: z.string().email(),
});
export type SendWelcomeEmailPayload = z.infer<typeof SendWelcomeEmailPayloadSchema>;

export const ProcessImagePayloadSchema = z.object({
  imageUrl: z.string().url(),
});
export type ProcessImagePayload = z.infer<typeof ProcessImagePayloadSchema>;

export const Topics = {
  'send-welcome-email': SendWelcomeEmailPayloadSchema,
  'process-image': ProcessImagePayloadSchema,
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Use with Worker Clients

### Trigger.dev Client

```typescript
import { Topics } from "@myorg/workers-sdk";
import { createTriggerClient } from "@alt-stack/workers-client-trigger";

const client = createTriggerClient({ jobs: Topics });

// Type-safe: autocomplete for job names and payloads
await client.trigger("send-welcome-email", {
  userId: "user-123",
  email: "user@example.com",
});

// With options
await client.trigger("send-welcome-email", payload, {
  idempotencyKey: "unique-123",
  delay: "PT5M", // 5 minute delay
});
```

### WarpStream Client

```typescript
import { Topics } from "@myorg/workers-sdk";
import { createWarpStreamClient } from "@alt-stack/workers-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "cluster.warpstream.com:9092",
  jobs: Topics,
});

await client.trigger("send-welcome-email", {
  userId: "user-123",
  email: "user@example.com",
});

await client.disconnect();
```

## Batch Triggering

Trigger multiple jobs efficiently:

```typescript
await client.triggerBatch("process-image", [
  { imageUrl: "https://example.com/1.jpg" },
  { imageUrl: "https://example.com/2.jpg" },
  { imageUrl: "https://example.com/3.jpg" },
]);
```

## Publishing the SDK

Create a package for your SDK:

```json
{
  "name": "@myorg/workers-sdk",
  "version": "1.0.0",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "peerDependencies": {
    "zod": "^3.25.0 || ^4.0.0"
  }
}
```

Add a build script:

```json
{
  "scripts": {
    "generate": "tsx generate-spec.ts && asyncapi-to-zod asyncapi.json -o src/index.ts",
    "build": "tsup src/index.ts --format esm,cjs --dts"
  }
}
```

Other services can then install and use your SDK:

```bash
pnpm add @myorg/workers-sdk @alt-stack/workers-client-trigger
```

## Benefits

- **Decoupled**: Services don't need to import worker router code
- **Type-safe**: Full TypeScript support with autocomplete
- **Validated**: Payloads are validated before sending
- **Versioned**: SDK can be versioned independently