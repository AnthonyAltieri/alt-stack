// File: client/core-concepts/basic-usage

# Basic Usage

Learn how to use the API client for making type-safe requests.

## Creating a Client

Use `createApiClient` to create a client instance:

```typescript
import { createApiClient } from "@alt-stack/client";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
  headers: {
    Authorization: "Bearer token",
  },
});
```

## Making Requests

The client provides methods for different HTTP methods:

### GET Requests

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  query: { include: "profile" },
});
```

### POST Requests

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "alice@example.com",
  },
});
```

### PUT Requests

```typescript
const result = await client.put("/users/{id}", {
  params: { id: "123" },
  body: { name: "Alice Updated", email: "alice@example.com" },
});
```

### PATCH Requests

```typescript
const result = await client.patch("/users/{id}", {
  params: { id: "123" },
  body: { email: "newemail@example.com" },
});
```

### DELETE Requests

```typescript
const result = await client.delete("/users/{id}", {
  params: { id: "123" },
});
```

## Handling Responses

All methods return a result object that can be either a success or error:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // Type-safe access to response body
  console.log(result.body);
  console.log(result.code); // Status code string, e.g., "200"
} else {
  // Handle error - check if it's a defined error or unexpected
  if (typeof result.code === "string") {
    // Server returned a defined error response
    console.error(result.code, result.error);
  } else {
    // Unexpected error (network, validation, etc.)
    console.error(result.error);
  }
}
```

## Request Options

You can pass additional options to requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  headers: {
    "X-Custom-Header": "value",
  },
  timeout: 5000, // milliseconds
  retries: 3, // number of retry attempts
  shouldRetry: ({ response }) => response?.status >= 500, // custom retry logic
});
```

| Option | Type | Description |
|--------|------|-------------|
| `params` | `object` | Path parameters to interpolate into the URL |
| `query` | `object` | Query parameters to append to the URL |
| `body` | `object` | Request body (required for POST, PUT, PATCH) |
| `headers` | `object` | Additional headers to include |
| `timeout` | `number` | Request timeout in milliseconds |
| `retries` | `number` | Number of retry attempts |
| `shouldRetry` | `function` | Custom retry logic callback |

See [Error Handling](./error-handling.md#custom-retry-logic) for more details on `shouldRetry`.

---

// File: client/core-concepts/error-handling

# Error Handling

The client provides comprehensive error handling with typed error responses.

## Response Types

Every request returns a result that can be one of three types:

1. **Success Response** - Request succeeded
2. **Error Response** - Server returned an error response
3. **Unexpected Error Response** - Network, validation, or unexpected error

## Success Response

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body);
  // result.code contains the status code (e.g., "200", "201")
}
```

## Error Response

When the server returns an error response (non-2xx status):

```typescript
const result = await client.post("/users", {
  body: { name: "Alice" },
});

if (!result.success && typeof result.code === "string") {
  // Server error response (typed error from Response schemas)
  // result.error is typed based on the error schema for this status code
  console.error(result.code); // HTTP status code (e.g., "404", "500")
  console.error(result.error); // Typed error body based on schema
}
```

## Unexpected Error Response

For network errors, validation errors, or other unexpected issues:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (!result.success && typeof result.code === "number") {
  // Unexpected error response (not defined in Response schemas)
  if (result.error instanceof Error) {
    console.error(result.error.message); // Error message
    // error may be UnexpectedApiClientError with additional properties
  } else {
    console.error("Unexpected error:", result.error);
  }
  console.error(result.code); // HTTP status code as number
}
```

## Error Classes

The client exports error classes for programmatic handling:

| Class | Description |
|-------|-------------|
| `ApiClientError` | Base class for all client errors |
| `ValidationError` | Request/response validation failed |
| `UnexpectedApiClientError` | Network error or unexpected response |
| `TimeoutError` | Request exceeded timeout |

```typescript
import {
  ValidationError,
  UnexpectedApiClientError,
  TimeoutError,
  ApiClientError,
} from "@alt-stack/client";

try {
  await client.get("/users/{id}", {
    params: { id: 123 },
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation error:", error.validationErrors);
  } else if (error instanceof TimeoutError) {
    console.error(`Request timed out after ${error.timeout}ms`);
  } else if (error instanceof UnexpectedApiClientError) {
    console.error("Request failed:", error.message, error.code);
  } else if (error instanceof ApiClientError) {
    console.error("Client error:", error.message);
  }
}
```

## Retry Logic

The client includes built-in retry logic with exponential backoff:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3, // Will retry up to 3 times
});
```

By default, retries are automatically performed for:
- Network errors

Retries are **not** performed by default for:
- Validation errors
- Client errors (4xx status codes)
- Server errors (5xx status codes) - these are valid HTTP responses

### Custom Retry Logic

Use the `shouldRetry` option to customize retry behavior:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  retries: 3,
  shouldRetry: ({ attempt, error, response }) => {
    // Retry on 5xx server errors
    if (response?.status >= 500) return true;
    // Retry on rate limiting
    if (response?.status === 429) return true;
    // Retry on network errors
    if (error) return true;
    return false;
  },
});
```

The `shouldRetry` callback receives a context object with:
- `attempt` - Current attempt number (0-indexed)
- `error` - Error thrown during request (network errors, timeouts)
- `response` - HTTP response received (status, statusText, data)

#### Examples

**Retry on 5xx server errors:**

```typescript
shouldRetry: ({ response }) => response?.status !== undefined && response.status >= 500
```

**Limit retries regardless of `retries` option:**

```typescript
shouldRetry: ({ attempt }) => attempt < 2
```

**Retry on specific error codes:**

```typescript
shouldRetry: ({ response }) => {
  const retryableCodes = [500, 502, 503, 504, 429];
  return response?.status !== undefined && retryableCodes.includes(response.status);
}
```

**Custom logic combining error and response:**

```typescript
shouldRetry: ({ error, response }) => {
  // Always retry network errors
  if (error) return true;
  // Retry rate limits and server errors
  if (response?.status === 429 || (response?.status ?? 0) >= 500) return true;
  return false;
}
```

## Timeouts

Set a timeout for requests:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
  timeout: 5000, // 5 seconds
});
```

If the request exceeds the timeout, a `TimeoutError` is thrown with the `timeout` property indicating the configured timeout in milliseconds.

---

// File: client/core-concepts/validation

# Validation

The client automatically validates request parameters, query strings, and request bodies using Zod schemas.

## Automatic Validation

When you make a request, the client automatically validates:

1. **Path parameters** - Validated against the `params` schema
2. **Query parameters** - Validated against the `query` schema
3. **Request body** - Validated against the `body` schema
4. **Response data** - Validated against the `output` schema

```typescript
const result = await client.post("/users", {
  body: {
    name: "Alice",
    email: "invalid-email", // ❌ This will throw ValidationError
  },
});
```

## Validation Errors

If validation fails, the client throws a `ValidationError`:

```typescript
import { ValidationError } from "@alt-stack/client";

try {
  await client.get("/users/{id}", {
    params: { id: 123 }, // ❌ Should be string
  });
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Validation failed:", error.message);
    console.error("Validation errors:", error.validationErrors);
  }
}
```

The `ValidationError` includes:
- `message`: Human-readable error message
- `validationErrors`: Validation error details from Zod
- `endpoint`: The endpoint that failed validation
- `method`: The HTTP method that failed validation

## Type Safety

TypeScript ensures you pass the correct types at compile time:

```typescript
// ✅ TypeScript knows this is correct
await client.get("/users/{id}", {
  params: { id: "123" },
});

// ❌ TypeScript error - id must be string
await client.get("/users/{id}", {
  params: { id: 123 },
});
```

## Response Validation

Response data is automatically validated when received:

```typescript
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is validated and typed
  console.log(result.body.name); // ✅ Type-safe
}
```

If the response doesn't match the expected schema, an error is returned in the result.

---

// File: client/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/client zod
```

## Peer Dependencies

- **zod**: `^4.0.0`

## Requirements

1. A server built with `@alt-stack/server-hono` that exposes an OpenAPI spec
2. Generated `Request` and `Response` types from the OpenAPI spec (see [Server Integration](../guides/server-integration))

---

// File: client/getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates how to use the type-safe API client.

## Basic Example

First, ensure your server generates an OpenAPI spec and Request/Response types:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });
const openApiSpec = generateOpenAPISpec({ api: router }, {
  title: "My API",
  version: "1.0.0",
});

export { openApiSpec };
export default app;
```

Then generate Request and Response types from the OpenAPI spec (see [Server Integration](../guides/server-integration) for details), and use the client:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/client";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

// Make a type-safe API call
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // TypeScript knows the shape of result.body
  console.log(result.body.name); // ✅ Type-safe
  console.log(result.body.email); // ✅ Type-safe
} else {
  // Handle error
  console.error(result.error);
}
```

## Features

- **Type-safe**: Full TypeScript inference from server types
- **Validation**: Automatic runtime validation using Zod schemas
- **Error handling**: Typed error responses
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters

---

// File: client/guides/server-integration

# Server Integration

Learn how to integrate the client with your Altstack server.

## Overview

To use the client with your server, you need:

1. Generate an OpenAPI spec from your server router
2. Generate `Request` and `Response` types from the OpenAPI spec
3. Create a client instance with these types

## Step 1: Generate OpenAPI Spec

On your server, generate the OpenAPI spec:

```typescript
// server.ts
import { init, createServer, generateOpenAPISpec } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({ id: z.string() }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  });

const app = createServer({ api: router });

// Generate OpenAPI spec
const openApiSpec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
  }
);

export { openApiSpec };
export default app;
```

## Step 2: Generate Request and Response Types

Use the `@alt-stack/zod-openapi` package to generate TypeScript types:

```typescript
// generate-types.ts
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";
import { openApiSpec } from "./server.js";
import { writeFileSync } from "fs";

const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});

writeFileSync("./src/generated-types.ts", generatedCode);
```

This generates a file with:
- Zod schemas for all request parameters, query strings, bodies, and responses
- `Request` object with lookup for request schemas
- `Response` object with lookup for response schemas organized by status code

Example generated output:

```typescript
// generated-types.ts
import { z } from "zod";

export const GetUsersIdParamsSchema = z.object({
  id: z.string(),
});

export const GetUsersId200ResponseSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});

export const GetUsersId404ErrorResponseSchema = z.object({
  error: z.object({
    code: z.literal("NOT_FOUND"),
    message: z.string(),
  }),
});

export const Request = {
  "/users/{id}": {
    GET: {
      params: GetUsersIdParamsSchema,
    },
  },
} as const;

export const Response = {
  "/users/{id}": {
    GET: {
      "200": GetUsersId200ResponseSchema,
      "404": GetUsersId404ErrorResponseSchema,
    },
  },
} as const;
```

## Step 3: Create Client

Now create the client using the generated types:

```typescript
// client.ts
import { createApiClient } from "@alt-stack/client";
import { Request, Response } from "./generated-types.js";

const client = createApiClient({
  baseUrl: "http://localhost:3000",
  Request,
  Response,
});

export { client };
```

## Step 4: Use the Client

Now you can make type-safe API calls:

```typescript
import { client } from "./client.js";

// Type-safe GET request
const result = await client.get("/users/{id}", {
  params: { id: "123" },
});

if (result.success) {
  // result.body is typed based on your output schema
  console.log(result.body.name); // ✅ Type-safe
}
```

## Keeping Types in Sync

It's recommended to regenerate types whenever you change your server routes. You can:

1. **Manual regeneration**: Run your type generation script when routes change
2. **Watch mode**: Use a file watcher to regenerate on route changes
3. **Build step**: Include type generation in your build process

## Sharing Types Between Projects

If your client is in a separate project from your server:

1. Export the OpenAPI spec from your server project
2. Share it via npm package, git submodule, or API endpoint
3. Generate types in your client project from the shared spec

Example: Export spec as JSON endpoint:

```typescript
// server.ts
const docsRouter = createDocsRouter({ api: router });
app.route("/docs", docsRouter);

// Access at /docs/openapi.json
```

Then fetch and generate types in client:

```typescript
// client project
const response = await fetch("http://localhost:3000/docs/openapi.json");
const openApiSpec = await response.json();
const generatedCode = openApiToZodTsCode(openApiSpec, undefined, {
  includeRoutes: true,
});
```

---

// File: core-concepts/combining-routers

# Combining Routers

Organize your API by combining multiple routers using the new tRPC-style `router()` function. Routers can be nested, and paths combine automatically.

## Basic Router Combination

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

// User routes
const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      const { input } = opts;
      return { id: input.id, name: "Alice" };
    }),

  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .post((opts) => {
      return { id: "1" };
    }),
});

// Post routes
const postsRouter = router({
  list: publicProcedure
    .output(
      z.array(
        z.object({
          id: z.string(),
          title: z.string(),
        })
      )
    )
    .get(() => {
      return [{ id: "1", title: "Hello World" }];
    }),
});

// Combine routers - keys become path prefixes
const appRouter = router({
  users: userRouter,  // Routes prefixed with /users
  posts: postsRouter, // Routes prefixed with /posts
});

const app = createServer({
  api: appRouter,
});

// Routes available at:
// - GET /api/users/{id}
// - POST /api/users/create
// - GET /api/posts/list
```

## Nested Routers

Routers can be nested within other routers. Paths combine automatically:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const productRouter = router({
  "favorites/me": publicProcedure.get(() => {
    return [];
  }),
});

const userRouter = router({
  profile: publicProcedure.get(() => {
    return { id: "1" };
  }),
});

// Nested routers
const appRouter = router({
  products: productRouter,  // /products/favorites/me
  users: userRouter,        // /users/profile
});

// Final paths:
// - GET /products/favorites/me
// - GET /users/profile
```

## Multiple Routers with Same Prefix

You can pass arrays of routers for the same prefix in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const app = createServer({
  api: [v1Router, v2Router], // Both routers prefixed with /api
});
```

This is useful for versioning APIs or organizing routes by feature.

## Nested Routes with Compound Paths

To achieve nested routes like `/api/v1/*` and `/api/v2/*`, use compound prefixes in `createServer`:

```typescript
import { router, publicProcedure, createServer } from "@alt-stack/server-hono";

const v1Router = router({
  users: publicProcedure.get(() => []),
});

const v2Router = router({
  users: publicProcedure.get(() => []),
});

const adminRouter = router({
  settings: publicProcedure.get(() => []),
});

const app = createServer({
  "api/v1": v1Router,
  "api/v2": v2Router,
  admin: adminRouter,
});
```

Results in routes like:
- `/api/v1/users` - All v1Router routes
- `/api/v2/users` - All v2Router routes
- `/admin/settings` - All adminRouter routes

---

// File: core-concepts/custom-context

# Custom Context

Define custom context (similar to tRPC) to pass data like database connections or authentication info.

## Defining Context

Create a context type and a function to create it:

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import type { Context } from "hono";
import { z } from "zod";

// Define your context type
interface AppContext {
  db: Database;
  user: User | null;
}

// Create context function
async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthenticatedUser(c);
  return {
    db: database,
    user,
  };
}

// Create factory and router with context type
const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.db and ctx.user are typed and available
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    return {
      id: ctx.user.id,
      name: ctx.user.name,
    };
  });

// Create server with createContext
const app = createServer({
  users: router,
}, {
  createContext,
});
```

## Accessing Hono Context

Access the raw Hono context for advanced use cases:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
    }),
  })
  .handler((ctx) => {
    // Access raw Hono context
    const headers = ctx.hono.req.header();
    const ip = ctx.hono.req.header("x-forwarded-for");
    
    return { id: ctx.input.id };
  });
```

The `ctx.hono` property gives you full access to the underlying Hono context for headers, cookies, environment variables, and other advanced features.

---

// File: core-concepts/error-handling

# Error Handling

Define error schemas and use type-safe `ctx.error()` for controlled error responses.

## Defining Error Schemas

Specify error schemas in the route configuration:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
    errors: {
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => {
    const user = findUser(ctx.input.id);
    
    if (!user) {
      // TypeScript knows this must match the 404 error schema
      // Status code is automatically inferred from the error type
      throw ctx.error({
        error: {
          code: "NOT_FOUND",
          message: `User ${ctx.input.id} not found`,
        },
      });
    }
    
    return user;
  });
```

## Multiple Error Types

Define multiple error status codes:

```typescript
const factory = init();
const router = factory.router()
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
    }),
    errors: {
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
      409: z.object({
        error: z.object({
          code: z.literal("CONFLICT"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => {
    if (userExists(ctx.input.name)) {
      throw ctx.error({
        error: {
          code: "CONFLICT",
          message: "User already exists",
        },
      });
    }
    
    return { id: "1" };
  });
```

## Automatic Status Codes

The status code is automatically inferred from the error type in `ctx.error()`. You don't need to specify it manually - TypeScript ensures you can only throw errors that match your defined schemas. Always use `throw ctx.error(...)` to throw the error.

## Validation Errors

When input validation fails, a `400` response is automatically returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

You don't need to handle validation errors manually - they're caught before your handler runs.

---

// File: core-concepts/input-validation

# Input Validation

Automatic validation of path parameters, query parameters, and request body using Zod schemas.

## Validation Sources

Inputs can be validated from three sources:

- **params**: Path parameters (e.g., `/users/{id}`)
- **query**: Query string parameters (e.g., `?limit=10&offset=0`)
- **body**: Request body for POST/PUT/PATCH requests

## Example

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .get((opts) => {
      // opts.input.params.id (from params)
      // opts.input.query.limit (from query)
      // opts.input.query.offset (from query)
      const { input } = opts;
      return { id: input.params.id };
    }),
});
```

## String Input Constraints

Since HTTP path parameters and query strings are always strings, `params` and `query` schemas are constrained at **compile-time** to only accept Zod types that can parse string input. This prevents runtime errors from invalid schema configurations.

| Schema | Input Type | Allowed in params/query? |
|--------|-----------|--------------------------|
| `z.string()` | `string` | ✅ |
| `z.enum(["a", "b"])` | `"a" \| "b"` | ✅ (string literals) |
| `z.coerce.number()` | `unknown` | ✅ (coerces strings) |
| `z.string().transform(...)` | `string` | ✅ (transform) |
| `z.codec(z.string(), ...)` | `string` | ✅ (Zod 4 codec) |
| `z.number()` | `number` | ❌ compile error |
| `z.boolean()` | `boolean` | ❌ compile error |
| `z.array(...)` | `T[]` | ❌ compile error |

```typescript
// ✅ Valid - all fields accept string input
.input({
  params: z.object({ id: z.string() }),
  query: z.object({ page: z.coerce.number() }),
})

// ❌ Compile error - z.number() doesn't accept string input
.input({
  query: z.object({ page: z.number() }), // Error!
})
```

:::tip Use z.coerce for numeric parameters
Since query strings are always strings, use `z.coerce.number()` instead of `z.number()` to automatically convert string values like `"42"` to numbers.
:::

### Zod 4 Codecs

[Zod 4 codecs](https://zod.dev/codecs) provide bidirectional transformation between input and output types. They work seamlessly with params/query since the input schema determines what the field accepts:

```typescript
// Define a codec that transforms ISO strings to Date objects
const stringToDate = z.codec(
  z.iso.datetime(),  // input schema: ISO date string
  z.date(),          // output schema: Date object
  {
    decode: (isoString) => new Date(isoString),
    encode: (date) => date.toISOString(),
  }
);

// ✅ Valid - input type is string (from z.iso.datetime())
.input({
  query: z.object({
    since: stringToDate, // Accepts: "2024-01-15T10:30:00.000Z"
  }),
})
.get(({ input }) => {
  // input.query.since is typed as Date (the output type)
  const date: Date = input.query.since;
  return { events: getEventsSince(date) };
})
```

:::note Body has no string constraint
The `body` field has no string input constraint since request bodies are parsed as JSON and can contain any JSON-serializable types.
:::

## Path Parameter Validation

When using path parameters in the route key (e.g., `{id}`), TypeScript enforces that you must provide a `params` schema with matching keys:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  // ✅ Valid - params.id matches {id} in path
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      return { id: opts.input.params.id };
    }),

  // ❌ TypeScript error - missing params.id for {id} path
  // "{id}": publicProcedure.get(() => ({ id: "1" })),
});
```

## Validation Errors

When validation fails, a `400` response is automatically returned:

```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "details": [...]
  }
}
```

The handler is only called if all inputs pass validation, ensuring type safety and runtime safety.

## Combining Input Types

You can combine params, query, and body validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.enum(["profile", "posts"]).optional(),
      }),
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      const { input } = opts;
      // All inputs are validated and typed:
      // input.params.id (from params)
      // input.query.include (from query, optional)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

---

// File: core-concepts/middleware

# Middleware

Apply middleware to procedures to add cross-cutting concerns like authentication, logging, or rate limiting.

## Procedure-Level Middleware

Apply middleware to specific procedures using `.use()`:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
      })
    )
    .use(async (opts) => {
      // Log before handler
      const { ctx, next } = opts;
      console.log("Creating user:", ctx.input.name);
      return next();
    })
    .post((opts) => {
      return { id: "1" };
    }),
});
```

## Context Extension

Middleware can extend the context by passing updated context to `next()`. This follows the tRPC pattern:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  console.log(`Request took ${duration}ms`);
  return result;
};

const authMiddleware = async (opts: {
  ctx: any;
  next: (opts?: { ctx: Partial<any> }) => Promise<any>;
}) => {
  const { ctx, next } = opts;
  const user = await authenticate(ctx.hono.req);
  if (!user) {
    return ctx.hono.json({ error: "Unauthorized" }, 401);
  }
  // Extend context - user is now non-null in subsequent handlers
  return next({ ctx: { user } });
};

const protectedProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware);

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null
      const { ctx } = opts;
      return { id: ctx.user!.id, name: ctx.user!.name };
    }),
});
```

## Multiple Middleware

Chain multiple middleware on the same procedure:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const loggerMiddleware = async (opts: any) => {
  console.log("Request started");
  return opts.next();
};

const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

const adminMiddleware = async (opts: any) => {
  if (opts.ctx.user?.role !== "admin") {
    return new Response("Forbidden", { status: 403 });
  }
  return opts.next();
};

const adminProcedure = factory.procedure
  .use(loggerMiddleware)
  .use(authMiddleware)
  .use(adminMiddleware);

export const adminRouter = router({
  settings: adminProcedure.get(() => {
    return { admin: true };
  }),
});
```

Middleware executes in the order they're defined.

## Reusable Procedures

Create reusable procedures with middleware to reuse authentication or other middleware across multiple routes. See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for details:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  // Auth middleware
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

// Use procedures
export const appRouter = router({
  hello: publicProc.get(() => "hello"),
  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      return opts.ctx.user!;
    }),
});
```

## Middleware Chaining and Context Flow

Middleware can chain together, with each middleware able to extend the context:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { id: string; role: string } | null;
  requestId: string;
  isAdmin: boolean;
}

const factory = init<AppContext>();

// First middleware adds requestId
const requestIdMiddleware = async (opts: any) => {
  const requestId = crypto.randomUUID();
  return opts.next({ ctx: { requestId } });
};

// Second middleware adds user
const authMiddleware = async (opts: any) => {
  const user = await getUser(opts.ctx);
  return opts.next({ ctx: { user } });
};

// Third middleware adds isAdmin based on user role
const adminCheckMiddleware = async (opts: any) => {
  const isAdmin = opts.ctx.user?.role === "admin";
  return opts.next({ ctx: { isAdmin } });
};

const adminProcedure = factory.procedure
  .use(requestIdMiddleware)
  .use(authMiddleware)
  .use(adminCheckMiddleware);

export const adminRouter = router({
  dashboard: adminProcedure
    .input({})
    .get((opts) => {
      // All context extensions are available
      const { ctx } = opts;
      return {
        requestId: ctx.requestId,
        userId: ctx.user!.id,
        isAdmin: ctx.isAdmin,
      };
    }),
});
```

---

// File: core-concepts/output-validation

# Output Validation

Optionally validate response data to ensure handlers return the expected structure.

## Basic Usage

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // Return value is validated against output schema
    return {
      id: ctx.input.id,
      name: "Alice",
    };
  });
```

## Benefits

- **Runtime safety**: Catch bugs during development when handlers return incorrect data
- **Type safety**: TypeScript ensures your return value matches the schema
- **Documentation**: Output schemas serve as API documentation

## Optional Output Validation

Output validation is optional. If you omit the `output` field, no validation is performed, but you lose type safety for the return value:

```typescript
const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    // No output validation
  })
  .handler((ctx) => {
    return { id: ctx.input.id };
  });
```

---

// File: core-concepts/reusable-procedures

# Reusable Procedures

Create reusable procedures with middleware to follow the tRPC pattern. This allows you to define common authentication, validation, or other middleware once and reuse it across multiple routes.

## Basic Pattern

Use `publicProcedure` or `init()` to create procedures:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    // `ctx.user` is nullable
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    // ✅ Pass updated context where user is non-null
    return next({
      ctx: {
        user: ctx.user, // ✅ user value is known to be non-null now
      },
    });
  });

// Create a router using the new tRPC-style API
export const appRouter = router({
  hello: publicProc.get(() => {
    return "hello world";
  }),

  profile: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        name: z.string(),
      })
    )
    .get((opts) => {
      // opts.ctx.user is guaranteed to be non-null after middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        name: ctx.user!.name,
      };
    }),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => {
      return { secret: "sauce" };
    }),
});
```

## Configuring Procedures

Procedures support the same configuration methods as regular routes:

### Setting Default Input

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const validatedProcedure = publicProcedure.input({
  query: z.object({
    apiKey: z.string().min(1),
  }),
});

// All routes using this procedure will require apiKey in query
export const dataRouter = router({
  list: validatedProcedure
    .input({
      body: z.object({ filter: z.string() }), // Additional input
    })
    .get((opts) => {
      // opts.input.apiKey is available (from procedure)
      // opts.input.filter is available (from route)
      const { input } = opts;
      return [];
    }),
});
```

### Setting Default Output

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const jsonProcedure = publicProcedure.output(
  z.object({
    success: z.boolean(),
  })
);

export const actionRouter = router({
  create: jsonProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post((opts) => {
      // output is automatically set from procedure
      return { success: true };
    }),
});
```

### Setting Default Errors

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const errorProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const protectedRouter = router({
  data: errorProcedure
    .input({})
    .output(z.string())
    .get((opts) => {
      const { ctx } = opts;
      if (someCondition) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Not authorized",
          },
        });
      }
      return "success";
    }),
});
```

### Combining Procedure and Route Errors

Errors defined on procedures are automatically merged with errors defined on routes. Route errors take precedence when the same status code is defined in both:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

// Procedure defines common authentication error
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const userRouter = router({
  "{id}": apiProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(z.object({ id: z.string(), name: z.string() }))
    .errors({
      // 401 is inherited from procedure
      // Add additional route-specific errors
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
      403: z.object({
        error: z.object({
          code: z.literal("FORBIDDEN"),
          message: z.string(),
        }),
      }),
    })
    .get((opts) => {
      const { input, ctx } = opts;
      const user = findUser(input.id);

      if (!user) {
        // Can throw 404 error (defined on route)
        throw ctx.error({
          error: {
            code: "NOT_FOUND",
            message: "User not found",
          },
        });
      }

      if (!canAccessUser(user)) {
        // Can throw 403 error (defined on route)
        throw ctx.error({
          error: {
            code: "FORBIDDEN",
            message: "Access denied",
          },
        });
      }

      if (!isAuthenticated()) {
        // Can throw 401 error (inherited from procedure)
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED",
            message: "Authentication required",
          },
        });
      }

      return user;
    }),
});
```

In this example, the route has access to all three error types:
- `401 UNAUTHORIZED` from the procedure
- `404 NOT_FOUND` from the route
- `403 FORBIDDEN` from the route

**Union of Error Schemas**: If both the procedure and route define an error with the same status code, the schemas are unioned. This means `ctx.error()` can accept either schema for that status code:

```typescript
const apiProcedure = publicProcedure.errors({
  401: z.object({
    error: z.object({
      code: z.literal("UNAUTHORIZED"),
      message: z.string(),
    }),
  }),
});

export const settingsRouter = router({
  me: apiProcedure
    .input({})
    .errors({
      // Route defines a different 401 error schema - they will be unioned
      401: z.object({
        error: z.object({
          code: z.literal("SESSION_EXPIRED"),
          message: z.string(),
          redirect: z.string().url(),
        }),
      }),
    })
    .get((opts) => {
      const { ctx } = opts;
      // Can throw 401 with either UNAUTHORIZED or SESSION_EXPIRED
      throw ctx.error({
        error: {
          code: "SESSION_EXPIRED",
          message: "Your session has expired",
          redirect: "https://example.com/login",
        },
      });
    }),
});
```

## Middleware Chaining

Middleware can be chained to build up context:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string } | null;
}

const factory = init<AppContext>();

const authProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  const user = await getUser(ctx);
  if (!user) {
    throw ctx.error({ code: "UNAUTHORIZED" });
  }
  return next({ ctx: { user } });
});

const adminProcedure = authProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (ctx.user.role !== "admin") {
    throw ctx.error({ code: "FORBIDDEN" });
  }
  return next({ ctx: { isAdmin: true } });
});

export const adminRouter = router({
  settings: adminProcedure
    .input({})
    .get((opts) => {
      // opts.ctx.user and opts.ctx.isAdmin are both available
      const { ctx } = opts;
      return { admin: ctx.isAdmin };
    }),
});
```

## Common Patterns

### Public and Protected Routes

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(authMiddleware);

export const appRouter = router({
  hello: publicProc.get(() => "hello"),

  profile: protectedProcedure
    .input({})
    .get((opts) => {
      return opts.ctx.user!; // Non-null due to middleware
    }),
});
```

### Role-Based Procedures

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";

interface AppContext {
  user: { role: string } | null;
}

const factory = init<AppContext>();

const requireRole = (role: string) =>
  factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user || ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next();
  });

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  delete: adminProcedure.get(() => ({ success: true })),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure.post(() => ({ success: true })),
});
```

### Rate Limited Procedures

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";

const rateLimitedProcedure = publicProcedure.use(async (opts) => {
  const { ctx, next } = opts;
  const rateLimitKey = getRateLimitKey(ctx);
  if (await isRateLimited(rateLimitKey)) {
    return new Response("Too many requests", { status: 429 });
  }
  await incrementRateLimit(rateLimitKey);
  return next();
});

export const apiRouter = router({
  data: rateLimitedProcedure.get(() => {
    return { data: [] };
  }),
});
```

---

// File: example

# Kitchen Sink Example

A comprehensive example demonstrating all features of Altstack with the tRPC-style API. This example shows a complete Todo API server with authentication, error handling, middleware, and type safety.

**Note**: In the tRPC-style API, the keys in the `router()` object become the endpoint paths. For example, `list: publicProcedure.get(...)` creates the route `/list`, and `"{id}": publicProcedure.get(...)` creates the route `/{id}`. When routers are nested, paths combine (e.g., `todos: todoRouter` with key `"{id}"` creates `/todos/{id}`).

**Multiple HTTP Methods on Same Path**: To define multiple HTTP methods for the same path (e.g., GET, PUT, DELETE on `/todos/{id}`), use a nested methods object with `.handler()` instead of `.get()`, `.put()`, etc. The HTTP method is automatically inferred from the object key. For example:
```typescript
"{id}": {
  get: publicProc.input(...).handler((opts) => { ... }),
  put: protectedProcedure.input(...).handler((opts) => { ... }),
  delete: protectedProcedure.input(...).handler((opts) => { ... }),
}
```

**Default Error Schemas**: 400 (validation) and 500 (internal server) errors are automatically included for all procedures. When you provide a custom 400 or 500 error via `.errors()`, it will be unioned with the default, allowing your procedure to accept both the default error format and your custom format. You can override the default error handlers in `init()` options.

## Complete Server Implementation

```typescript
import { router, publicProcedure, init, createServer } from "@alt-stack/server-hono";
import type { HonoBaseContext } from "@alt-stack/server-hono";
import type { Context } from "hono";
import { z } from "zod";

// ============================================================================
// Type Definitions
// ============================================================================

const UserSchema = z.object({
  id: z.string(),
  email: z.string(),
  role: z.literal("admin", "user"),
});
type User = z.infer<typeof UserSchema>;

interface AppContext {
  user: User | null;
}

const TodoSchema = z.object({
  id: z.string(),
  title: z.string(),
  description: z.string().optional(),
  completed: z.boolean(),
  createdAt: z.string(),
  userId: z.string(),
});
type Todo = z.infer<typeof TodoSchema>;

// ============================================================================
// Reusable Procedures
// ============================================================================

// Initialize factory with default error handlers
// You can override default 400/500 error handlers here if needed:
// const factory = init<AppContext>({
//   default400Error: (errors, variant, value) => [customSchema, customInstance],
//   default500Error: (error) => [customSchema, customInstance],
// });
const factory = init<AppContext>();

// Public procedure (no auth required)
const publicProc = publicProcedure;

// Protected procedure with authentication middleware
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED",
          message: "Authentication required",
        },
      });
    }
    return next({ ctx: { user: ctx.user } });
  });

// Admin-only procedure
const adminProcedure = protectedProcedure
  .errors({
    403: z.object({
      error: z.object({
        code: z.literal("FORBIDDEN"),
        message: z.string(),
      }),
    }),
  })
  .use(async (opts) => {
    const { ctx, next } = opts;
    if (ctx.user.role !== "admin") {
      throw ctx.error({
        error: {
          code: "FORBIDDEN",
          message: "Admin access required",
        },
      });
    }
    return next();
  });

// ============================================================================
// Routers
// ============================================================================

// Todo router with full CRUD operations
export const todoRouter = router<AppContext>({
  // GET /todos - List all todos with query filtering
  // POST /todos - Create new todo (protected)
  "/": {
    get: publicProc
      .input({
        query: z.object({
          completed: z.enum(["true", "false"]).optional(),
          limit: z.number().int().positive().optional(),
          offset: z.number().int().nonnegative().optional(),
        }),
      })
      .output(z.array(TodoSchema))
      .handler((opts) => {
        const { input } = opts;
        // ✅ input.completed is typed as "true" | "false" | undefined
        // ✅ input.limit and input.offset are typed
        let todos = getAllTodos();

        if (input.completed === "true") {
          todos = todos.filter((t) => t.completed);
        } else if (input.completed === "false") {
          todos = todos.filter((t) => !t.completed);
        }

        if (input.limit) {
          todos = todos.slice(
            input.offset ?? 0,
            (input.offset ?? 0) + input.limit,
          );
        }

        return todos; // ✅ Return type matches z.array(TodoSchema)
      }),

    post: protectedProcedure
      .input({
        body: z.object({
          title: z.string().min(1).max(200),
          description: z.string().max(1000).optional(),
        }),
      })
      .output(TodoSchema)
      // ✅ 400 validation error is automatically included - no need to declare it
      // ✅ 500 internal server error is also automatically included
      .handler((opts) => {
        const { input, ctx } = opts;
        // ✅ input.title is string (min 1, max 200)
        // ✅ input.description is string | undefined (max 1000)
        // ✅ ctx.user is guaranteed non-null (from middleware)

        const todo = createTodo({
          title: input.title,
          description: input.description,
          userId: ctx.user!.id,
        });

        return todo;
      }),
  },

  // GET /todos/{id} - Get single todo with path parameter
  // PUT /todos/{id} - Update todo
  // DELETE /todos/{id} - Delete todo
  // Using nested methods object to support multiple HTTP methods on the same path
  "{id}": {
    get: publicProc
      .input({
        params: z.object({
          id: z.string().uuid(), // ✅ TypeScript enforces params.id matches {id}
        }),
      })
      .output(TodoSchema)
      .errors({
        404: z.object({
          error: z.object({
            code: z.literal("NOT_FOUND"),
            message: z.string(),
          }),
        }),
      })
      .handler((opts) => {
        const { input, ctx } = opts;
        // ✅ input.id is typed as string (from params)
        const todo = getTodoById(input.id);

        if (!todo) {
          throw ctx.error({
            // ✅ TypeScript ensures code is "NOT_FOUND"
            // ✅ Status code (404) is automatically inferred!
            error: {
              code: "NOT_FOUND",
              message: `Todo with id ${input.id} not found`,
            },
          });
        }

        return todo; // ✅ Return type matches TodoSchema
      }),

    put: protectedProcedure
      .input({
        params: z.object({
          id: z.string().uuid(),
        }),
        query: z.object({
          notify: z.coerce.boolean().optional(),
        }),
        body: z.object({
          title: z.string().min(1).max(200).optional(),
          description: z.string().max(1000).optional(),
          completed: z.boolean().optional(),
        }),
      })
      .output(TodoSchema)
      .errors({
        // ✅ 400 and 500 errors are automatically included (default validation and internal server errors)
        // ✅ Custom 400 error will be unioned with the default validation error
        // This means ctx.error() can accept either the default validation error OR this custom error
        400: z.object({
          error: z.object({
            code: z.literal("CUSTOM_VALIDATION_ERROR"),
            message: z.string(),
            field: z.string(),
          }),
        }),
        404: z.object({
          error: z.object({
            code: z.literal("NOT_FOUND"),
            message: z.string(),
          }),
        }),
        403: z.object({
          error: z.object({
            code: z.literal("FORBIDDEN"),
            message: z.string(),
          }),
        }),
      })
      .handler((opts) => {
        const { input, ctx } = opts;
        // ✅ All inputs are available and typed:
        // input.id (from params)
        // input.notify (from query, optional)
        // input.title, input.description, input.completed (from body, all optional)

        const todo = getTodoById(input.id);
        if (!todo) {
          throw ctx.error({
            error: {
              code: "NOT_FOUND",
              message: `Todo with id ${input.id} not found`,
            },
          });
        }

        // Check ownership
        if (todo.userId !== ctx.user!.id && ctx.user!.role !== "admin") {
          throw ctx.error({
            error: {
              code: "FORBIDDEN",
              message: "You don't have permission to update this todo",
            },
          });
        }

        const updated = updateTodo(input.id, {
          title: input.title,
          description: input.description,
          completed: input.completed,
        });

        if (input.notify) {
          // Send notification
        }

        return updated;
      }),

    delete: protectedProcedure
      .input({
        params: z.object({
          id: z.string().uuid(),
        }),
      })
      .output(
        z.object({
          success: z.boolean(),
        }),
      )
      .errors({
        404: z.object({
          error: z.object({
            code: z.literal("NOT_FOUND"),
            message: z.string(),
          }),
        }),
      })
      .handler((opts) => {
        const { input, ctx } = opts;
        const todo = getTodoById(input.id);
        if (!todo) {
          throw ctx.error({
            error: {
              code: "NOT_FOUND",
              message: `Todo with id ${input.id} not found`,
            },
          });
        }

        deleteTodo(input.id);
        return { success: true };
      }),
  },

  // PATCH /todos/{id}/complete - Partial update with nested path
  "{id}/complete": protectedProcedure
    .input({
      params: z.object({
        id: z.string().uuid(),
      }),
      body: z.object({
        completed: z.boolean(),
      }),
    })
    .output(TodoSchema)
    .errors({
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    })
    .patch((opts) => {
      const { input } = opts;
      const todo = getTodoById(input.id);
      if (!todo) {
        throw opts.ctx.error({
          error: {
            code: "NOT_FOUND",
            message: `Todo with id ${input.id} not found`,
          },
        });
      }
      return updateTodo(input.id, { completed: input.completed });
    }),
});

// User router with profile management
export const userRouter = router<AppContext>({
  // GET /users/me - Get current user profile
  me: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
        role: z.enum(["admin", "user"]),
      }),
    )
    .get((opts) => {
      const { ctx } = opts;
      // ✅ ctx.user is guaranteed non-null after middleware
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
        role: ctx.user!.role,
      };
    }),

  // GET /users/{id} - Get user by ID
  "{id}": publicProc
    .input({
      params: z.object({
        id: z.string().uuid(),
      }),
    })
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
      }),
    )
    .errors({
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    })
    .get((opts) => {
      const { input, ctx } = opts;
      const user = getUserById(input.id);
      if (!user) {
        throw ctx.error({
          error: {
            code: "NOT_FOUND",
            message: `User with id ${input.id} not found`,
          },
        });
      }
      return { id: user.id, email: user.email };
    }),
});

// Admin router (admin-only routes)
export const adminRouter = router<AppContext>({
  // GET /admin/users - List all users (admin only)
  users: adminProcedure
    .input({
      query: z.object({
        role: z.enum(["admin", "user"]).optional(),
      }),
    })
    .output(
      z.array(
        z.object({
          id: z.string(),
          email: z.string(),
          role: z.enum(["admin", "user"]),
        }),
      ),
    )
    .get((opts) => {
      const { input } = opts;
      let users = getAllUsers();
      if (input.role) {
        users = users.filter((u) => u.role === input.role);
      }
      return users;
    }),

  // DELETE /admin/users/{id} - Delete user (admin only)
  "users/{id}": adminProcedure
    .input({
      params: z.object({
        id: z.string().uuid(),
      }),
    })
    .output(
      z.object({
        success: z.boolean(),
      }),
    )
    .errors({
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    })
    .delete((opts) => {
      const { input, ctx } = opts;
      const user = getUserById(input.id);
      if (!user) {
        throw ctx.error({
          error: {
            code: "NOT_FOUND",
            message: `User with id ${input.id} not found`,
          },
        });
      }
      deleteUser(input.id);
      return { success: true };
    }),
});

// ============================================================================
// Combine Routers
// ============================================================================

const appRouter = router<AppContext>({
  todos: todoRouter, // /todos/*
  users: userRouter, // /users/*
  admin: adminRouter, // /admin/*
});

// ============================================================================
// Helper Functions (implementation details)
// ============================================================================

function getAllTodos(): Todo[] {
  // Implementation
  return [];
}

function getTodoById(_id: string): Todo | null {
  // Implementation
  return null;
}

function createTodo(data: {
  title: string;
  description?: string;
  userId: string;
}): Todo {
  // Implementation
  return {
    id: crypto.randomUUID(),
    title: data.title,
    description: data.description,
    completed: false,
    createdAt: new Date().toISOString(),
    userId: data.userId,
  };
}

function updateTodo(
  _id: string,
  _data: { title?: string; description?: string; completed?: boolean },
) {
  // Implementation
  return getTodoById(_id)!;
}

function deleteTodo(_id: string): void {
  // Implementation
}

function getAllUsers(): User[] {
  // Implementation
  return [];
}

function getUserById(_id: string): User | null {
  // Implementation
  return null;
}

function deleteUser(_id: string): void {
  // Implementation
}

function getUserFromRequest(_request: Request): User {
  // Extract user from request (e.g., from JWT token)
  return null!;
}

// ============================================================================
// Create Server
// ============================================================================

async function createContext(c: Context): Promise<AppContext> {
  const user = await getUserFromRequest(c.req.raw);
  return { user };
}

const app = createServer<AppContext>(
  {
    api: appRouter, // All routes prefixed with /api
  },
  {
    createContext,
    docs: {
      path: "/docs",
      openapiPath: "/docs/openapi.json",
    },
  },
);

export default app;
```

## Key Features Demonstrated

### 1. **Type-Safe Path Parameters**
```typescript
"{id}": publicProc
  .input({
    params: z.object({
      id: z.string().uuid(), // ✅ TypeScript enforces this matches {id}
    }),
  })
```
TypeScript will error if you use `{id}` without providing `params.id`.

### 2. **Multiple Error Types**
```typescript
.errors({
  404: z.object({ error: z.object({ code: z.literal("NOT_FOUND"), ... }) }),
  403: z.object({ error: z.object({ code: z.literal("FORBIDDEN"), ... }) }),
})
```
Each route can define multiple error types with different status codes.

### 3. **Combining Input Sources**
```typescript
.input({
  params: z.object({ id: z.string().uuid() }),
  query: z.object({ notify: z.coerce.boolean().optional() }),
  body: z.object({ title: z.string().optional() }),
})
```
Routes can use params, query, and body together. Note that `params` and `query` must use schemas that accept string input (e.g., `z.string()`, `z.coerce.number()`, `z.coerce.boolean()`).

### 4. **Middleware Chaining**
```typescript
const adminProcedure = protectedProcedure
  .use(async (opts) => {
    // Additional middleware
  });
```
Middleware can be chained to build up context and permissions.

### 5. **Nested Routers**
```typescript
const appRouter = router<AppContext>({
  todos: todoRouterWithLogging, // /todos/*
  users: userRouter,            // /users/*
  admin: adminRouter,           // /admin/*
});
```
Routers can be nested, and paths combine automatically.

### 6. **Output Validation**
```typescript
.output(TodoSchema)
```
Return types are validated against Zod schemas.

## Type Safety Highlights

- ✅ **Path parameters**: TypeScript enforces `{id}` requires `params.id`
- ✅ **Input types**: All inputs (`params`, `query`, `body`) are fully typed
- ✅ **Output types**: Return values are validated and typed
- ✅ **Error types**: `ctx.error()` only accepts defined error schemas
- ✅ **Context narrowing**: Middleware can extend context with type safety
- ✅ **Status codes**: Error status codes are inferred from error schemas

## Try It Yourself

The complete example server is available in the repository:
- **Server**: `apps/example-altstack-server/`
- Run it: `pnpm --filter example-altstack-server dev`

See the [Installation Guide](/getting-started/installation) to get started building your own type-safe API!

---

// File: getting-started/basic-routes

# Basic Routes

Define routes using the tRPC-style API with support for all HTTP methods.

## Route Methods

The router supports all standard HTTP methods:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure.get(() => {
    return [];
  }),
  
  create: publicProcedure.post(() => {
    return { id: "1" };
  }),
  
  update: publicProcedure.put(() => {
    return { id: "1" };
  }),
  
  patch: publicProcedure.patch(() => {
    return { id: "1" };
  }),
  
  remove: publicProcedure.delete(() => {
    return { success: true };
  }),
});
```

## Path Parameters

Extract parameters from the URL path. Path parameters in the route key (e.g., `{id}`) are automatically validated:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
    })
    .get((opts) => {
      // opts.input.id is typed as string
      const { input } = opts;
      return {
        id: input.id,
        name: "Alice",
      };
    }),
});
```

**Type Safety**: TypeScript will automatically detect an error if you use a path parameter like `{id}` but don't provide the corresponding `params.id` in your input schema. For example, this would cause a TypeScript error:

```typescript
// ❌ TypeScript error: Missing required path parameter 'id' in params
export const userRouter = router({
  "{id}": publicProcedure.get((opts) => {
    return { id: "1" };
  }),
});
```

You must include `params: z.object({ id: z.string() })` (or the appropriate type) when using `{id}` in your route path.

## Query Parameters

Extract query string parameters:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  list: publicProcedure
    .input({
      query: z.object({
        limit: z.coerce.number().optional(),
        offset: z.coerce.number().optional(),
        search: z.string().optional(),
      }),
    })
    .get((opts) => {
      // opts.input.query.limit, opts.input.query.offset, opts.input.query.search are typed
      const { input } = opts;
      return [];
    }),
});
```

:::tip Use z.coerce for numeric query parameters
Query strings are always strings in HTTP. Use `z.coerce.number()` to automatically convert string values like `"10"` to numbers. See [Input Validation](/core-concepts/input-validation#string-input-constraints) for more details.
:::

## Request Body

Handle POST/PUT/PATCH requests with typed request bodies:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  create: publicProcedure
    .input({
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .post((opts) => {
      // opts.input.name and opts.input.email are typed
      const { input } = opts;
      return {
        id: "1",
        name: input.name,
      };
    }),
});
```

## Combining Input Sources

You can combine params, query, and body:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

export const userRouter = router({
  "{id}": publicProcedure
    .input({
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        notify: z.coerce.boolean().optional(),
      }),
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    })
    .put((opts) => {
      // All inputs are available and typed
      const { input } = opts;
      // input.params.id (from params)
      // input.query.notify (from query)
      // input.body.name, input.body.email (from body)
      return { id: input.params.id };
    }),
});
```

## Output Validation

You can specify output schemas for validation:

```typescript
import { router, publicProcedure } from "@alt-stack/server-hono";
import { z } from "zod";

const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string(),
});

export const userRouter = router({
  get: publicProcedure
    .input({
      params: z.object({ id: z.string() }),
    })
    .output(UserSchema)
    .get((opts) => {
      return {
        id: opts.input.id,
        name: "Alice",
        email: "alice@example.com",
      };
    }),
});
```

---

// File: getting-started/installation

# Installation

Choose an adapter based on your preferred HTTP framework.

## Hono Adapter (Recommended)

Best for new projects, edge deployments, and serverless environments.

```bash
pnpm add @alt-stack/server-hono hono zod
# or
npm install @alt-stack/server-hono hono zod
# or
yarn add @alt-stack/server-hono hono zod
```

### Peer Dependencies

- **hono**: `^4.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Express Adapter

Best for existing Express applications or teams familiar with Express.

```bash
pnpm add @alt-stack/server-express express zod
# or
npm install @alt-stack/server-express express zod
# or
yarn add @alt-stack/server-express express zod
```

For TypeScript users:
```bash
pnpm add -D @types/express
```

### Peer Dependencies

- **express**: `^4.0.0 || ^5.0.0` - The underlying HTTP framework
- **zod**: `^4.0.0` - For schema validation and type inference

## Which Adapter Should I Choose?

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards API) | Mature, well-tested |
| Bundle size | Smaller | Larger ecosystem |
| Edge/Serverless | Native support (Cloudflare, Vercel) | Requires adapters |
| Middleware ecosystem | Growing | Extensive |
| Learning curve | Familiar if you know fetch | Familiar if you know Express |

**Recommendation**: Use `@alt-stack/server-hono` for new projects. Use `@alt-stack/server-express` if you're adding to an existing Express app or need specific Express middleware.

## Migration from @alt-stack/server

If you're using the deprecated `@alt-stack/server` package:

```bash
# Remove old package
pnpm remove @alt-stack/server

# Install new package
pnpm add @alt-stack/server-hono hono zod
```

Then update your imports:

```typescript
// Before
import { createServer, router } from "@alt-stack/server";

// After
import { createServer, router } from "@alt-stack/server-hono";
```

The API remains the same - only the import path changes.

---

// File: getting-started/quickstart

# Quickstart

Get started with a simple example that demonstrates the core concepts.

## Basic Example

```typescript
import { init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.id is typed as string (from params)
    return {
      id: ctx.input.id,
      name: "Alice",
      email: "alice@example.com",
    };
  })
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    // ctx.input.name and ctx.input.email are typed (from body)
    return {
      id: "1",
      name: ctx.input.name,
    };
  });

const app = createServer({
  api: router,
});

// Use with your favorite Hono adapter
export default app;
```

This example shows:
- Type-safe route definitions with Zod schemas
- Automatic input validation from params, query, and body
- Type inference in handlers
- Combining routes into a server

---

// File: guides/asyncapi-to-typescript

# AsyncAPI to TypeScript

Generate TypeScript types and Zod schemas from AsyncAPI specifications using the `zod-asyncapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-asyncapi
# or
npm install @alt-stack/zod-asyncapi
```

## CLI Usage

```bash
npx zod-asyncapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-asyncapi asyncapi.json

# Generate from URL (e.g., from your running Kafka producer)
npx zod-asyncapi http://localhost:3000/asyncapi.json

# Specify output file
npx zod-asyncapi asyncapi.json -o src/kafka-types.ts
```

## Generated Output

Given an AsyncAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Message schemas** for each topic
- **Topics lookup object** for easy schema access

### Example

For an AsyncAPI spec with a `User` schema and `user-events` topic:

```typescript
/**
 * This file was automatically generated from AsyncAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

// Component Schemas
export const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

// Topic Message Schemas
export const UserEventsMessageSchema = UserSchema;
export type UserEventsMessage = z.infer<typeof UserEventsMessageSchema>;

// Topics Object
export const Topics = {
  'user-events': UserEventsMessageSchema
} as const;

export type TopicName = keyof typeof Topics;
export type MessageType<T extends TopicName> = z.infer<typeof Topics[T]>;
```

## Using Generated Types with Kafka Client

The generated `Topics` object works directly with `@alt-stack/kafka-core-client-kafkajs` or `@alt-stack/kafka-core-client-warpstream`:

### KafkaJS Producer

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-core-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending - topic names and message shapes are validated
await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});

await client.disconnect();
```

### WarpStream Producer

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-core-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  id: "123",
  name: "John",
  email: "john@example.com",
});
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToAsyncApiSchema } from "@alt-stack/zod-asyncapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToAsyncApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-asyncapi asyncapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/kafka-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Workflow: Server to Client

A typical workflow:

1. **Server defines Kafka topics** with Zod schemas using `@alt-stack/kafka-core`
2. **Server exposes AsyncAPI spec** at an endpoint
3. **Client generates types** using `zod-asyncapi`
4. **Client uses Kafka client** with generated types

```bash
# Generate types from running server
npx zod-asyncapi http://localhost:3000/asyncapi.json -o src/kafka-types.ts
```

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { asyncApiToZodTsCode } from "@alt-stack/zod-asyncapi";

const asyncApiSpec = {
  asyncapi: "3.0.0",
  info: { title: "My API", version: "1.0.0" },
  channels: {
    userEvents: {
      address: "user-events",
      messages: {
        UserCreated: { $ref: "#/components/messages/UserCreated" },
      },
    },
  },
  components: {
    messages: {
      UserCreated: {
        payload: { $ref: "#/components/schemas/User" },
      },
    },
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
};

const generatedCode = asyncApiToZodTsCode(
  asyncApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
);

console.log(generatedCode);
```

---

// File: guides/better-auth-integration

# Better Auth Integration

Integrate Better Auth for authentication with your server framework. Better Auth handles session management, authentication flows, and user management.

## Setup

First, install Better Auth:

```bash
pnpm add better-auth
# or
npm install better-auth
# or
yarn add better-auth
```

Create your Better Auth configuration:

```typescript
// src/auth.ts
import { betterAuth } from "better-auth";
import { drizzleAdapter } from "better-auth/adapters/drizzle";
import { z } from "zod";

export const auth = betterAuth({
  database: drizzleAdapter(db, {
    provider: "pg", // or your database provider
  }),
  emailAndPassword: {
    enabled: true,
  },
  // Add other auth providers as needed
});
```

## Validating User Session with Zod

Better Auth returns session data that should be validated. Use Zod to ensure type safety and validate the user structure:

```typescript
import { z } from "zod";
import { auth } from "./auth.js";

// Define your user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  // Add other user fields as needed
});

// Schema for Better Auth session
const SessionSchema = z.object({
  user: UserSchema,
  session: z.object({
    id: z.string(),
    userId: z.string(),
    expiresAt: z.date(),
  }),
});

// Infer TypeScript types from Zod schemas
export type User = z.infer<typeof UserSchema>;
export type Session = z.infer<typeof SessionSchema>;

export async function getAuthSession(request: Request): Promise<Session | null> {
  const session = await auth.api.getSession({ headers: request.headers });
  
  // Validate and parse the session with safeParse for optional validation
  const result = SessionSchema.safeParse(session);
  
  if (!result.success) {
    // Log validation errors in development
    if (process.env.NODE_ENV === "development") {
      console.warn("Session validation failed:", result.error);
    }
    return null;
  }
  
  return result.data;
}

// Or if you only need the user:
export async function getAuthUser(request: Request): Promise<User | null> {
  const session = await getAuthSession(request);
  return session?.user ?? null;
}
```

## Mounting Better Auth Routes

Mount Better Auth routes alongside your server framework routes. Better Auth handles all `/api/auth/*` routes:

```typescript
import { Hono } from "hono";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create base Hono app
const app = new Hono();

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount your server framework routes
const serverApp = createServer({
  todos: todosRouter,
});

app.route("/", serverApp);

export default app;
```

## Adding User to Context

Add the authenticated user to your custom context so it's available in all handlers. Use Zod validation to ensure type safety:

```typescript
import { createServer } from "@alt-stack/server-hono";
import { getAuthUser, type User } from "./auth.js";
import type { Context } from "hono";
import { z } from "zod";

interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return {
    user,
  };
}

const factory = init<AppContext>();
const router = factory.router()
  .get("/profile", {
    input: {},
    output: z.object({
      id: z.string(),
      email: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => {
    if (!ctx.user) {
      return ctx.hono.json({ error: "Unauthorized" }, 401);
    }
    
    // ctx.user is fully typed based on UserSchema
    return {
      id: ctx.user.id,
      email: ctx.user.email,
      name: ctx.user.name,
    };
  });

const app = createServer({
  users: router,
}, {
  createContext,
});
```

---

// File: guides/client-side-usage

# Client-Side Usage

When making requests from the client, include credentials to support authentication cookies.

## Using Hono Client

Use the Hono client (`hc`) for type-safe API calls:

```typescript
import { hc } from "hono/client";

const client = hc("http://localhost:3000", {
  init: {
    credentials: "include", // Required for auth cookies
  },
});

// Make authenticated requests
const response = await client.api.users.profile.$get();
```

## Fetch with Credentials

When using standard `fetch`, ensure credentials are included:

```typescript
const response = await fetch("http://localhost:3000/api/users/profile", {
  method: "GET",
  credentials: "include", // Required for auth cookies
  headers: {
    "Content-Type": "application/json",
  },
});

const data = await response.json();
```

## Type-Safe API Calls

The Hono client provides type inference from your router definitions. The client automatically knows:

- Available routes
- Request methods
- Input types (params, query, body)
- Output types
- Error types

```typescript
// TypeScript knows this route exists and what it expects
const response = await client.api.users["{id}"].$get({
  param: {
    id: "123",
  },
  query: {
    include: "profile",
  },
});

// response.data is typed based on your output schema
console.log(response.data.name); // ✅ TypeScript knows this exists
```

## Error Handling

Handle errors type-safely:

```typescript
try {
  const response = await client.api.users["{id}"].$get({
    param: { id: "123" },
  });
  
  if (!response.ok) {
    // Handle error response
    const error = await response.json();
    console.error(error);
  }
} catch (error) {
  // Handle network errors
  console.error("Request failed:", error);
}
```

---

// File: guides/cors-configuration

# CORS Configuration

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call.

## Recommended: Global CORS with Better Auth

For most applications, applying CORS globally with credentials support works best:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth, getAuthUser } from "./auth.js";
import { todosRouter } from "./routes/todos.js";
import type { Context } from "hono";

// Create base app
const app = new Hono();

// Apply CORS globally (must be before routes)
app.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true, // Required for Better Auth cookies
  exposeHeaders: ["Set-Cookie"],
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create server framework app with context
interface AppContext extends Record<string, unknown> {
  user: User | null;
}

async function createContext(c: Context): Promise<AppContext> {
  const user = await getAuthUser(c.req.raw);
  return { user };
}

const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Mount server framework routes
app.route("/", serverApp);

export default app;
```

## Using Middleware Option

Use the `middleware` option in `createServer` to apply global middleware like CORS and mount external routes like Better Auth, all in one call:

```typescript
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server with CORS and Better Auth routes
const app = createServer(
  {
    todos: todosRouter,
  },
  {
    createContext,
    middleware: {
      // Apply CORS globally
      "*": {
        methods: ["OPTIONS", "GET", "POST", "PUT", "PATCH", "DELETE"],
        handler: cors({
          origin: process.env.CLIENT_URL || "http://localhost:3000",
          allowHeaders: ["Content-Type", "Authorization"],
          allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
          credentials: true, // Required for Better Auth cookies
          exposeHeaders: ["Set-Cookie"],
        }) as any, // Type assertion for CORS middleware
      },
      // Mount Better Auth routes
      "/api/auth/*": {
        methods: ["GET", "POST"],
        handler: async (c) => auth.handler(c.req.raw),
      },
    },
  },
);

export default app;
```

**Key Points:**
- The `"*"` path applies middleware globally to all routes (framework and mounted routes)
- For `"*"` paths, the handler can be a Hono middleware function (like `cors()`) or a regular handler
- Other paths mount specific route handlers (like Better Auth)
- Middleware is applied before framework routes, ensuring CORS headers are set correctly

## Manual Setup

If you need more control, you can still apply CORS manually after `createServer`:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

const app = new Hono();

// Apply CORS specifically to Better Auth routes
app.use("/api/auth/*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "OPTIONS"],
  credentials: true,
}));

// Mount Better Auth routes
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Create and mount server framework routes
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

app.route("/", serverApp);

export default app;
```

## CORS Only for Server Framework Routes

Apply CORS to server framework routes only:

```typescript
import { Hono } from "hono";
import { cors } from "hono/cors";
import { createServer } from "@alt-stack/server-hono";
import { auth } from "./auth.js";
import { todosRouter } from "./routes/todos.js";

// Create server framework app
const serverApp = createServer({
  todos: todosRouter,
}, {
  createContext,
});

// Apply CORS to server framework routes
serverApp.use("*", cors({
  origin: process.env.CLIENT_URL || "http://localhost:3000",
  allowHeaders: ["Content-Type", "Authorization"],
  allowMethods: ["POST", "GET", "PUT", "PATCH", "DELETE", "OPTIONS"],
  credentials: true,
}));

const app = new Hono();

// Mount Better Auth routes (no CORS needed if same origin)
app.on(["GET", "POST"], "/api/auth/*", async (c) => {
  return auth.handler(c.req.raw);
});

// Mount server framework routes with CORS
app.route("/", serverApp);

export default app;
```

---

// File: guides/openapi-documentation

# OpenAPI Documentation

Automatically generate and serve OpenAPI 3.0 documentation for your API using Zod 4's native `toJSONSchema()` function.

## Quick Start

Use `createDocsRouter` to automatically generate and serve OpenAPI documentation:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const apiRouter = factory.router()
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string().email(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "Alice",
    email: "alice@example.com",
  }))
  .post("/users", {
    input: {
      body: z.object({
        name: z.string(),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
  }));

// Create docs router
const docsRouter = createDocsRouter(
  { api: apiRouter },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Mount both routers
const app = createServer({
  api: apiRouter,
  docs: docsRouter,
});
```

Now you can access:
- OpenAPI JSON spec at `/docs/openapi.json` (path determined by mount prefix `docs`)
- Interactive Swagger UI at `/docs` (path determined by mount prefix `docs`)

## Basic Usage

The `createDocsRouter` function takes the same router configuration as `createServer`, allowing it to automatically discover all your routes and generate complete OpenAPI documentation.

```typescript
import { init, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const router = factory.router()
  .get("/items", {
    input: {},
    output: z.array(z.object({ id: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter({ api: router });
```

## Customization Options

Customize paths, metadata, and enable/disable features:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    // OpenAPI metadata
    title: "Todo API",
    version: "2.0.0",
    description: "A simple todo API",
    
    // Custom OpenAPI spec path
    openapiPath: "openapi.json", // Default: "openapi.json"
    // Note: The docs path is determined by the router prefix when mounting in createServer
    
    // Enable/disable interactive docs
    enableDocs: true, // Default: true
  }
);
```

## Integration with createServer

The docs router integrates seamlessly with `createServer`:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";

const factory = init();
const todosRouter = factory.router()
  .get("/", {
    input: {},
    output: z.array(z.object({ id: z.string(), title: z.string() })),
  })
  .handler(() => []);

const docsRouter = createDocsRouter(
  { todos: todosRouter },
  {
    title: "Todo API",
    version: "1.0.0",
  }
);

const app = createServer({
  todos: todosRouter,
  docs: docsRouter,
});
```

With this setup:
- API routes are available at `/todos/*`
- Documentation is available at `/docs/*`

## Manual OpenAPI Spec Generation

If you need the OpenAPI spec object directly (e.g., for external tools or custom documentation), use `generateOpenAPISpec`:

```typescript
import { generateOpenAPISpec } from "@alt-stack/server-hono";

const spec = generateOpenAPISpec(
  { api: router },
  {
    title: "My API",
    version: "1.0.0",
    description: "API documentation",
  }
);

// Use the spec with external tools
console.log(JSON.stringify(spec, null, 2));
```

## What Gets Documented

The OpenAPI documentation automatically includes:

- **All routes** from your routers
- **Path parameters** (e.g., `/{id}`)
- **Query parameters** from query schemas
- **Request bodies** for POST/PUT/PATCH operations
- **Response schemas** from output schemas
- **Error responses** from error schemas
- **Operation IDs** automatically generated from route paths

## Example: Complete API Documentation

Here's a complete example with multiple route types:

```typescript
import { init, createServer, createDocsRouter } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();
const router = factory.router()
  // GET with path and query params
  .get("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      query: z.object({
        include: z.string().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      404: z.object({
        error: z.object({
          code: z.literal("NOT_FOUND"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: "John",
    email: "john@example.com",
  }))
  
  // POST with body
  .post("/users", {
    input: {
      body: z.object({
        name: z.string().min(1),
        email: z.string().email(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
    errors: {
      400: z.object({
        error: z.object({
          code: z.literal("VALIDATION_ERROR"),
          message: z.string(),
        }),
      }),
    },
  })
  .handler((ctx) => ({
    id: "1",
    name: ctx.input.name,
    email: ctx.input.email,
  }))
  
  // PATCH with path params and body
  .patch("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
      body: z.object({
        name: z.string().optional(),
        email: z.string().email().optional(),
      }),
    },
    output: z.object({
      id: z.string(),
      name: z.string(),
      email: z.string(),
    }),
  })
  .handler((ctx) => ({
    id: ctx.input.id,
    name: ctx.input.name || "John",
    email: ctx.input.email || "john@example.com",
  }))
  
  // DELETE
  .delete("/users/{id}", {
    input: {
      params: z.object({
        id: z.string(),
      }),
    },
    output: z.object({
      success: z.boolean(),
    }),
  })
  .handler(() => ({ success: true }));

const docsRouter = createDocsRouter({ api: router });
const app = createServer({ api: router, docs: docsRouter });
```

All routes are automatically documented with proper OpenAPI 3.0 schemas.

## Disabling Interactive Docs

If you only need the JSON spec (e.g., for external tools), disable the HTML docs:

```typescript
const docsRouter = createDocsRouter(
  { api: router },
  {
    enableDocs: false, // Only serve /openapi.json, not /docs
  }
);
```

## How It Works

The OpenAPI generation uses Zod 4's native `toJSONSchema()` function with the `openapi-3.0` target. This means:

- All Zod schemas are automatically converted to JSON Schema
- Complex types (objects, arrays, unions, etc.) are properly documented
- String formats (email, UUID, URL, etc.) are recognized
- Validation constraints are included in the schema

The generated OpenAPI spec is fully compliant with OpenAPI 3.0 specification and can be used with any OpenAPI-compatible tools.

---

// File: guides/openapi-to-typescript

# OpenAPI to TypeScript

Generate TypeScript types and Zod schemas from OpenAPI specifications using the `zod-openapi` CLI.

## Installation

```bash
pnpm add @alt-stack/zod-openapi
# or
npm install @alt-stack/zod-openapi
```

## CLI Usage

```bash
npx zod-openapi <input> [options]
```

### Options

| Option | Description |
|--------|-------------|
| `-o, --output <file>` | Output file path (default: `generated-types.ts`) |
| `-r, --registry <file>` | Registry file that registers custom schemas |
| `-i, --include <file>` | TypeScript file to include at top of generated output |
| `-h, --help` | Show help message |

### Basic Examples

```bash
# Generate from local file
npx zod-openapi openapi.json

# Generate from URL (e.g., from your running server)
npx zod-openapi http://localhost:3000/docs/openapi.json

# Specify output file
npx zod-openapi openapi.json -o src/api-types.ts
```

## Generated Output

Given an OpenAPI spec, the CLI generates:

- **Zod schemas** for all component schemas
- **TypeScript types** inferred from the Zod schemas
- **Request schemas** for params, query, headers, and body
- **Response schemas** for all status codes
- **Lookup objects** (`Request` and `Response`) for easy access

### Example

For an OpenAPI spec with a `User` schema and `/users/{id}` endpoint:

```typescript
/**
 * This file was automatically generated from OpenAPI schema
 * Do not manually edit this file
 */

import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string(),
  name: z.string(),
  email: z.string().email(),
});
export type User = z.infer<typeof UserSchema>;

export const GetUsersIdParams = z.object({ id: z.string() });
export const GetUsersId200Response = UserSchema;

export const Request = {
  '/users/{id}': {
    GET: {
      params: GetUsersIdParams,
    },
  },
} as const;

export const Response = {
  '/users/{id}': {
    GET: {
      '200': GetUsersId200Response,
    },
  },
} as const;
```

## Custom String Formats

For custom type mappings (e.g., using Luxon `DateTime` for `iso-date` format), use the `--registry` and `--include` flags.

### Step 1: Create a Registry File

The registry file registers format-to-schema mappings that the CLI uses during code generation:

```typescript title="registry.ts"
import { z } from "zod";
import { registerZodSchemaToOpenApiSchema } from "@alt-stack/zod-openapi";

// Register DateTimeSchema for iso-date and iso-date-time formats
const dateTimeSchema = z.string();
registerZodSchemaToOpenApiSchema(dateTimeSchema, {
  schemaExportedVariableName: "DateTimeSchema",
  type: "string",
  formats: ["iso-date", "iso-date-time"],
});
```

### Step 2: Create an Include File

The include file contains imports and schema definitions that will be injected at the top of the generated output:

```typescript title="custom-schemas.ts"
import { DateTime } from "luxon";

export const DateTimeSchema = z
  .string()
  .transform((v) => DateTime.fromISO(v));
```

### Step 3: Run the CLI

```bash
npx zod-openapi openapi.json \
  -r ./registry.ts \
  -i ./custom-schemas.ts \
  -o src/api-types.ts
```

The generated output will:
1. Include the contents of `custom-schemas.ts` at the top
2. Use `DateTimeSchema` for any fields with `format: "iso-date"` or `format: "iso-date-time"`

### Supported String Formats

The following string formats can be registered:

- `color-hex`
- `date`
- `date-time`
- `email`
- `iso-date`
- `iso-date-time`
- `objectid`
- `uri`
- `url`
- `uuid`

## Integration with @alt-stack/server

A typical workflow with `@alt-stack/server-hono`:

1. **Define your API** with Zod schemas on the server
2. **Generate OpenAPI spec** using `createDocsRouter`
3. **Generate client types** using the `zod-openapi` CLI

```bash
# Fetch OpenAPI from your running server and generate types
npx zod-openapi http://localhost:3000/docs/openapi.json -o src/api-types.ts
```

This gives you fully typed request/response schemas that match your server's API exactly.

## Programmatic Usage

You can also use the library programmatically:

```typescript
import { openApiToZodTsCode } from "@alt-stack/zod-openapi";

const openApiSpec = {
  components: {
    schemas: {
      User: {
        type: "object",
        properties: {
          id: { type: "string" },
          name: { type: "string" },
        },
        required: ["id", "name"],
      },
    },
  },
  paths: {
    "/users/{id}": {
      get: {
        parameters: [
          { name: "id", in: "path", required: true, schema: { type: "string" } },
        ],
        responses: {
          "200": {
            content: {
              "application/json": {
                schema: { $ref: "#/components/schemas/User" },
              },
            },
          },
        },
      },
    },
  },
};

const generatedCode = openApiToZodTsCode(
  openApiSpec,
  ['import { DateTime } from "luxon";'], // custom imports
  { includeRoutes: true }
);

console.log(generatedCode);
```

---

// File: guides/protected-routes

# Protected Routes

Follow the tRPC authorization pattern for type-safe protected routes. The middleware can pass an updated context to `next()` to narrow types.

## Reusable Procedures Pattern (Recommended)

The recommended way to create protected routes is using reusable procedures:

```typescript
import { router, publicProcedure, init, createServer } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; name: string } | null;
}

const factory = init<AppContext>();

// Create reusable procedures
const publicProc = publicProcedure;
const protectedProcedure = factory.procedure
  .errors({
    401: z.object({
      error: z.object({
        code: z.literal("UNAUTHORIZED"),
        message: z.string(),
      }),
    }),
  })
  .use(async function isAuthed(opts) {
    const { ctx, next } = opts;
    if (!ctx.user) {
      throw ctx.error({
        error: {
          code: "UNAUTHORIZED" as const,
          message: "Authentication required",
        },
      });
    }
    return next({
      ctx: {
        user: ctx.user,
      },
    });
  });

// Use procedures to create routes
export const appRouter = router({
  hello: publicProc.get(() => "hello world"),

  secret: protectedProcedure
    .input({})
    .output(
      z.object({
        secret: z.string(),
      })
    )
    .get(() => ({
      secret: "sauce",
    })),
});

const app = createServer({ api: appRouter });
```

See the [Reusable Procedures guide](/core-concepts/reusable-procedures) for more details.

## Procedure-Level Middleware Pattern

The middleware can narrow the context type by passing an updated context to `next()`:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string; name: string } | null;
}

const factory = init<AppContext>();

export const protectedRouter = router({
  profile: factory.procedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
        name: z.string(),
      })
    )
    .errors({
      401: z.object({
        error: z.object({
          code: z.literal("UNAUTHORIZED"),
          message: z.string(),
        }),
      }),
    })
    .use(async function isAuthed(opts) {
      const { ctx, next } = opts;
      // `ctx.user` is nullable
      if (!ctx.user) {
        throw ctx.error({
          error: {
            code: "UNAUTHORIZED" as const,
            message: "Authentication required",
          },
        });
      }
      // ✅ Pass updated context where user is non-null (tRPC pattern)
      // This allows the context to have user as non-null for subsequent handlers
      return next({
        ctx: {
          user: ctx.user, // ✅ user value is known to be non-null now
        },
      });
    })
    .get((opts) => {
      // ✅ opts.ctx.user is now guaranteed to be non-null after the middleware
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
        name: ctx.user!.name,
      };
    }),
});
```

## Mixed Public and Protected Routes

You can mix public and protected routes in the same router:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; email: string } | null;
}

const factory = init<AppContext>();

const publicProc = publicProcedure;
const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }
  return next({ ctx: { user: ctx.user } });
});

export const appRouter = router({
  public: publicProc.get(() => ({ message: "Public content" })),

  private: protectedProcedure
    .input({})
    .output(
      z.object({
        id: z.string(),
        email: z.string(),
      })
    )
    .get((opts) => {
      const { ctx } = opts;
      return {
        id: ctx.user!.id,
        email: ctx.user!.email,
      };
    }),
});
```

## Role-Based Access Control

You can validate user roles, permissions, or other attributes:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

interface AppContext {
  user: { id: string; role: string; permissions: string[] } | null;
}

const factory = init<AppContext>();

// Middleware that requires specific role
const requireRole = (role: "admin" | "user" | "moderator") => {
  return factory.procedure.use(async (opts) => {
    const { ctx, next } = opts;
    if (!ctx.user) {
      return new Response("Unauthorized", { status: 401 });
    }
    if (ctx.user.role !== role) {
      return new Response("Forbidden", { status: 403 });
    }
    return next({ ctx: { user: ctx.user } });
  });
};

const adminProcedure = requireRole("admin");
const moderatorProcedure = requireRole("moderator");

export const adminRouter = router({
  users: adminProcedure
    .input({})
    .output(z.array(z.object({ id: z.string(), name: z.string() })))
    .get(() => {
      return getAllUsers();
    }),
});

export const moderatorRouter = router({
  moderate: moderatorProcedure
    .input({
      body: z.object({ action: z.string() }),
    })
    .post(() => {
      return { success: true };
    }),
});
```

## Type-Safe User Context

For better type safety, use Zod's type inference to create authenticated context types:

```typescript
import { router, publicProcedure, init } from "@alt-stack/server-hono";
import { z } from "zod";

// Your validated user schema
const UserSchema = z.object({
  id: z.string(),
  email: z.string().email(),
  name: z.string(),
  role: z.enum(["admin", "user", "moderator"]),
  permissions: z.array(z.string()),
});

type User = z.infer<typeof UserSchema>;

interface AppContext {
  user: User | null;
}

const factory = init<AppContext>();

const protectedProcedure = factory.procedure.use(async (opts) => {
  const { ctx, next } = opts;
  if (!ctx.user) {
    return new Response("Unauthorized", { status: 401 });
  }

  // Optionally re-validate to ensure type safety
  const validatedUser = UserSchema.parse(ctx.user);

  // Return context with validated user
  return next({ ctx: { user: validatedUser } });
});

export const appRouter = router({
  profile: protectedProcedure
    .input({})
    .output(UserSchema)
    .get((opts) => {
      // opts.ctx.user is validated and typed
      const { ctx } = opts;
      return ctx.user!;
    }),
});
```

---

// File: intro

# Introduction

Altstack is a type-safe full-stack framework with separate server and client packages, built with Zod validation. Inspired by tRPC's builder pattern, providing full type inference from a central router definition.

## Architecture

Altstack's server framework is split into a core package and framework-specific adapters:

### Server Packages

- **`@alt-stack/server-core`**: Framework-agnostic core containing types, router, middleware, and validation logic. Used as a dependency by the adapter packages.

- **`@alt-stack/server-hono`**: [Hono](https://hono.dev/) adapter - creates a Hono app with full type inference. **Recommended for new projects.**

- **`@alt-stack/server-express`**: [Express](https://expressjs.com/) adapter - creates an Express app with the same type-safe API.

### Client Package

- **`@alt-stack/client`**: A type-safe API client that works seamlessly with server-generated types

## Choosing an Adapter

| Feature | Hono | Express |
|---------|------|---------|
| Performance | Faster (Web Standards) | Mature ecosystem |
| Edge/Serverless | Native support | Requires adapters |
| Context access | `ctx.hono` | `ctx.express.req/res` |
| Best for | New projects, edge | Existing Express apps |

## Server Features

- **Type-safe routes**: Full TypeScript inference from Zod schemas
- **Builder pattern**: Fluent API for defining routes with `.get()`, `.post()`, etc.
- **Type-safe errors**: `ctx.error()` with automatic status code inference from error schemas
- **Reusable procedures**: Create reusable procedures with middleware (tRPC-style pattern)
- **Middleware support**: Procedure-level middleware with context extension
- **Router combination**: Merge multiple routers with `.merge()`
- **Validation**: Automatic Zod validation for inputs and optional outputs
- **OpenAPI generation**: Generate OpenAPI specs and interactive Swagger UI
- **Native framework access**: Full access to underlying framework APIs

## Client Features

- **Type-safe API calls**: Full TypeScript inference from server-generated types
- **Automatic validation**: Runtime validation using Zod schemas
- **Retry logic**: Built-in exponential backoff for failed requests
- **Path interpolation**: Automatic handling of path parameters
- **Error handling**: Typed error responses with detailed error information

## Quick Example

```typescript
import { init, createServer, router } from "@alt-stack/server-hono";
import { z } from "zod";

const factory = init();

const appRouter = router({
  "/hello": factory.procedure
    .output(z.object({ message: z.string() }))
    .get(() => ({ message: "Hello, World!" })),
});

const app = createServer({ api: appRouter });
export default app;
```

---

// File: kafka/core-concepts/combining-routers

# Combining Routers

Organize consumers by domain using nested routers.

## Nested Routers

Use nested `kafkaRouter` for topic prefixing:

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";

const { procedure } = init<AppContext>();

const userRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: UserCreatedSchema }).subscribe(handleUserCreated),
  updated: procedure.input({ message: UserUpdatedSchema }).subscribe(handleUserUpdated),
});

const orderRouter = kafkaRouter<AppContext>({
  created: procedure.input({ message: OrderCreatedSchema }).subscribe(handleOrderCreated),
  cancelled: procedure.input({ message: OrderCancelledSchema }).subscribe(handleOrderCancelled),
});

// Topics become: users/created, users/updated, orders/created, orders/cancelled
const mainRouter = kafkaRouter<AppContext>({
  users: userRouter,
  orders: orderRouter,
});
```

## Merging Flat Routers

Use `mergeKafkaRouters` to combine routers without prefixing:

```typescript
import { mergeKafkaRouters } from "@alt-stack/kafka-core";

const router1 = kafkaRouter({
  "user-events": procedure.input({ message: UserSchema }).subscribe(() => {}),
});

const router2 = kafkaRouter({
  "order-events": procedure.input({ message: OrderSchema }).subscribe(() => {}),
});

// Topics remain: user-events, order-events (no prefix)
const mainRouter = mergeKafkaRouters(router1, router2);
```

## Using init() Factory

```typescript
const { router, mergeRouters, procedure } = init<AppContext>();

const r1 = router();
r1.registerProcedure("events", procedure.input({ message: Schema }).subscribe(() => {}));

const r2 = router();
r2.registerProcedure("other", procedure.input({ message: Schema }).subscribe(() => {}));

const merged = mergeRouters(r1, r2);
```

---

// File: kafka/core-concepts/consumers

# Consumers

Create Kafka consumers from routers.

## Basic Setup

```typescript
import { createConsumer, kafkaRouter, init } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: z.object({ userId: z.string() }) })
    .subscribe(({ input }) => {
      console.log(input.userId);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-app",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});

// Consumer is connected and running
```

## Kafka Config Options

Pass config directly instead of a Kafka instance:

```typescript
const consumer = await createConsumer(router, {
  kafka: {
    clientId: "my-app",
    brokers: ["localhost:9092"],
    ssl: true,
    sasl: {
      mechanism: "plain",
      username: "user",
      password: "pass",
    },
  },
  groupId: "my-consumer-group",
});
```

## Consumer Options

```typescript
const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-consumer-group",
  consumerConfig: {
    sessionTimeout: 30000,
    heartbeatInterval: 3000,
    maxBytesPerPartition: 1048576,
  },
  createContext: (baseCtx) => ({ logger: getLogger() }),
  onError: (error) => console.error("Consumer error:", error),
});
```

## Graceful Shutdown

```typescript
const consumer = await createConsumer(router, options);

process.on("SIGTERM", async () => {
  await consumer.disconnect();
  process.exit(0);
});
```

---

// File: kafka/core-concepts/custom-context

# Custom Context

Extend the base context with application-specific properties.

## Base Context

Every handler receives:

```typescript
interface BaseKafkaContext {
  message: KafkaMessage; // Full kafkajs message (value, key, headers, timestamp)
  topic: string;
  partition: number;
  offset: string;
}
```

## Defining Custom Context

```typescript
import { init, kafkaRouter, createConsumer, type BaseKafkaContext } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
  db: Database;
}

// Initialize with context type
const { procedure } = init<AppContext>();

const router = kafkaRouter<AppContext>({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx has logger, db, plus base context
      ctx.logger.log(`Processing user ${input.userId}`);
      ctx.db.save(input);
    }),
});
```

## Creating Context

Provide `createContext` to the consumer:

```typescript
function createContext(baseCtx: BaseKafkaContext): AppContext {
  return {
    logger: {
      log: (msg: string) =>
        console.log(`[${baseCtx.topic}:${baseCtx.partition}] ${msg}`),
    },
    db: getDatabase(),
  };
}

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  createContext,
});
```

## Async Context

```typescript
async function createContext(baseCtx: BaseKafkaContext): Promise<AppContext> {
  const db = await getConnectionFromPool();
  return { logger: getLogger(), db };
}
```

## Middleware Context Extension

Middleware can add to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await authenticate(ctx.message.headers);
  return next({ ctx: { user } });
});

const router = kafkaRouter<AppContext>({
  protected: authMiddleware
    .input({ message: Schema })
    .subscribe(({ ctx }) => {
      // ctx.user is available
    }),
});
```

---

// File: kafka/core-concepts/error-handling

# Error Handling

Define typed error schemas for structured error handling.

## Error Schemas

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "process-order": procedure
    .input({
      message: z.object({
        orderId: z.string(),
        amount: z.number(),
      }),
    })
    .errors({
      INVALID_ORDER: z.object({
        error: z.object({
          code: z.literal("INVALID_ORDER"),
          message: z.string(),
          orderId: z.string(),
        }),
      }),
      INSUFFICIENT_FUNDS: z.object({
        error: z.object({
          code: z.literal("INSUFFICIENT_FUNDS"),
          message: z.string(),
          required: z.number(),
          available: z.number(),
        }),
      }),
    })
    .subscribe(({ input, ctx }) => {
      if (!isValidOrder(input.orderId)) {
        throw ctx.error({
          error: {
            code: "INVALID_ORDER",
            message: "Order not found",
            orderId: input.orderId,
          },
        });
      }

      const available = getAvailableFunds();
      if (input.amount > available) {
        throw ctx.error({
          error: {
            code: "INSUFFICIENT_FUNDS",
            message: "Insufficient funds",
            required: input.amount,
            available,
          },
        });
      }

      processOrder(input);
    }),
});
```

## Consumer Error Handling

```typescript
import { createConsumer, ProcessingError } from "@alt-stack/kafka-core";

const consumer = await createConsumer(router, {
  kafka: new Kafka({ brokers: ["localhost:9092"] }),
  groupId: "my-group",
  onError: (error) => {
    if (error instanceof ProcessingError) {
      console.error("Processing error:", error.code, error.details);
      sendToDeadLetterQueue(error);
    } else {
      console.error("Unexpected error:", error);
    }
  },
});
```

## Error Types

The library exports:

- `KafkaError` - Base error class with `code`, `message`, and optional `details`
- `ValidationError` - Schema validation failures
- `ProcessingError` - Handler execution errors

---

// File: kafka/core-concepts/middleware

# Middleware

Add cross-cutting concerns like logging, metrics, or authentication.

## Basic Middleware

```typescript
const { procedure } = init();

const loggedProcedure = procedure.use(async ({ ctx, next }) => {
  console.log(`Processing message from ${ctx.topic}`);
  const result = await next();
  console.log(`Completed processing`);
  return result;
});

const router = kafkaRouter({
  events: loggedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input }) => {
      // Logging middleware runs before/after this
    }),
});
```

## Context Extension

Middleware can add properties to context:

```typescript
const authMiddleware = procedure.use(async ({ ctx, next }) => {
  const user = await getUserFromMessage(ctx.message);
  return next({ ctx: { user } });
});

const router = kafkaRouter({
  "protected-events": authMiddleware
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {
      // ctx.user is available and typed
      console.log(`User: ${ctx.user.name}`);
    }),
});
```

## Reusable Middleware with createMiddleware

```typescript
import { createMiddleware } from "@alt-stack/kafka-core";

interface AppContext {
  logger: Logger;
}

const metricsMiddleware = createMiddleware<AppContext>()(async ({ ctx, next }) => {
  const start = Date.now();
  const result = await next();
  const duration = Date.now() - start;
  metrics.recordDuration(ctx.topic, duration);
  return result;
});
```

## Chaining Middleware

```typescript
const { procedure } = init<AppContext>();

const protectedProcedure = procedure
  .use(loggingMiddleware)
  .use(authMiddleware)
  .use(metricsMiddleware);

// All three middleware run in order
const router = kafkaRouter({
  events: protectedProcedure
    .input({ message: EventSchema })
    .subscribe(({ input, ctx }) => {}),
});
```

## Piping Middleware Builders

```typescript
const authChain = createMiddleware<AppContext>()
  .pipe(validateSession)
  .pipe(loadUser);

// Use the chain
const protectedProcedure = procedure.use(authChain);
```

---

// File: kafka/core-concepts/producers

# Producers

Create type-safe Kafka producers using AsyncAPI-generated types.

## Installation

```bash
# Core + KafkaJS binding
pnpm add @alt-stack/kafka-core-client-core @alt-stack/kafka-core-client-kafkajs kafkajs zod

# Or for WarpStream
pnpm add @alt-stack/kafka-core-client-core @alt-stack/kafka-core-client-warpstream kafkajs zod
```

## Basic Setup

Use types generated from your AsyncAPI spec with `zod-asyncapi`:

```typescript
// 1. Generate types from AsyncAPI spec
// npx zod-asyncapi asyncapi.json -o ./generated-types.ts

// 2. Import generated types
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-core-client-kafkajs";

// 3. Create type-safe client
const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// 4. Send messages with full type safety
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

## KafkaJS Client

```typescript
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-core-client-kafkajs";

const client = await createKafkaClient({
  kafka: {
    brokers: ["localhost:9092"],
    clientId: "my-app",
    ssl: true,
    sasl: { mechanism: "plain", username: "user", password: "pass" },
  },
  topics: Topics,
  producerConfig: {
    allowAutoTopicCreation: false,
  },
  onError: (error) => console.error("Producer error:", error),
});
```

## WarpStream Client

Optimized for WarpStream with recommended defaults (LZ4 compression, extended timeouts):

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-core-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
  clientId: "my-producer",
});
```

## Type-Safe Sending

```typescript
// TypeScript enforces valid topics and message shapes
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});

// Type error: "invalid-topic" doesn't exist
await client.send("invalid-topic", { data: "test" });

// Type error: missing required field
await client.send("user-events", { userId: "123" });
```

## Batch Sending

```typescript
await client.sendBatch("user-events", [
  { userId: "user-1", eventType: "created", timestamp: Date.now() },
  { userId: "user-2", eventType: "created", timestamp: Date.now() },
  { userId: "user-1", eventType: "updated", timestamp: Date.now() },
]);
```

## Send Options

```typescript
await client.send(
  "user-events",
  { userId: "123", eventType: "created", timestamp: Date.now() },
  {
    key: "user-123",              // Message key for partitioning
    partition: 0,                 // Explicit partition
    headers: { source: "api" },   // Custom headers
    timestamp: Date.now().toString(),
  }
);
```

## Disconnecting

```typescript
await client.disconnect();
```

## Accessing Raw Producer

For advanced use cases (transactions, producer events, etc.), access the underlying KafkaJS producer:

```typescript
// Access the raw kafkajs Producer
const rawProducer = client.producer;

// Use kafkajs features directly
await rawProducer.send({
  topic: "my-topic",
  messages: [{ value: "raw message" }],
  acks: -1,
  timeout: 30000,
});
```

## Error Handling

```typescript
import { ValidationError, SendError, ConnectionError } from "@alt-stack/kafka-core-client-kafkajs";

try {
  await client.send("user-events", invalidData);
} catch (error) {
  if (error instanceof ValidationError) {
    console.error("Invalid message:", error.topic, error.details);
  } else if (error instanceof SendError) {
    console.error("Failed to send:", error.topic, error.cause);
  } else if (error instanceof ConnectionError) {
    console.error("Connection failed:", error.cause);
  }
}
```

---

// File: kafka/core-concepts/topics-and-procedures

# Topics and Procedures

Define Kafka topics with type-safe message schemas using `kafkaRouter`.

## Basic Topic Definition

```typescript
import { init, kafkaRouter } from "@alt-stack/kafka-core";
import { z } from "zod";

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({
      message: z.object({
        userId: z.string(),
        eventType: z.string(),
      }),
    })
    .subscribe(({ input }) => {
      // input is the validated message
      console.log(input.userId);
    }),
});
```

## Message Validation

Messages are validated before the handler runs:

```typescript
const router = kafkaRouter({
  orders: procedure
    .input({
      message: z.object({
        orderId: z.string().uuid(),
        amount: z.number().positive(),
        currency: z.string().length(3),
      }),
    })
    .subscribe(({ input }) => {
      // Only called if message passes validation
      processOrder(input);
    }),
});
```

## Multiple Topics

```typescript
const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input }) => handleUserEvent(input)),

  "order-events": procedure
    .input({ message: OrderEventSchema })
    .subscribe(({ input }) => handleOrderEvent(input)),
});
```

## Output Validation

Optionally validate handler return values:

```typescript
const router = kafkaRouter({
  "process-data": procedure
    .input({
      message: z.object({ data: z.string() }),
    })
    .output(
      z.object({
        processed: z.boolean(),
        result: z.string(),
      })
    )
    .subscribe(({ input }) => ({
      processed: true,
      result: input.data.toUpperCase(),
    })),
});
```

## subscribe vs handler

- `.subscribe()` - Use in `kafkaRouter({})` config (topic determined by key)
- `.handler()` - Creates a pending procedure for manual registration

```typescript
// Using subscribe (recommended)
const router = kafkaRouter({
  "my-topic": procedure.input({ message: Schema }).subscribe(({ input }) => {}),
});

// Using handler for manual registration
const pendingProc = procedure.input({ message: Schema }).handler(({ input }) => {});
const router = createKafkaRouter();
router.registerPendingProcedure("my-topic", pendingProc);
```

---

// File: kafka/getting-started/installation

# Installation

```bash
pnpm add @alt-stack/kafka-core kafkajs zod
```

## Peer Dependencies

- **kafkajs**: `^2.0.0` - Kafka client
- **zod**: `^3.25.0` - Schema validation

---

// File: kafka/getting-started/quickstart

# Quickstart

## Consumer

```typescript
import { init, kafkaRouter, createConsumer } from "@alt-stack/kafka-core";
import { Kafka } from "kafkajs";
import { z } from "zod";

const UserEventSchema = z.object({
  userId: z.string(),
  eventType: z.enum(["created", "updated", "deleted"]),
  timestamp: z.number(),
});

const { procedure } = init();

const router = kafkaRouter({
  "user-events": procedure
    .input({ message: UserEventSchema })
    .subscribe(({ input, ctx }) => {
      console.log(`Event: ${input.eventType} for user ${input.userId}`);
    }),
});

const consumer = await createConsumer(router, {
  kafka: new Kafka({
    clientId: "my-consumer",
    brokers: ["localhost:9092"],
  }),
  groupId: "my-consumer-group",
});
```

## Producer (using Kafka Client)

For producers, use the Kafka client packages with AsyncAPI-generated types:

```typescript
// 1. Generate types: npx zod-asyncapi asyncapi.json -o ./generated-types.ts
import { Topics } from "./generated-types";
import { createKafkaClient } from "@alt-stack/kafka-core-client-kafkajs";

const client = await createKafkaClient({
  kafka: { brokers: ["localhost:9092"], clientId: "my-producer" },
  topics: Topics,
});

// Type-safe sending
await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```

Or with WarpStream:

```typescript
import { Topics } from "./generated-types";
import { createWarpStreamClient } from "@alt-stack/kafka-core-client-warpstream";

const client = await createWarpStreamClient({
  bootstrapServer: "my-cluster.warpstream.com:9092",
  topics: Topics,
});

await client.send("user-events", {
  userId: "user-123",
  eventType: "created",
  timestamp: Date.now(),
});
```