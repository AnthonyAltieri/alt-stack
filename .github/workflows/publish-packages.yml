name: Publish Packages

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no publishing, tagging, or committing)'
        required: false
        default: 'false'
        type: boolean

jobs:
  detect-unpublished:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_packages: ${{ steps.set-matrix.outputs.has_packages }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-store-
        continue-on-error: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check if SDK regeneration needed
        id: sdk-check
        shell: bash
        run: |
          KAFKA_PRODUCER_CHANGED=false
          ALTSTACK_SERVER_CHANGED=false
          CHANGED_FILES=$(git diff --name-only HEAD^1 HEAD 2>/dev/null || echo "")

          if echo "$CHANGED_FILES" | grep -q "^apps/example-kafka-producer/"; then
            KAFKA_PRODUCER_CHANGED=true
            echo "ğŸ“¦ Kafka producer app changed - will regenerate SDK"
          fi

          if echo "$CHANGED_FILES" | grep -q "^apps/example-altstack-server/"; then
            ALTSTACK_SERVER_CHANGED=true
            echo "ğŸ“¦ Altstack server app changed - will regenerate SDK"
          fi

          echo "kafka_producer_changed=$KAFKA_PRODUCER_CHANGED" >> $GITHUB_OUTPUT
          echo "altstack_server_changed=$ALTSTACK_SERVER_CHANGED" >> $GITHUB_OUTPUT

      - name: Build core packages for SDK generation
        if: steps.sdk-check.outputs.kafka_producer_changed == 'true' || steps.sdk-check.outputs.altstack_server_changed == 'true'
        run: |
          pnpm --filter @alt-stack/result build
          pnpm --filter @alt-stack/zod-openapi build
          pnpm --filter @alt-stack/zod-asyncapi build
          pnpm --filter @alt-stack/kafka-core build
          pnpm --filter @alt-stack/server-core build
          pnpm --filter @alt-stack/server-hono build

      - name: Regenerate Kafka Producer SDK
        if: steps.sdk-check.outputs.kafka_producer_changed == 'true'
        run: |
          echo "ğŸ”„ Regenerating Kafka Producer SDK..."
          cd apps/example-kafka-producer
          pnpm generate-spec
          echo "âœ“ Generated AsyncAPI spec"
          cd ../..
          pnpm --filter @alt-stack/zod-asyncapi exec tsx src/cli.ts \
            ${{ github.workspace }}/apps/example-kafka-producer/asyncapi.json \
            -o ${{ github.workspace }}/packages/example-kafka-producer-sdk/src/index.ts
          echo "âœ“ Regenerated example-kafka-producer-sdk"

      - name: Regenerate Altstack Server SDK
        if: steps.sdk-check.outputs.altstack_server_changed == 'true'
        run: |
          echo "ğŸ”„ Regenerating Altstack Server SDK..."
          cd apps/example-altstack-server
          pnpm dev > server.log 2>&1 &
          SERVER_PID=$!
          MAX_ATTEMPTS=30
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            sleep 2
            if curl -f -s http://localhost:3000/docs/openapi.json > /dev/null 2>&1; then
              echo "âœ“ Server is ready"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "Waiting for server... attempt $ATTEMPT/$MAX_ATTEMPTS"
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âœ— Server failed to start"
            cat server.log || true
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi

          cd ../..
          pnpm --filter @alt-stack/zod-openapi exec tsx src/cli.ts \
            http://localhost:3000/docs/openapi.json \
            -o ${{ github.workspace }}/packages/example-altstack-server-sdk/src/index.ts
          kill $SERVER_PID 2>/dev/null || true
          echo "âœ“ Regenerated example-altstack-server-sdk"

      - name: Detect packages with unpublished versions
        id: set-matrix
        shell: bash
        run: |
          node << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');

          const packageDirs = fs.readdirSync('packages')
            .map(dir => path.join('packages', dir))
            .filter(dir => {
              const pkgPath = path.join(dir, 'package.json');
              if (!fs.existsSync(pkgPath)) return false;
              try {
                const pkgJson = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
                return pkgJson.name?.startsWith('@alt-stack/') && pkgJson.name !== '@alt-stack/typescript-config';
              } catch { return false; }
            });

          const matrix = [];

          for (const dir of packageDirs) {
            const pkgJson = JSON.parse(fs.readFileSync(path.join(dir, 'package.json'), 'utf-8'));
            const pkgName = pkgJson.name;
            const localVersion = pkgJson.version;

            // Check if this version exists on npm
            let npmVersion = null;
            try {
              npmVersion = execSync(`npm view "${pkgName}@${localVersion}" version 2>/dev/null`, {
                encoding: 'utf-8',
                stdio: ['pipe', 'pipe', 'pipe']
              }).trim();
            } catch {
              // Version doesn't exist on npm
            }

            if (!npmVersion) {
              console.log(`ğŸ“¦ ${pkgName}@${localVersion} not on npm - will publish`);
              matrix.push({ name: pkgName, directory: dir, version: localVersion });
            } else {
              console.log(`âœ“ ${pkgName}@${localVersion} already on npm - skipping`);
            }
          }

          console.log('\nPackages to publish:', JSON.stringify(matrix, null, 2));
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `matrix=${JSON.stringify({ include: matrix })}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `has_packages=${matrix.length > 0}\n`);
          EOF

  publish:
    needs: detect-unpublished
    if: needs.detect-unpublished.outputs.has_packages == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-unpublished.outputs.matrix) }}
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org/'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-store-
        continue-on-error: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Build package
        shell: bash
        run: |
          PKG_JSON="${{ matrix.directory }}/package.json"
          if node -e "const p=require('./$PKG_JSON'); process.exit(p.scripts?.build ? 0 : 1)" 2>/dev/null; then
            echo "Building ${{ matrix.name }}..."
            pnpm turbo run build --filter="${{ matrix.name }}"
            echo "âœ“ Successfully built ${{ matrix.name }}"
          else
            echo "No build script found for ${{ matrix.name }}, skipping build"
          fi

      - name: Configure npm
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "Error: NPM_TOKEN secret is required"
            exit 1
          fi
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > .npmrc

      - name: Publish package
        shell: bash
        run: |
          if [ "$DRY_RUN" == "true" ]; then
            echo "ğŸ§ª [DRY-RUN] Would publish ${{ matrix.name }}@${{ matrix.version }}"
          else
            echo "Publishing ${{ matrix.name }}@${{ matrix.version }}..."
            cd "${{ matrix.directory }}"
            pnpm publish --access public --no-git-checks
            echo "âœ“ Successfully published ${{ matrix.name }}@${{ matrix.version }}"
          fi

      - name: Create git tag
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          TAG_NAME="${{ matrix.name }}@${{ matrix.version }}"
          echo "Creating tag: $TAG_NAME"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME" 2>/dev/null || echo "Tag $TAG_NAME already exists"

      - name: Upload git tag
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          mkdir -p /tmp/tags
          echo "${{ matrix.name }}@${{ matrix.version }}" > /tmp/tags/${{ hashFiles(format('{0}/package.json', matrix.directory)) }}.txt

      - name: Upload tag artifact
        if: env.DRY_RUN != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: git-tag-${{ hashFiles(format('{0}/package.json', matrix.directory)) }}
          path: /tmp/tags/
          retention-days: 1

      - name: Dry-run summary
        if: env.DRY_RUN == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ§ª DRY-RUN SUMMARY for ${{ matrix.name }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  â€¢ Would publish: ${{ matrix.name }}@${{ matrix.version }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  finalize:
    needs: [detect-unpublished, publish]
    if: always() && needs.detect-unpublished.outputs.has_packages == 'true' && needs.publish.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Download all tag artifacts
        if: env.DRY_RUN != 'true'
        uses: actions/download-artifact@v4
        with:
          pattern: git-tag-*
          path: /tmp/tags
          merge-multiple: true
        continue-on-error: true

      - name: Push tags
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          shopt -s nullglob
          for tag_file in /tmp/tags/*.txt; do
            if [ -f "$tag_file" ]; then
              TAG_NAME=$(cat "$tag_file")
              echo "Creating tag: $TAG_NAME"
              git tag -a "$TAG_NAME" -m "Release $TAG_NAME" 2>/dev/null || echo "Tag $TAG_NAME already exists"
            fi
          done
          shopt -u nullglob

          git push origin --tags || echo "No new tags to push"

      - name: Dry-run final summary
        if: env.DRY_RUN == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ§ª DRY-RUN COMPLETE"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… All checks passed! This workflow would have:"
          echo "  â€¢ Published packages to npm"
          echo "  â€¢ Created git tags"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
