name: Publish Packages

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Run in dry-run mode (no publishing, tagging, or committing)'
        required: false
        default: 'false'
        type: boolean

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      has_packages: ${{ steps.set-matrix.outputs.has_packages }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-store-
        continue-on-error: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Check if SDK regeneration needed
        id: sdk-check
        shell: bash
        run: |
          KAFKA_PRODUCER_CHANGED=false
          ALTSTACK_SERVER_CHANGED=false
          CHANGED_FILES=$(git diff --name-only HEAD^1 HEAD 2>/dev/null || echo "")
          
          if echo "$CHANGED_FILES" | grep -q "^apps/example-kafka-producer/"; then
            KAFKA_PRODUCER_CHANGED=true
            echo "ğŸ“¦ Kafka producer app changed - will regenerate SDK"
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^apps/example-altstack-server/"; then
            ALTSTACK_SERVER_CHANGED=true
            echo "ğŸ“¦ Altstack server app changed - will regenerate SDK"
          fi
          
          echo "kafka_producer_changed=$KAFKA_PRODUCER_CHANGED" >> $GITHUB_OUTPUT
          echo "altstack_server_changed=$ALTSTACK_SERVER_CHANGED" >> $GITHUB_OUTPUT

      - name: Build core packages for SDK generation
        if: steps.sdk-check.outputs.kafka_producer_changed == 'true' || steps.sdk-check.outputs.altstack_server_changed == 'true'
        run: |
          pnpm --filter @alt-stack/zod-openapi build
          pnpm --filter @alt-stack/zod-asyncapi build
          pnpm --filter @alt-stack/kafka-core build
          pnpm --filter @alt-stack/server-core build
          pnpm --filter @alt-stack/server-hono build

      - name: Regenerate Kafka Producer SDK
        if: steps.sdk-check.outputs.kafka_producer_changed == 'true'
        run: |
          echo "ğŸ”„ Regenerating Kafka Producer SDK..."
          cd apps/example-kafka-producer
          pnpm generate-spec
          echo "âœ“ Generated AsyncAPI spec"
          cd ../..
          pnpm --filter @alt-stack/zod-asyncapi exec tsx src/cli.ts \
            ${{ github.workspace }}/apps/example-kafka-producer/asyncapi.json \
            -o ${{ github.workspace }}/packages/example-kafka-producer-sdk/src/index.ts
          echo "âœ“ Regenerated example-kafka-producer-sdk"

      - name: Regenerate Altstack Server SDK
        if: steps.sdk-check.outputs.altstack_server_changed == 'true'
        run: |
          echo "ğŸ”„ Regenerating Altstack Server SDK..."
          cd apps/example-altstack-server
          pnpm dev > server.log 2>&1 &
          SERVER_PID=$!
          MAX_ATTEMPTS=30
          ATTEMPT=0
          
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            sleep 2
            if curl -f -s http://localhost:3000/docs/openapi.json > /dev/null 2>&1; then
              echo "âœ“ Server is ready"
              break
            fi
            ATTEMPT=$((ATTEMPT + 1))
            echo "Waiting for server... attempt $ATTEMPT/$MAX_ATTEMPTS"
          done
          
          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "âœ— Server failed to start"
            cat server.log || true
            kill $SERVER_PID 2>/dev/null || true
            exit 1
          fi
          
          cd ../..
          pnpm --filter @alt-stack/zod-openapi exec tsx src/cli.ts \
            http://localhost:3000/docs/openapi.json \
            -o ${{ github.workspace }}/packages/example-altstack-server-sdk/src/index.ts
          kill $SERVER_PID 2>/dev/null || true
          echo "âœ“ Regenerated example-altstack-server-sdk"

      - name: Detect changed packages and set matrix
        id: set-matrix
        shell: bash
        run: |
          node << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          
          const packageDirs = fs.readdirSync('packages')
            .map(dir => path.join('packages', dir))
            .filter(dir => {
              const pkgPath = path.join(dir, 'package.json');
              if (!fs.existsSync(pkgPath)) return false;
              try {
                const pkgJson = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
                return pkgJson.name?.startsWith('@alt-stack/') && pkgJson.name !== '@alt-stack/typescript-config';
              } catch { return false; }
            });
          
          let changedFiles = [];
          try {
            changedFiles = execSync('git diff --name-only HEAD^1 HEAD', { encoding: 'utf-8' })
              .trim().split('\n').filter(Boolean);
          } catch {
            changedFiles = execSync('git diff --name-only HEAD', { encoding: 'utf-8' })
              .trim().split('\n').filter(Boolean);
          }
          
          let turboPackages = [];
          try {
            const turboOutput = execSync('turbo run build --filter="[HEAD^1]" --dry-run=json', { 
              encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore']
            });
            const turboData = JSON.parse(turboOutput);
            if (turboData.tasks) {
              turboPackages = turboData.tasks
                .map(t => t.package)
                .filter(p => p?.startsWith('@alt-stack/') && p !== '@alt-stack/typescript-config');
            }
          } catch {}
          
          const changedPackages = new Set(turboPackages);
          
          for (const pkgDir of packageDirs) {
            const pkgJson = JSON.parse(fs.readFileSync(path.join(pkgDir, 'package.json'), 'utf-8'));
            if (changedFiles.some(f => f.startsWith(pkgDir + '/'))) {
              changedPackages.add(pkgJson.name);
            }
          }
          
          if (changedFiles.some(f => f.startsWith('apps/example-kafka-producer/'))) {
            changedPackages.add('@alt-stack/example-kafka-producer-sdk');
          }
          if (changedFiles.some(f => f.startsWith('apps/example-altstack-server/'))) {
            changedPackages.add('@alt-stack/example-altstack-server-sdk');
          }
          
          // Build matrix with package info
          const matrix = [];
          for (const pkgName of changedPackages) {
            for (const dir of packageDirs) {
              const pkgJson = JSON.parse(fs.readFileSync(path.join(dir, 'package.json'), 'utf-8'));
              if (pkgJson.name === pkgName) {
                matrix.push({ name: pkgName, directory: dir });
                break;
              }
            }
          }
          
          console.log('Changed packages:', JSON.stringify(matrix, null, 2));
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `matrix=${JSON.stringify({ include: matrix })}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `has_packages=${matrix.length > 0}\n`);
          EOF

  publish:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_packages == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          registry-url: 'https://registry.npmjs.org/'

      - name: Install pnpm
        uses: pnpm/action-setup@v4

      - name: Get pnpm store directory
        shell: bash
        run: echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: ${{ runner.os }}-pnpm-store-
        continue-on-error: true

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Analyze commits and bump version
        id: version
        shell: bash
        run: |
          node << 'EOF'
          const { execSync } = require('child_process');
          const fs = require('fs');
          const path = require('path');
          
          const pkgName = '${{ matrix.name }}';
          const pkgDir = '${{ matrix.directory }}';
          const isDryRun = process.env.DRY_RUN === 'true';
          
          const sdkToAppDir = {
            '@alt-stack/example-kafka-producer-sdk': 'apps/example-kafka-producer',
            '@alt-stack/example-altstack-server-sdk': 'apps/example-altstack-server'
          };
          
          const pkgJson = JSON.parse(fs.readFileSync(path.join(pkgDir, 'package.json'), 'utf-8'));
          const currentVersion = pkgJson.version;
          
          // Find last tag for this package
          let lastTag = null;
          try {
            const tags = execSync('git tag --sort=-version:refname', { encoding: 'utf-8' })
              .trim().split('\n').filter(Boolean);
            const pkgTagPattern = pkgName.replace('@alt-stack/', '');
            for (const tag of tags) {
              if (tag.includes(pkgTagPattern) || tag.startsWith(pkgName + '@')) {
                lastTag = tag;
                break;
              }
            }
          } catch {}
          
          let sinceRef = 'HEAD^1';
          try { execSync('git rev-parse HEAD^1', { stdio: 'ignore' }); }
          catch { sinceRef = execSync('git rev-list --max-parents=0 HEAD', { encoding: 'utf-8' }).trim(); }
          if (lastTag) sinceRef = lastTag;
          
          const commitDirs = [pkgDir];
          if (sdkToAppDir[pkgName]) commitDirs.push(sdkToAppDir[pkgName]);
          
          let commits = [];
          for (const dir of commitDirs) {
            try {
              const out = execSync(`git log ${sinceRef}..HEAD --pretty=format:"%s" -- ${dir}`,
                { encoding: 'utf-8', stdio: ['pipe', 'pipe', 'ignore'] });
              commits.push(...out.trim().split('\n').filter(Boolean));
            } catch {}
          }
          
          let bumpType = 'patch';
          let hasBreaking = false, hasFeature = false;
          for (const commit of commits) {
            if (commit.includes('BREAKING CHANGE') || commit.includes('BREAKING:') || /^[^:]+!:/.test(commit)) {
              hasBreaking = true; break;
            }
            if (/^(feat|feature)(\(.+\))?:/i.test(commit)) hasFeature = true;
          }
          if (hasBreaking) bumpType = 'major';
          else if (hasFeature) bumpType = 'minor';
          
          const [major, minor, patch] = currentVersion.split('.').map(Number);
          if (bumpType === 'major' && major === 0) {
            console.log(`Package ${pkgName} is pre-1.0, treating breaking change as minor bump`);
            bumpType = 'minor';
          }
          
          let newVersion;
          if (bumpType === 'major') newVersion = `${major + 1}.0.0`;
          else if (bumpType === 'minor') newVersion = `${major}.${minor + 1}.0`;
          else newVersion = `${major}.${minor}.${patch + 1}`;
          
          if (!isDryRun) {
            execSync(`pnpm version ${bumpType} --no-git-tag`, { cwd: pkgDir, stdio: 'inherit' });
          } else {
            console.log(`[DRY-RUN] Would bump ${pkgName} from ${currentVersion} to ${newVersion} (${bumpType})`);
          }
          
          console.log(`${isDryRun ? '[DRY-RUN] ' : ''}Bumped ${pkgName} from ${currentVersion} to ${newVersion} (${bumpType})`);
          
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `old_version=${currentVersion}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `new_version=${newVersion}\n`);
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `bump_type=${bumpType}\n`);
          EOF

      - name: Build package
        shell: bash
        run: |
          PKG_JSON="${{ matrix.directory }}/package.json"
          if node -e "const p=require('./$PKG_JSON'); process.exit(p.scripts?.build ? 0 : 1)" 2>/dev/null; then
            echo "Building ${{ matrix.name }}..."
            pnpm turbo run build --filter="${{ matrix.name }}"
            echo "âœ“ Successfully built ${{ matrix.name }}"
          else
            echo "No build script found for ${{ matrix.name }}, skipping build"
          fi

      - name: Configure npm
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          if [ -z "${{ secrets.NPM_TOKEN }}" ]; then
            echo "Error: NPM_TOKEN secret is required"
            exit 1
          fi
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > .npmrc

      - name: Publish package
        shell: bash
        run: |
          if [ "$DRY_RUN" == "true" ]; then
            echo "ğŸ§ª [DRY-RUN] Would publish ${{ matrix.name }}@${{ steps.version.outputs.new_version }}"
          else
            echo "Publishing ${{ matrix.name }}@${{ steps.version.outputs.new_version }}..."
            cd "${{ matrix.directory }}"
            pnpm publish --access public --no-git-checks
            echo "âœ“ Successfully published ${{ matrix.name }}@${{ steps.version.outputs.new_version }}"
          fi

      - name: Create git tag
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          TAG_NAME="${{ matrix.name }}@${{ steps.version.outputs.new_version }}"
          echo "Creating tag: $TAG_NAME"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"

      - name: Upload version bump info
        uses: actions/upload-artifact@v4
        with:
          name: version-bump-${{ hashFiles(format('{0}/package.json', matrix.directory)) }}
          path: ${{ matrix.directory }}/package.json
          retention-days: 1

      - name: Upload git tag
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          mkdir -p /tmp/tags
          echo "${{ matrix.name }}@${{ steps.version.outputs.new_version }}" > /tmp/tags/${{ hashFiles(format('{0}/package.json', matrix.directory)) }}.txt

      - name: Upload tag artifact
        if: env.DRY_RUN != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: git-tag-${{ hashFiles(format('{0}/package.json', matrix.directory)) }}
          path: /tmp/tags/
          retention-days: 1

      - name: Dry-run summary
        if: env.DRY_RUN == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ§ª DRY-RUN SUMMARY for ${{ matrix.name }}"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "  â€¢ ${{ matrix.name }}: ${{ steps.version.outputs.old_version }} â†’ ${{ steps.version.outputs.new_version }} (${{ steps.version.outputs.bump_type }})"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

  finalize:
    needs: [detect-changes, publish]
    if: always() && needs.detect-changes.outputs.has_packages == 'true' && needs.publish.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      DRY_RUN: ${{ github.event.inputs.dry_run == 'true' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Download all version bump artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: version-bump-*
          path: /tmp/version-bumps
          merge-multiple: true

      - name: Download all tag artifacts
        if: env.DRY_RUN != 'true'
        uses: actions/download-artifact@v4
        with:
          pattern: git-tag-*
          path: /tmp/tags
          merge-multiple: true
        continue-on-error: true

      - name: Apply version bumps
        shell: bash
        run: |
          echo "Applying version bumps from artifacts..."
          shopt -s nullglob
          for pkg_json in /tmp/version-bumps/*.json; do
            if [ -f "$pkg_json" ]; then
              PKG_NAME=$(node -e "console.log(require('$pkg_json').name)")
              # Find the target directory
              for dir in packages/*/; do
                if [ -f "${dir}package.json" ]; then
                  DIR_PKG_NAME=$(node -e "console.log(require('./${dir}package.json').name)")
                  if [ "$PKG_NAME" == "$DIR_PKG_NAME" ]; then
                    cp "$pkg_json" "${dir}package.json"
                    echo "âœ“ Updated ${dir}package.json"
                    break
                  fi
                fi
              done
            fi
          done
          shopt -u nullglob

      - name: Recreate and push tags
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          shopt -s nullglob
          for tag_file in /tmp/tags/*.txt; do
            if [ -f "$tag_file" ]; then
              TAG_NAME=$(cat "$tag_file")
              echo "Creating tag: $TAG_NAME"
              git tag -a "$TAG_NAME" -m "Release $TAG_NAME" 2>/dev/null || echo "Tag $TAG_NAME already exists"
            fi
          done
          shopt -u nullglob

          git push origin --tags || echo "No new tags to push"

      - name: Commit version changes
        if: env.DRY_RUN != 'true'
        shell: bash
        run: |
          # Add SDK source files if regenerated
          git add packages/example-kafka-producer-sdk/src/index.ts 2>/dev/null || true
          git add packages/example-altstack-server-sdk/src/index.ts 2>/dev/null || true
          git add apps/example-kafka-producer/asyncapi.json 2>/dev/null || true
          
          git add packages/*/package.json
          if git diff --staged --quiet; then
            echo "No version changes to commit"
          else
            git commit -m "chore: bump package versions [skip ci]"
            git push origin HEAD:${{ github.ref_name }}
          fi

      - name: Dry-run final summary
        if: env.DRY_RUN == 'true'
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸ§ª DRY-RUN COMPLETE"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âœ… All checks passed! This workflow would have:"
          echo "  â€¢ Published packages to npm"
          echo "  â€¢ Created git tags"
          echo "  â€¢ Committed version bumps"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
